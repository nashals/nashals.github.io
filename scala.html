<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head><!-- <meta name="baidu-site-verification" content="707024a76f8f40b549f07f478abab237"/> -->
<title>scala</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="title" content="scala"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2013-09-10 21:45:18 CST"/>
<meta name="author" content="dirtysalt"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  div.inlinetask {
    padding:10px;
    border:2px solid gray;
    margin:10px;
    background: #ffffcc;
  }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style><link rel="stylesheet" type="text/css" href="css/site-plain.css" />
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>

</head>
<body><!-- <div id="bdshare" class="bdshare_t bds_tools_32 get-codes-bdshare"><a class="bds_tsina"></a><span class="bds_more"></span><a class="shareCount"></a></div> --><!-- Place this tag where you want the +1 button to render --><g:plusone annotation="inline"></g:plusone>


<div id="content">
<h1 class="title">scala</h1>


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="scala.html#sec-1">1 scala</a>
<ul>
<li><a href="scala.html#sec-1-1">1.1 基础知识</a>
<ul>
<li><a href="scala.html#sec-1-1-1">1.1.1 标识符</a></li>
<li><a href="scala.html#sec-1-1-2">1.1.2 原始类型</a></li>
<li><a href="scala.html#sec-1-1-3">1.1.3 变量定义</a></li>
<li><a href="scala.html#sec-1-1-4">1.1.4 函数定义</a></li>
<li><a href="scala.html#sec-1-1-5">1.1.5 控制结构</a></li>
<li><a href="scala.html#sec-1-1-6">1.1.6 等值比较</a></li>
<li><a href="scala.html#sec-1-1-7">1.1.7 operator</a></li>
<li><a href="scala.html#sec-1-1-8">1.1.8 前提断言</a></li>
<li><a href="scala.html#sec-1-1-9">1.1.9 package</a></li>
</ul>
</li>
<li><a href="scala.html#sec-1-2">1.2 面向对象</a>
<ul>
<li><a href="scala.html#sec-1-2-1">1.2.1 单例对象</a></li>
<li><a href="scala.html#sec-1-2-2">1.2.2 构造函数</a></li>
<li><a href="scala.html#sec-1-2-3">1.2.3 override</a></li>
<li><a href="scala.html#sec-1-2-4">1.2.4 隐式转换</a></li>
<li><a href="scala.html#sec-1-2-5">1.2.5 ()method</a></li>
<li><a href="scala.html#sec-1-2-6">1.2.6 类型继承</a></li>
<li><a href="scala.html#sec-1-2-7">1.2.7 类型层次</a></li>
<li><a href="scala.html#sec-1-2-8">1.2.8 Traits</a></li>
</ul>
</li>
<li><a href="scala.html#sec-1-3">1.3 面向函数</a>
<ul>
<li><a href="scala.html#sec-1-3-1">1.3.1 匿名函数</a></li>
<li><a href="scala.html#sec-1-3-2">1.3.2 偏应用函数</a></li>
<li><a href="scala.html#sec-1-3-3">1.3.3 closure</a></li>
</ul>
</li>
<li><a href="scala.html#sec-1-4">1.4 面向泛型</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> scala</h2>
<div class="outline-text-2" id="text-1">

<ul>
<li><a href="http://www.cs.ucsb.edu/~benh/260/Programming-in-Scala.pdf">Programming in Scala</a> 
</li>
<li>The Scala Programming Language : <a href="http://www.scala-lang.org/">http://www.scala-lang.org/</a>
</li>
</ul>



</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> 基础知识</h3>
<div class="outline-text-3" id="text-1-1">


</div>

<div id="outline-container-1-1-1" class="outline-4">
<h4 id="sec-1-1-1"><span class="section-number-4">1.1.1</span> 标识符</h4>
<div class="outline-text-4" id="text-1-1-1">

<p>scala标识符分为3类：
</p><ul>
<li>An <b>alphanumeric identifier</b> starts with a letter or underscore, which can be followed by further letters, digits, or underscores.
<ul>
<li>Identifiers in user programs should not contain ‘$’ characters, even though it will compile; if they do this might lead to name clashes with iden- tifiers generated by the Scala compiler. （尽可能避免$） 
</li>
<li>Although underscores are legal in identifiers, they are not used that often in Scala programs, in part to be consistent with Java, but also because underscores have many other non-identifier uses in Scala code. As a result, it is best to avoid identifiers like <b>to_string, __init__, or name_</b> . （尽可能避免_) 
</li>
<li>"val name_:Int = 1" 会被认为是定义"name_:"，所以必须在:之前添加空格 <b>NOTE（dirlt）：词法解析足够奇葩</b> 
</li>
</ul>

</li>
<li>An <b>operator identifier</b> consists of one or more operator characters. Oper- ator characters are printable ASCII characters such as +, :, ?, ~ or #.
<ul>
<li>The Scala compiler will internally “mangle” operator identifiers to turn them into legal Java identifiers with embedded $ characters. For instance, the identifier :-&gt; would be represented internally as $colon$minus$greater. If you ever wanted to access this identifier from Java code, you’d need to use this internal representation. 
</li>
</ul>

</li>
<li>A <b>mixed identifier</b> consists of an alphanumeric identifier, which is fol- lowed by an underscore and an operator identifier.
<ul>
<li>unary_+ used as a method name defines a unary + operator.
</li>
<li>myvar_= used as method name defines an assignment operator.
</li>
</ul>

</li>
<li>A <b>literal identifier</b> is an arbitrary string enclosed in back ticks (` . . . `). <b>NOTE（dirlt）：解决关键字问题</b>
<ul>
<li>You cannot write Thread.yield() because yield is a reserved word in Scala. However, you can still name the method in back ticks, e.g., Thread.`yield`().
</li>
</ul>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-1-2" class="outline-4">
<h4 id="sec-1-1-2"><span class="section-number-4">1.1.2</span> 原始类型</h4>
<div class="outline-text-4" id="text-1-1-2">

<p>More generally, all of Java’s primitive types have corresponding classes in the scala package. And when you compile your Scala code to Java bytecodes, the Scala com- piler will use Java’s primitive types where possible to give you the perfor- mance benefits of the primitive types.
</p>
<p>
java原始类型已经全部导入了scala这个包里面，并且这个包是自动引入的。然后所有的原始类型全部变为大写字母开头比如Int,Float,Long等。这样存在一个好处就是从语法上完全统一了扩展类型和原始类型，并且对于这些原始类型scala在上面也做了一些扩展提供了方法，这样使得就更加模糊了扩展类型和原始类型之间的区别。但是scala在底层会尽可能地使用原始类型操作，在性能上不会存在损失。
</p>



<pre class="example">scala&gt; val a:Int=2
a: Int = 2

scala&gt; a.toString()
res0: String = 2

scala&gt; a.to(4)
res1: scala.collection.immutable.Range.Inclusive = Range(2, 3, 4)
</pre>


<p>
<b>TODO(dirlt):可以学习一下这些原始类型提供的方法</b> 
</p>

<hr/>
<p>
数组类型则是 Array[&lt;type&gt;] 比如
</p><ul>
<li>Array[String]
</li>
<li>Array[Array[String]]
</li>
</ul>




<pre class="example">scala&gt; val a = new Array[Array[String]](10)
a: Array[Array[String]] = Array(null, null, null, null, null, null, null, null, null, null)

scala&gt; a[0]
&lt;console&gt;:1: error: identifier expected but integer literal found.
       a[0]

scala&gt; a(0)
res1: Array[String] = null

scala&gt; a.apply(0)
res2: Array[String] = null
</pre>

<p>
注意这里不能够在用[]这种方式来访问数组，而必须使用()的方式来访问。实际上scala将()调用方法定向到了apply这个函数，可以认为是操作符重载。 
</p>
</div>

</div>

<div id="outline-container-1-1-3" class="outline-4">
<h4 id="sec-1-1-3"><span class="section-number-4">1.1.3</span> 变量定义</h4>
<div class="outline-text-4" id="text-1-1-3">

<p>Scala has two kinds of variables, vals and vars. A val is similar to a final variable in Java. Once initialized, a val can never be reassigned. A var, by contrast, is similar to a non-final variable in Java. A var can be reassigned throughout its lifetime. 
</p>
<p>
scala提供了两种变量定义的方式，分别是val和var. 对于val来说一旦赋值便不能够更改，有点类似C++的引用或者是用const/final字段做修饰。而var则是类似普通变量赋值之后依然可以更改。定义变量形式如下
</p>


<pre class="example">[val|var] &lt;name&gt; : &lt;type&gt; = &lt;initializor&gt;
</pre>

<p>
因为scala有type inference功能，所以实际上&lt;type&gt;这个字段可以省略，直接通过&lt;initializor&gt;这个字段来推测类型。
</p>



<pre class="example">scala&gt; val a = 1
a: Int = 1

scala&gt; val a = 1L
a: Long = 1

scala&gt; val a = 1.0
a: Double = 1.0

scala&gt; val a = "Hello"
a: String = Hello
</pre>


</div>

</div>

<div id="outline-container-1-1-4" class="outline-4">
<h4 id="sec-1-1-4"><span class="section-number-4">1.1.4</span> 函数定义</h4>
<div class="outline-text-4" id="text-1-1-4">

<p>a function defines an expression that results in a value.
</p>
<p>
大致形式如下
</p>


<pre class="example">def &lt;func&gt;(&lt;param1&gt;:&lt;type1&gt;, &lt;param2&gt;:&lt;type2&gt;,..):&lt;return-type&gt; = {
  // function body.
}
</pre>


<p>
函数本质上就是求得一个表达式，所以在&lt;function-body&gt;部分最后一个表达式就function返回结果，不需要使用return来显示说明。同样这里也可以使用type inference, 所以如果scala可以从function-body推断的话，那么&lt;return-type&gt;这个部分也可以不用写。但是scala type inference依然比较简单，如果有显示return语句的话(有时候我们确实需要），那么依然需要指定返回类型。
</p>


<pre class="example">scala&gt; def foo(a:Int,b:Int):Int = {
     | a+b
     | }
foo: (a: Int, b: Int)Int

scala&gt; def foo(a:Int,b:Int)  = {
     | a+b
     | }
foo: (a: Int, b: Int)Int

scala&gt; def foo(a:Int,b:Int)  = {
     | return a+b
     | }
&lt;console&gt;:9: error: method foo has return statement; needs result type
       return a+b
       ^
</pre>


<p>
但是scala也允许定义没有任何返回值的函数.对于这类函数&lt;return-type&gt;=Unit, 类似java里面的void. 但是从概念上来说因为不返回值，所以没有必要加上=这个标签，这样看上去更像是一个过程
</p>


<pre class="src src-Scala">def printLine(a:String) {
  println(a)
}
</pre>


<p>
<b>NOTE（dirlt)：需要注意的是传入的param实际上都是以val来定义的，所以在funciton-body里面不允许做修改</b>
</p>

<hr/>
<p>
java里面使用&hellip;来表示参数列表比如
</p>


<pre class="src src-Java">public static void main(String... args) {
  System.out.println(args[0]);
}
</pre>

<p>
而外部可以将类型为String[]的参数直接传入使用。 
</p>
<p>
scala里面对应的表示如下,类型为String*
</p>


<pre class="src src-Scala">def foo(args:String*) {
  for(arg &lt;- args) {
    println(arg);
  }
}
</pre>


<p>
但是和java不同的是没有办法直接传入数组，而必须使用:_*操作符展开。
</p>


<pre class="src src-Scala">val x = Array(<span style="color: #ffff00;">"Hello"</span>,<span style="color: #ffff00;">"World"</span>);
foo(x:_*)
</pre>


</div>

</div>

<div id="outline-container-1-1-5" class="outline-4">
<h4 id="sec-1-1-5"><span class="section-number-4">1.1.5</span> 控制结构</h4>
<div class="outline-text-4" id="text-1-1-5">

<p>One thing you will notice is that almost all of Scala’s control structures result in some value. This is the approach taken by functional languages, in which programs are viewed as computing a value, thus the components of a program should also compute values. 
</p>
<p>
从函数式编程角度出发，所有的控制结构都应该是能够产生值的。对于scala来说也是，基本上所有的控制结构都能够产生值。
</p><ul>
<li>while # 不产生值
</li>
<li>foreach # args.foreach(&lt;function&gt;).
</li>
<li>for # for(arg &lt;- args). 注意这里的arg以val定义所以不能够修改
</li>
<li>if/else # val x = if (&lt;pred&gt;) &lt;value1&gt; else &lt;value2&gt;
</li>
<li>match/case # pattern matching.
</li>
<li>try/catch/finally # exception handling.
</li>
<li><b>NOTE(dirlt):没有break/continue语句</b>
</li>
</ul>



<hr/>
<p>
对于for来说分为两个部分，一个是循环部分，一个是执行部分。
</p>
<p>
循环部分的大致语法就是arg &lt;- args. 但是允许在后面接上过滤条件，然后允许多重嵌套用;分开。比如下面一段代码
</p>


<pre class="src src-Scala">for(i &lt;- 0 to 4
    if i%2 == 0
    if i%4 == 0;
    j &lt;- 0 to 5
    if j%2 == 1) {
  println(<span style="color: #ffff00;">"i="</span> + i + <span style="color: #ffff00;">",j="</span> + j);
}
</pre>


<p>
但是这样的方式是不产生值的，即使执行部分最后返回值，所以结果为()，如果需要产生值的话那么必须使用yield关键字。yield生成的效果非常类似list comprehension, 将执行部分返回值组成一个collection. 比如下面一段代码
</p>


<pre class="src src-Scala">val x = 
  for(i &lt;- 0 to 4) yield {
    i
  }
println(x) // Vector(0, 1, 2, 3, 4)
</pre>


<p>
上面这段代码效果和python list comprehension非常类似
</p>


<pre class="src src-Python">a = [x+2 for x in range(0,4) if x %2 == 0]
</pre>



<hr/>
<p>
异常的触发和java类似都是throw new Exception(). catch部分可以通过模式匹配来完成。finally则主要用于处理清理资源释放等问题。
</p>


<pre class="src src-Scala">def f() {
  throw new Exception(<span style="color: #ffff00;">"hello"</span>);
}

def g():Int = {
  try {
    f()
    2
  } catch {
    case e:Exception =&gt; 3
    case _:Throwable =&gt; 4
  } finally {
  }
}
</pre>

<p>
finally里面的返回值会被忽略，除非使用return来强制返回。但是建议不要这么做，finally所存在的主要理由应该是用来做cleanup的工作而不是参与计算（The best way to think of finally clauses is as a way to ensure some side effect happens, such as closing an open file.）
</p>
<p>
One difference from Java that you’ll quickly notice in Scala is that unlike Java, Scala does not require you to catch checked exceptions.（不强制捕获检查异常）
</p>

<hr/>
<p>
match和switch非常类似，但是有下面两个比较重要的差别：
</p><ul>
<li>One is that any kind of constant, as well as other things, can be used in cases in Scala, not just the integer-type and enum constants of Java’s case statements.
</li>
<li>Another difference is that there are no breaks at the end of each alternative. Instead the break is implicit, and there is no fall through from one alternative to the next.
</li>
</ul>


<p>
下面是一段示例代码
</p>


<pre class="src src-Scala">val x = <span style="color: #ffff00;">"hello"</span>;
val y = 
  x match {
    case <span style="color: #ffff00;">"world"</span> =&gt; 2;
    case <span style="color: #ffff00;">"hello"</span> =&gt; 3;
    case _ =&gt; 4;
  }
</pre>


<p>
<b>NOTE（dirlt）：限制以及内部实现</b>
</p>
</div>

</div>

<div id="outline-container-1-1-6" class="outline-4">
<h4 id="sec-1-1-6"><span class="section-number-4">1.1.6</span> 等值比较</h4>
<div class="outline-text-4" id="text-1-1-6">

<p>scala下==的和java是不同的。 <b>在java下==是比较引用相等性，而scala下==则是比较值相等性，也就是说会调用equal来做比较</b> 
</p>
<p>
使用eq,ne来判断引用相当，但是判断引用相等仅限于引用类型
</p>


<pre class="src src-Scala">val a = Array(<span style="color: #ffff00;">"1"</span>);
val b = Array(<span style="color: #ffff00;">"2"</span>);
println(a eq b)
val c = b
println(c eq b)
</pre>


</div>

</div>

<div id="outline-container-1-1-7" class="outline-4">
<h4 id="sec-1-1-7"><span class="section-number-4">1.1.7</span> operator</h4>
<div class="outline-text-4" id="text-1-1-7">

<ul>
<li>a op b -&gt; a.op(b)
</li>
<li>a(b) -&gt; a.apply(b)
</li>
<li>a(b)=c -&gt; a.update(b,c)
</li>
<li>a op: b -&gt; b.op(a) # If the method name ends in a colon, the method is invoked on the right operand. 
<ul>
<li><b>NOTE(dirlt):但是evaluation的顺序依然先是a，然后是b</b>
</li>
</ul>

</li>
</ul>





<pre class="src src-Scala">var Id = 0 // for identification.
class Op() {
  val id = Id;
  Id += 1;
  def + (x: Op) {
    println(<span style="color: #ffff00;">"operation by Op#"</span> + id);
  }
  def +: (x: Op) {
    println(<span style="color: #ffff00;">"operation by Op#"</span> + id);
  }
  def apply(p: Int) {
    println(<span style="color: #ffff00;">"apply with "</span> + p)
  }
  def update(p: Int, c:Int) {
    println(<span style="color: #ffff00;">"update with "</span> + p + <span style="color: #ffff00;">", "</span> + c);
  }
}
val a = new Op(); // Op#0
val b = new Op(); // Op#1
a + b;
a +: b;
a(0);
a(0)=1;
</pre>


</div>

</div>

<div id="outline-container-1-1-8" class="outline-4">
<h4 id="sec-1-1-8"><span class="section-number-4">1.1.8</span> 前提断言</h4>
<div class="outline-text-4" id="text-1-1-8">

<ul>
<li>require(expression)
</li>
<li>assert(expression)
</li>
<li>assert(experession,explaination)
</li>
</ul>


</div>

</div>

<div id="outline-container-1-1-9" class="outline-4">
<h4 id="sec-1-1-9"><span class="section-number-4">1.1.9</span> package</h4>
<div class="outline-text-4" id="text-1-1-9">

<p>scala提供了两种定义package的方式，一种是java的，一种是类似C++ namespace的，关键字_root_来引用到最外层package
</p>


<pre class="src src-Scala">package A {  
  class X {
  }
  package B {
    class X {
    }
  }
  package C {
    object Hello extends App {
      val x = new A.X() // new _root_.A.X()
      val x2 = new B.X()
    }
  }
}
</pre>


<p>
import有下面几种常用方法 <a href="http://www.scala-lang.org/old/node/119.html">http://www.scala-lang.org/old/node/119.html</a>
</p><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col class="left" /><col class="left" />
</colgroup>
<thead>
<tr><th scope="col" class="left">The clause</th><th scope="col" class="left">makes available without qualification..</th></tr>
</thead>
<tbody>
<tr><td class="left">import p._</td><td class="left">all members of p (this is analogous to import p.* in Java).</td></tr>
<tr><td class="left">import p.x</td><td class="left">the member x of p.</td></tr>
<tr><td class="left">import p.{x =&gt; a}</td><td class="left">the member x of p renamed as a.</td></tr>
<tr><td class="left">import p.{x =&gt; _}</td><td class="left">the member x of p removed.</td></tr>
<tr><td class="left">import p.{x, y}</td><td class="left">the members x and y of p.</td></tr>
<tr><td class="left">import p1.p2.z</td><td class="left">the member z of p2, itself member of p1.</td></tr>
</tbody>
</table>

Futhermore the clause import p1._, p2._ is a shorthand for import p1._; import p2._. A catch-all ‘_’. This imports all members except those members men-tioned in a preceding clause. If a catch-all is given, it must come last in the list of import selectors.

<p>
cacth-all只能够用在最后一个selector上面，过滤之前所有的条件之后的部分，也就是说import p.{x=&gt;_,_}导入p的除x之外的所有members, import p.{x=&gt;a,_}则是导入p所有的members但是将x重命名为a.
</p>
<p>
scala import相比java import更加灵活
</p><ul>
<li>may appear anywhere // 类似Python的import.
</li>
<li>may refer to objects (singleton or regular) in addition to packages
</li>
<li>let you rename and hide some of the imported members
</li>
</ul>




<pre class="src src-Scala">def showFruit(fruit: Fruit) {
  import fruit._
  println(name +<span style="color: #ffff00;">"s are "</span>+ color)
}
</pre>


<p>
Implicitly imported into every compilation unit are, in that order:
</p><ul>
<li>the package java.lang,
</li>
<li>the package scala,
</li>
<li>and the object scala.Predef.
</li>
</ul>


</div>
</div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> 面向对象</h3>
<div class="outline-text-3" id="text-1-2">


</div>

<div id="outline-container-1-2-1" class="outline-4">
<h4 id="sec-1-2-1"><span class="section-number-4">1.2.1</span> 单例对象</h4>
<div class="outline-text-4" id="text-1-2-1">

<p>单例对象很好地解决了Java的两个问题，一个是是单例模式没有集成到语言当中去导致代码编写冗余，一个是静态字段和静态方法嵌入在类定义中导致代码结构不清晰。下面是一段Java代码
</p>


<pre class="src src-Java">/* coding:utf-8
 * Copyright (C) dirlt
 */

public class Hello {
  public static final kConstant = 10;
  private static instance;
  public static void init() {
    instance = new Hello();
  }
  public static Hello getInstance() {
    return instance;
  }
  public void method() {
  }
}
</pre>


<p>
而scala引入单例对象方式解决这个问题。单例对象使用object来定义，使用时候直接拿名称引用即可。
</p>


<pre class="src src-Scala">object Hello {
  val kConstant = 10;
  def method() {
  }
}
Hello.method();
println(Hello.kConstant);
</pre>


<p>
When a singleton object shares the same name with a class, it is called that class’s companion object. You must define both the class and its companion object in the same source file. The class is called the companion class of the singleton object. A class and its companion object can access each other’s private members. A singleton object that does not share the same name with a companion class is called a standalone object. You can use standalone objects for many purposes, including collecting related utility methods together, or defining an entry point to a Scala application. 
</p>
<p>
如果定义了和这个单例对象名称相同的类的话，那么
</p><ul>
<li><b>这两个定义必须放在同一份文件</b>
</li>
<li>这个类称为这个单例对象的 <b>共生类</b>
</li>
<li>这个单例对象称为这个类的 <b>共生对象</b> 
</li>
</ul>

<p>共生对象和共生类可以相互访问private members
</p>
</div>

</div>

<div id="outline-container-1-2-2" class="outline-4">
<h4 id="sec-1-2-2"><span class="section-number-4">1.2.2</span> 构造函数</h4>
<div class="outline-text-4" id="text-1-2-2">

<p>scala将构造函数和类定义合并，相比java方式更加简洁。下面是一段Java代码
</p>


<pre class="src src-Java">/* coding:utf-8
 * Copyright (C) dirlt
 */

public class Hello {
  private int n;
  private int d;
  public Hello(int n,int d) {
    this.n = n;
    this.d = d;
  }
  public Hello(int n) {
    this(n,0);
  }
  {
    System.out.println(<span style="color: #ffff00;">"initializing...("</span> + n + <span style="color: #ffff00;">","</span> + d + <span style="color: #ffff00;">")"</span>);
  }
}
</pre>

<p>
可以看到，实际上整个类的初始化是由两个部分来完成的，一个部分是构造函数部分，一个是类初始化执行代码。但是本质上它们都是为初始化类来服务的，或许我们就不应该将它们分开。此外构造函数重新赋值部分显得有点蹩脚，将传入的参数重新赋值到类内部字段上，略显得有点多余。
</p>
<p>
而下面是则是scala对应的代码
</p>


<pre class="src src-Scala">class Hello(pn: Int, pd: Int) {
  private val n = pn;
  private val d = pd;
  println(<span style="color: #ffff00;">"initializing...("</span> + n + <span style="color: #ffff00;">","</span> + d + <span style="color: #ffff00;">")"</span>);
  def this(pn:Int) = this(pn,0);
}
</pre>

<p>
scala将构造函数和初始化代码融合，只是使用初始化代码来作为构造函数，这样我们也不用在纠结到底是构造函数先执行还是初始化代码先执行。这个构造函数成为 <b>primary constructor</b> , 传入的参数称为 <b>class parameters</b> 注意这里parameters可以看做也是以val来定义的. 构造函数this(pn:Int)称为 <b>auxiliary constructor</b> . 
</p>
<p>
对于大部分构造函数来说传入的参数都想留存一份下来。为此scala引入了 <b>parametric fields</b> 这个概念。只需要在class parameters上面稍作扩展即可
</p>


<pre class="src src-Scala">class Hello(private val pn: Int, private val pd: Int) {
  println(<span style="color: #ffff00;">"initializing...("</span> + pn + <span style="color: #ffff00;">","</span> + pd + <span style="color: #ffff00;">")"</span>);
  def this(pn:Int) = this(pn,0);
}
</pre>

<p>
在class parameter之前添加[private|protected|override] [val|var]即可，这样既定义了类构造函数参数也定义了对应的字段。scala访问修饰符只有private/protected,默认是public. The way you make members public in Scala is by not explicitly specifying any access modifier. Put another way, where you’d say “public” in Java, you simply say nothing in Scala. Public is Scala’s default access level. 
</p>
<p>
如果面向对象角度相比于java，上面这种方式确实简化不少。而scala本意应该是更想到达函数式类构造效果，构造生成对象称为 <b>functional object</b> . 我们之所以想保存这些参数是因为在编写java时候这些参数只能够在构造函数中获得，而在scala里面实际上在整个类里面都是可以获得的，因此对于上面情况来说我们根本没有必要保存这些类参数。在下面closure代码里面我们实际上可以直接引用pn,pd来参与计算。
</p>


<pre class="src src-Scala">class Hello(pn: Int, pd: Int) {
  def n = pn
  def d = pd
  def closure(ratio:Float) = {
    ratio * pn + pd;
  }
}

val h = new Hello(2,1);
println(h.closure(2.0f));
</pre>


</div>

</div>

<div id="outline-container-1-2-3" class="outline-4">
<h4 id="sec-1-2-3"><span class="section-number-4">1.2.3</span> override</h4>
<div class="outline-text-4" id="text-1-2-3">

<p>scala提供了override这个关键字可以确保复写错误几率降低。对于java来说@Override这个注解是可选的，但是对于scala来说override关键字是必须的。如果B继承A复写其方法但是没有提供override关键字的话，就会出现编译错误，这样就强制要求在复写方法的时候提供override。一旦强制写override的话我们就能够发现一些我们原本希望复写某方法但是却没有复写的情况。
</p>



<pre class="src src-Scala">class Hello(pn: Int, pd: Int) {
  def toString() = <span style="color: #ffff00;">"n = "</span> + pn + <span style="color: #ffff00;">", d = "</span> + pd;
}
</pre>


<p>
编译出现错误
</p>


<pre class="example">/Users/dirlt/scala/Hello.scala:2: error: overriding method toString in class Object of type ()String;
 method toString needs `override' modifier
  def toString() = "n = " + pn + ", d = " + pd;
      ^
one error found
</pre>


<p>
可以复写的不仅有方法也包括字段。字段复写相对来说就比较简单只是覆盖基类字段，但是也可能会影响到函数调用。
</p>


<pre class="src src-Scala">class Hello {
  val x = 0;
  def echoX() {
    println(x);
  }
}

class Hello2 extends Hello {
  override val x = 1;
}

val x:Hello = new Hello2();
x.echoX(); // 1
</pre>


</div>

</div>

<div id="outline-container-1-2-4" class="outline-4">
<h4 id="sec-1-2-4"><span class="section-number-4">1.2.4</span> 隐式转换</h4>
<div class="outline-text-4" id="text-1-2-4">

<p>scala可以通过提供隐式转换函数来完成，函数需要添加关键字implicit作为前缀. 注意这个隐式转换函数必须放在类外部来定义。 
</p>


<pre class="src src-Scala">class Hello(p:Int) {
  private val x = p;
  def op(h:Hello) {
    println(<span style="color: #ffff00;">"op("</span> + x + <span style="color: #ffff00;">","</span> + h.x + <span style="color: #ffff00;">")"</span>);
  }
}

implicit def intToHello(x:Int) = {
  println(<span style="color: #ffff00;">"do implicit conversion"</span>);
  new Hello(x);
}

val h = new Hello(1);
h op 2;
</pre>


<p>
但是从一个类型向另外一个类型做隐式转换只能够提供一个函数，不然就会出现歧义. 这里我提供了两个隐式转换函数结果编译出错。 
</p>


<pre class="example">Note that implicit conversions are not applicable because they are ambiguous:
 both method intToHello of type (x: Int)this.Hello
 and method intToHello2 of type (x: Int)this.Hello
 are possible conversion functions from Int(2) to this.Hello
</pre>


<p>
Because im- plicit conversions are applied implicitly by the compiler, not explicitly writ- ten down in the source code, it can be non-obvious to client programmers what implicit conversions are being applied. 
</p>
<p>
所以隐式转换这个东西还是尽量少用比较好。
</p>
</div>

</div>

<div id="outline-container-1-2-5" class="outline-4">
<h4 id="sec-1-2-5"><span class="section-number-4">1.2.5</span> ()method</h4>
<div class="outline-text-4" id="text-1-2-5">

<p>parameterless vs. empty-paren method. 对于函数来说如果没有任何参数的话，那么可以将()取消:
</p><ul>
<li>def foo() = 1 // empty-paren
</li>
<li>def foo = 1 // parameterless
</li>
</ul>

<p>本质上这两者没有任何差别，但是在习惯上我们通常做出如下选择： <b>如果这个方法存在side-effect的话，那么选用foo()这种方式，否则选用foo方式</b>
</p>
<p>
这样的选择有个好处就是可以统一method和field访问，使得代码更加简洁。考虑在Java经常需要编写getter方法导致冗长的代码
</p>


<pre class="src src-Java">public class Hello {
  private int n;
  private int d;
  public Hello(int n,int d) {
    this.n = n;
    this.d = d;
  }
  public int squareN() {
    return n*n;
  }
  public int doubleD() {
    return 2*d;
  }
  public static void usage() {
    Hello h = new Hello(1,2);
    h.squareN();
    h.doubleD();
  }
}
</pre>


<p>
而scala代码相对简洁，并且访问squareN和doubleD更像是访问字段而不是在调用方法。 <b>NOTE(dirlt):不过从个人感觉上看，如果计算代价比较大的话，还是使用empty-paren比较好</b>
</p>


<pre class="src src-Scala">class Hello(private val n:Int,
            private val d:Int) {
  def squareN = n * n;
  def doubleD = d * d;
}

val h = new Hello(1,2);
println(h.squareN)
println(h.doubleD)
</pre>


</div>

</div>

<div id="outline-container-1-2-6" class="outline-4">
<h4 id="sec-1-2-6"><span class="section-number-4">1.2.6</span> 类型继承</h4>
<div class="outline-text-4" id="text-1-2-6">

<p>使用extends关键字来继承，然后在继承的声明里面可以对父类做初始化。父类实例使用super来引用。
</p>


<pre class="src src-Scala">class A(n:Int) {
  println(<span style="color: #ffff00;">"init A with n = "</span> + n);
}

class B(n:Int) extends A(n) {
  println(<span style="color: #ffff00;">"init B with n = "</span> + n);
}

val b = new B(10);
</pre>


<p> 
抽象类中存在没有实现的方法(只给出声明)，在class之前使用abstract关键字指示
</p>


<pre class="src src-Scala">abstract class Hello {
  def echo()
}
</pre>

<p>
抽象类不能够用来创建实例，类必须继承实现方法才能够创建实例。
</p>
<p>
与抽象类相对应的是final类，这个类不能够再被继承。同时final字段还能够用在方法和字段上面这样可以不被override.
</p>
</div>

</div>

<div id="outline-container-1-2-7" class="outline-4">
<h4 id="sec-1-2-7"><span class="section-number-4">1.2.7</span> 类型层次</h4>
<div class="outline-text-4" id="text-1-2-7">

<p><img src="images/scala-class-hierarchy.png"  alt="./images/scala-class-hierarchy.png" />
</p>
<p>
所有的基类是Any，定义了下面这些方法
</p>


<pre class="src src-Scala">final def ==(that: Any): Boolean
final def !=(that: Any): Boolean
def equals(that: Any): Boolean
def hashCode: Int
def toString: String
</pre>

<p>
注意这里我们不需要实现==,!=，它们会调用equals这个方法，这个才是我们需要复写的。
</p>
<p>
The root class Any has two subclasses: AnyVal and AnyRef. AnyVal is the parent class of every built-in value class in Scala. There are nine such value classes: Byte, Short, Char, Int, Long, Float, Double, Boolean, and Unit. The first eight of these correspond to Java’s primitive types, and their values are represented at run time as Java’s primitive values. The instances of these classes are all written as literals in Scala. As mentioned previously, on the Java platform AnyRef is in fact just an alias for class java.lang.Object. So classes written in Java as well as classes written in Scala all inherit from AnyRef.
</p>
<p>
AnyVal是所有的内置类型基类，包括8种对应的java基本类型以及Unit（对应void类型），AnyRef是所有引用类型的基类。对于scala内置类型而言，值是通过字面量来创建的，也就是说不能够通过比如new Int这样的方法来创建，而Unit对应的value为(). 在JVM平台上面，AnyRef是Object的alias,但是如果可以的话尽可能地使用AnyRef而不要使用Object. <b>因为AnyRef上定义了eq和ne两个方法，所以只有引用类型才能够调用</b>
</p>
<p>
Scala classes are different from Java classes in that they also inherit from a special marker trait called ScalaObject. The idea is that the ScalaObject contains methods that the Scala compiler defines and implements in order to make execution of Scala programs more efficient. Right now, Scala object contains a single method, named $tag, which is used internally to speed up pattern matching.
</p>
<p>
继承ScalaObject主要是用来加速pattern matching.
</p>
<p>
Class Null is the type of the null reference; it is a subclass of every reference class (i.e., every class that itself inherits from AnyRef). Type Nothing is at the very bottom of Scala’s class hierarchy; it is a sub- type of every other type. However, there exist no values of this type whatso-ever.
</p>
<p>
Null是所有引用类型的子类，其实例对象是null. 而Nothing是所有类型的子类，但是没有实例对象。对于Nothing没有实例对象需要了解Nothing的引入。Nothing引入是为了将异常融入类型系统的，比如下面scala代码
</p>


<pre class="src src-Scala">def error(message: String): Nothing =
  throw new RuntimeException(message)
</pre>

<p>
定义了error这个函数来报告错误，然后我们在使用的时候
</p>


<pre class="src src-Scala">def divide(x: Int, y: Int): Int =
  if (y != 0) x / y
  else error(<span style="color: #ffff00;">"can't divide by zero"</span>)
</pre>

<p>
我们必须确保类型能够统一，所以error类型必须和Int兼容，因此Nothing在设计上必须是所有类型的子类。
</p>
</div>

</div>

<div id="outline-container-1-2-8" class="outline-4">
<h4 id="sec-1-2-8"><span class="section-number-4">1.2.8</span> Traits</h4>
<div class="outline-text-4" id="text-1-2-8">

<p>所谓的traits就是特征，在面向对象里面就是指代这个类或者是这个对象的特征。scala trait和java interface非常相似，其引入都是为了解决多重继承的问题。 <b>trait包含方法和字段，但是没有类参数（class parameter）和构造函数。</b>  <b>NOTE（dirlt）：我觉得这点设计让trait回归到了本意，同时简化了设计和使用</b>
trait的定义和class类似，mixin trait上也是通过关键字extends来完成的，如果需要mixin多个trait的话用with关键字
</p>


<pre class="src src-Scala">trait A {
  def foo();
}

trait B {
  def bar();
}

class C extends A with B {
  def foo() {
    println(<span style="color: #ffff00;">"foo"</span>);
  }
  def bar() {
    println(<span style="color: #ffff00;">"bar"</span>);
  }
}
</pre>


<p>
trait的引入解决了一些多重继承的问题，最重要的问题就是如何解释super. 多重继承里面最麻烦的就是菱形继承问题A-&gt;B,A-&gt;C,B-&gt;D,C-&gt;D. 下面是一段C++代码
</p>


<pre class="src src-C++">/* coding:utf-8
 * Copyright (C) dirlt
 */

#include &lt;cstdio&gt;

class A {
 public:
  void foo() {
    printf(<span style="color: #ffff00;">"A\n"</span>);
  }
};

class B:public A {
 public:
  void foo() {
    A::foo();
    printf(<span style="color: #ffff00;">"B\n"</span>);
  }
};

class C:public A {
 public:
  void foo() {
    A::foo();
    printf(<span style="color: #ffff00;">"C\n"</span>);
  }
};

class D:public B,
        public C {
 public:
  void foo() {
    B::foo();
    C::foo();        
    printf(<span style="color: #ffff00;">"D\n"</span>);
  }
};

int main() {
  D d;
  d.foo();
  return 0;
}
</pre>

<p>
这里D想调用A,B,C的foo各一次，但是最终调用了A两次。因为在C++里面允许多重继承没有super这个概念，所以只指定哪些父类，但是即使存在super这个概念也比较难以解决这个问题。比较难以解决这个问题的根本是，super这个parent-child关系是静态确定的，也就是说一旦出现菱形继承这样的情况，能够选择其中一条parent-child链执行。而如果语言能够在语言级别的层面上，根据当前继承关系动态地给出一个包含所有节点parent-child链的话，就可以解决这个问题。scala就是这个做法。
</p>
<p>
scala这种动态确定关系链的技术叫做linearization, 也就是将继承关系线性化得到一个linear order。以下面这个继承关系为例
</p>


<pre class="example">class Animal
trait Furry extends Animal
trait HasLegs extends Animal
trait FourLegged extends HasLegs
class Cat extends Animal with Furry with FourLegged
</pre>


<p>
<img src="images/scala-linearization.png"  alt="./images/scala-linearization.png" />
</p>
<p>
以Cat直接继承和混入类型， <b>从左向右分析</b>
</p><ol>
<li>Animal linear order = Animal -&gt; AnyRef -&gt; Any
</li>
<li>Flurry linear order = Furry -&gt; Animal -&gt; AnyRef -&gt; Any
</li>
<li>FourLegged linear order = HasLegs -&gt; Animal -&gt; AnyRef -&gt; Any
</li>
</ol>

<p>优先级别上1&gt;2&gt;3. 1和2结合结果为
</p><ul>
<li>Furry -&gt; Animal -&gt; AnyRef -&gt; Any
</li>
</ul>

<p>然后和3结合结果为
</p><ul>
<li>FourLegged -&gt; HasLegs -&gt; Furry -&gt; Animal -&gt; AnyRef -&gt; Any
</li>
</ul>

<p>所以最后的linear order为此，以此顺序调用super.
</p>
<p>
<b>NOTE（dirlt）：这种动态执行的效果就是，你不能够确定super到底是哪个，取决于context.</b>
</p>
</div>
</div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> 面向函数</h3>
<div class="outline-text-3" id="text-1-3">


</div>

<div id="outline-container-1-3-1" class="outline-4">
<h4 id="sec-1-3-1"><span class="section-number-4">1.3.1</span> 匿名函数</h4>
<div class="outline-text-4" id="text-1-3-1">

<p><b>NOTE（dirlt）：aka. function literal</b> 
</p>



<pre class="example">(&lt;param1&gt;:&lt;type1&gt;,&lt;param2&gt;:&lt;type2&gt;,...) =&gt; { &lt;funciton-body&gt; }
</pre>

<p>
匿名函数不允许指定return-type，也就是说匿名函数必须通过type inference确定返回类型。
</p>
<p>
但是在某些特殊情况则不需要指定parameter-type, 因为parameter-type可以通过上下文推导出来。 
</p>


<pre class="src src-Scala">val x = (0 to 4).filter((x:Int) =&gt; x &gt; 2)
val y = (0 to 4).filter(x =&gt; x &gt; 2)
</pre>

<p>
This is called <b>target typing</b> , because the targeted usage of an expression is allowed to influence the typing of that expression
</p>
<p>
使用placeholder syntax也可以构造一些简单的函数，_相当于一个函数参数占位符。但是因为_之间没有办法做区分，所以就函数功能来说非常有限。
</p>


<pre class="src src-Scala">val y = (0 to 4).filter(_ &gt; 2)
val f = (_:Int) + (_:Int) // (x:Int,y:Int) =&gt; x + y
</pre>


</div>

</div>

<div id="outline-container-1-3-2" class="outline-4">
<h4 id="sec-1-3-2"><span class="section-number-4">1.3.2</span> 偏应用函数</h4>
<div class="outline-text-4" id="text-1-3-2">

<p>偏应用函数(partially applied function)允许我们将部分参数作用在函数上形成特化函数。
</p>


<pre class="src src-Scala">def foo1(x:Int)(y:Int) = x + y
def foo2(x:Int,y:Int) = x + y
val pFoo1 = (y:Int) =&gt; foo1(1)(y)
val pFoo2 = (y:Int) =&gt; foo2(1,y)
</pre>


<p> 
placeholder syntax提供了更简单的方法，并且_能够作为后续多个参数的占位符。
</p>


<pre class="src src-Scala">def foo1(x:Int)(y:Int) = x + y
def foo2(x:Int,y:Int) = x + y
// val pFoo1 = foo1(_) // also OK.
val pFoo1 = foo1(1)(_)
val pFoo2 = foo2(1,_:Int)
</pre>


</div>

</div>

<div id="outline-container-1-3-3" class="outline-4">
<h4 id="sec-1-3-3"><span class="section-number-4">1.3.3</span> closure</h4>
<div class="outline-text-4" id="text-1-3-3">

<p>function literal内部取值通常有三种：
</p><ul>
<li>constant # 常量
</li>
<li>bound variable # 函数参数
</li>
<li>free variable # 外部变量
</li>
</ul>


<p>
以下面两个function literal为例
</p><ul>
<li>(x:Int) =&gt; x + 1 + y
<ul>
<li>x as bound variable
</li>
<li>1 as constant
</li>
<li>y as free variable
</li>
</ul>

</li>
</ul>

<p>对于一个function literal来说的话，内部没有free variable的话，那么称为closed term. 否则称为open term. 
</p>
<p>
<b>open term因为free variable被captured住之后形成的function value称为closure.</b> The resulting function value, which will contain a reference to the captured more variable, is called a closure, therefore, because the function value is the end product of the act of closing the open term.
</p>
<p>
需要注意的是， <b>closure capture的不是variable的值而是variable本身</b> ，所以如果variable变化的话那么closure本身行为也是会变化的。
</p>


<pre class="src src-Scala">var y = 10
val foo = (x:Int) =&gt; x+y
println(foo(1)) // 11
y = 0
println(foo(1)) // 1
</pre>


</div>
</div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> 面向泛型</h3>
<div class="outline-text-3" id="text-1-4">

</div>
</div>
</div>
</div>

<!-- Baidu Analytics BEGIN --><script type="text/javascript">var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F54a700ad7035f6e485eaf2300641e7e9' type='text/javascript'%3E%3C/script%3E"));</script><!-- Baidu Analytics END --><!-- Google Analytics BEGIN --><script type="text/javascript">  var _gaq = _gaq || [];  _gaq.push(['_setAccount', 'UA-31377772-1']);  _gaq.push(['_trackPageview']);  (function() {    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);  })();</script><!-- Google Analytics END --><!-- Baidu Button BEGIN --><!-- <script type="text/javascript" id="bdshare_js" data="type=tools&amp;uid=6762177" ></script><script type="text/javascript" id="bdshell_js"></script><script type="text/javascript"> document.getElementById("bdshell_js").src = "http://bdimg.share.baidu.com/static/js/shell_v2.js?cdnversion=" + Math.ceil(new Date()/3600000)</script> --><!-- Baidu Button END --><!-- G+ BEGIN --><!-- Place this render call where appropriate --><script type="text/javascript">  (function() {    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;    po.src = 'https://apis.google.com/js/plusone.js';    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);  })();</script><!-- G+ END --><!-- DISQUS BEGIN --><div id="disqus_thread"></div><script type="text/javascript">/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * *//* required: replace example with your forum shortname  */var disqus_shortname = 'dirlt';var disqus_identifier = 'scala.html';var disqus_title = 'scala.html';var disqus_url = 'http://dirlt.com/scala.html';/* * * DON'T EDIT BELOW THIS LINE * * */(function() {var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);})();</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a><!-- DISQUS END --></body>
</html>
