<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head><!-- <meta name="baidu-site-verification" content="707024a76f8f40b549f07f478abab237"/> -->
<title>scala</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="title" content="scala"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2013-09-10 17:12:13 CST"/>
<meta name="author" content="dirtysalt"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  div.inlinetask {
    padding:10px;
    border:2px solid gray;
    margin:10px;
    background: #ffffcc;
  }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style><link rel="stylesheet" type="text/css" href="css/site-plain.css" />
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>

</head>
<body><!-- <div id="bdshare" class="bdshare_t bds_tools_32 get-codes-bdshare"><a class="bds_tsina"></a><span class="bds_more"></span><a class="shareCount"></a></div> --><!-- Place this tag where you want the +1 button to render --><g:plusone annotation="inline"></g:plusone>


<div id="content">
<h1 class="title">scala</h1>


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="scala.html#sec-1">1 scala</a>
<ul>
<li><a href="scala.html#sec-1-1">1.1 基础知识</a>
<ul>
<li><a href="scala.html#sec-1-1-1">1.1.1 标识符</a></li>
<li><a href="scala.html#sec-1-1-2">1.1.2 原始类型</a></li>
<li><a href="scala.html#sec-1-1-3">1.1.3 变量定义</a></li>
<li><a href="scala.html#sec-1-1-4">1.1.4 函数定义</a></li>
<li><a href="scala.html#sec-1-1-5">1.1.5 控制结构</a></li>
<li><a href="scala.html#sec-1-1-6">1.1.6 等值比较</a></li>
<li><a href="scala.html#sec-1-1-7">1.1.7 operator</a></li>
<li><a href="scala.html#sec-1-1-8">1.1.8 前提断言</a></li>
</ul>
</li>
<li><a href="scala.html#sec-1-2">1.2 面向对象</a>
<ul>
<li><a href="scala.html#sec-1-2-1">1.2.1 单例对象</a></li>
<li><a href="scala.html#sec-1-2-2">1.2.2 构造函数</a></li>
<li><a href="scala.html#sec-1-2-3">1.2.3 override</a></li>
<li><a href="scala.html#sec-1-2-4">1.2.4 隐式转换</a></li>
<li><a href="scala.html#sec-1-2-5">1.2.5 类型层次</a></li>
</ul>
</li>
<li><a href="scala.html#sec-1-3">1.3 面向函数</a>
<ul>
<li><a href="scala.html#sec-1-3-1">1.3.1 匿名函数</a></li>
<li><a href="scala.html#sec-1-3-2">1.3.2 偏应用函数</a></li>
<li><a href="scala.html#sec-1-3-3">1.3.3 closure</a></li>
</ul>
</li>
<li><a href="scala.html#sec-1-4">1.4 面向泛型</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> scala</h2>
<div class="outline-text-2" id="text-1">

<ul>
<li><a href="http://www.cs.ucsb.edu/~benh/260/Programming-in-Scala.pdf">Programming in Scala</a> 
</li>
<li>The Scala Programming Language : <a href="http://www.scala-lang.org/">http://www.scala-lang.org/</a>
</li>
</ul>



</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> 基础知识</h3>
<div class="outline-text-3" id="text-1-1">


</div>

<div id="outline-container-1-1-1" class="outline-4">
<h4 id="sec-1-1-1"><span class="section-number-4">1.1.1</span> 标识符</h4>
<div class="outline-text-4" id="text-1-1-1">

<p>scala标识符分为3类：
</p><ul>
<li>An <b>alphanumeric identifier</b> starts with a letter or underscore, which can be followed by further letters, digits, or underscores.
<ul>
<li>Identifiers in user programs should not contain ‘$’ characters, even though it will compile; if they do this might lead to name clashes with iden- tifiers generated by the Scala compiler. （尽可能避免$） 
</li>
<li>Although underscores are legal in identifiers, they are not used that often in Scala programs, in part to be consistent with Java, but also because underscores have many other non-identifier uses in Scala code. As a result, it is best to avoid identifiers like <b>to_string, __init__, or name_</b> . （尽可能避免_) 
</li>
<li>"val name_:Int = 1" 会被认为是定义"name_:"，所以必须在:之前添加空格 <b>NOTE（dirlt）：词法解析足够奇葩</b> 
</li>
</ul>

</li>
<li>An <b>operator identifier</b> consists of one or more operator characters. Oper- ator characters are printable ASCII characters such as +, :, ?, ~ or #.
<ul>
<li>The Scala compiler will internally “mangle” operator identifiers to turn them into legal Java identifiers with embedded $ characters. For instance, the identifier :-&gt; would be represented internally as $colon$minus$greater. If you ever wanted to access this identifier from Java code, you’d need to use this internal representation. 
</li>
</ul>

</li>
<li>A <b>mixed identifier</b> consists of an alphanumeric identifier, which is fol- lowed by an underscore and an operator identifier.
<ul>
<li>unary_+ used as a method name defines a unary + operator.
</li>
<li>myvar_= used as method name defines an assignment operator.
</li>
</ul>

</li>
<li>A <b>literal identifier</b> is an arbitrary string enclosed in back ticks (` . . . `). <b>NOTE（dirlt）：解决关键字问题</b>
<ul>
<li>You cannot write Thread.yield() because yield is a reserved word in Scala. However, you can still name the method in back ticks, e.g., Thread.`yield`().
</li>
</ul>

</li>
</ul>


</div>

</div>

<div id="outline-container-1-1-2" class="outline-4">
<h4 id="sec-1-1-2"><span class="section-number-4">1.1.2</span> 原始类型</h4>
<div class="outline-text-4" id="text-1-1-2">

<p>More generally, all of Java’s primitive types have corresponding classes in the scala package. And when you compile your Scala code to Java bytecodes, the Scala com- piler will use Java’s primitive types where possible to give you the perfor- mance benefits of the primitive types.
</p>
<p>
java原始类型已经全部导入了scala这个包里面，并且这个包是自动引入的。然后所有的原始类型全部变为大写字母开头比如Int,Float,Long等。这样存在一个好处就是从语法上完全统一了扩展类型和原始类型，并且对于这些原始类型scala在上面也做了一些扩展提供了方法，这样使得就更加模糊了扩展类型和原始类型之间的区别。但是scala在底层会尽可能地使用原始类型操作，在性能上不会存在损失。
</p>



<pre class="example">scala&gt; val a:Int=2
a: Int = 2

scala&gt; a.toString()
res0: String = 2

scala&gt; a.to(4)
res1: scala.collection.immutable.Range.Inclusive = Range(2, 3, 4)
</pre>


<p>
<b>TODO(dirlt):可以学习一下这些原始类型提供的方法</b> 
</p>

<hr/>
<p>
数组类型则是 Array[&lt;type&gt;] 比如
</p><ul>
<li>Array[String]
</li>
<li>Array[Array[String]]
</li>
</ul>




<pre class="example">scala&gt; val a = new Array[Array[String]](10)
a: Array[Array[String]] = Array(null, null, null, null, null, null, null, null, null, null)

scala&gt; a[0]
&lt;console&gt;:1: error: identifier expected but integer literal found.
       a[0]

scala&gt; a(0)
res1: Array[String] = null

scala&gt; a.apply(0)
res2: Array[String] = null
</pre>

<p>
注意这里不能够在用[]这种方式来访问数组，而必须使用()的方式来访问。实际上scala将()调用方法定向到了apply这个函数，可以认为是操作符重载。 
</p>
</div>

</div>

<div id="outline-container-1-1-3" class="outline-4">
<h4 id="sec-1-1-3"><span class="section-number-4">1.1.3</span> 变量定义</h4>
<div class="outline-text-4" id="text-1-1-3">

<p>Scala has two kinds of variables, vals and vars. A val is similar to a final variable in Java. Once initialized, a val can never be reassigned. A var, by contrast, is similar to a non-final variable in Java. A var can be reassigned throughout its lifetime. 
</p>
<p>
scala提供了两种变量定义的方式，分别是val和var. 对于val来说一旦赋值便不能够更改，有点类似C++的引用或者是用const/final字段做修饰。而var则是类似普通变量赋值之后依然可以更改。定义变量形式如下
</p>


<pre class="example">[val|var] &lt;name&gt; : &lt;type&gt; = &lt;initializor&gt;
</pre>

<p>
因为scala有type inference功能，所以实际上&lt;type&gt;这个字段可以省略，直接通过&lt;initializor&gt;这个字段来推测类型。
</p>



<pre class="example">scala&gt; val a = 1
a: Int = 1

scala&gt; val a = 1L
a: Long = 1

scala&gt; val a = 1.0
a: Double = 1.0

scala&gt; val a = "Hello"
a: String = Hello
</pre>


</div>

</div>

<div id="outline-container-1-1-4" class="outline-4">
<h4 id="sec-1-1-4"><span class="section-number-4">1.1.4</span> 函数定义</h4>
<div class="outline-text-4" id="text-1-1-4">

<p>a function defines an expression that results in a value.
</p>
<p>
大致形式如下
</p>


<pre class="example">def &lt;func&gt;(&lt;param1&gt;:&lt;type1&gt;, &lt;param2&gt;:&lt;type2&gt;,..):&lt;return-type&gt; = {
  // function body.
}
</pre>


<p>
函数本质上就是求得一个表达式，所以在&lt;function-body&gt;部分最后一个表达式就function返回结果，不需要使用return来显示说明。同样这里也可以使用type inference, 所以如果scala可以从function-body推断的话，那么&lt;return-type&gt;这个部分也可以不用写。但是scala type inference依然比较简单，如果有显示return语句的话(有时候我们确实需要），那么依然需要指定返回类型。
</p>


<pre class="example">scala&gt; def foo(a:Int,b:Int):Int = {
     | a+b
     | }
foo: (a: Int, b: Int)Int

scala&gt; def foo(a:Int,b:Int)  = {
     | a+b
     | }
foo: (a: Int, b: Int)Int

scala&gt; def foo(a:Int,b:Int)  = {
     | return a+b
     | }
&lt;console&gt;:9: error: method foo has return statement; needs result type
       return a+b
       ^
</pre>


<p>
但是scala也允许定义没有任何返回值的函数.对于这类函数&lt;return-type&gt;=Unit, 类似java里面的void. 但是从概念上来说因为不返回值，所以没有必要加上=这个标签，这样看上去更像是一个过程
</p>


<pre class="src src-Scala">def printLine(a:String) {
  println(a)
}
</pre>


<p>
<b>NOTE（dirlt)：需要注意的是传入的param实际上都是以val来定义的，所以在funciton-body里面不允许做修改</b>
</p>
</div>

</div>

<div id="outline-container-1-1-5" class="outline-4">
<h4 id="sec-1-1-5"><span class="section-number-4">1.1.5</span> 控制结构</h4>
<div class="outline-text-4" id="text-1-1-5">

<p>One thing you will notice is that almost all of Scala’s control structures result in some value. This is the approach taken by functional languages, in which programs are viewed as computing a value, thus the components of a program should also compute values. 
</p>
<p>
从函数式编程角度出发，所有的控制结构都应该是能够产生值的。对于scala来说也是，基本上所有的控制结构都能够产生值。
</p><ul>
<li>while # 不产生值
</li>
<li>foreach # args.foreach(&lt;function&gt;).
</li>
<li>for # for(arg &lt;- args). 注意这里的arg以val定义所以不能够修改
</li>
<li>if/else # val x = if (&lt;pred&gt;) &lt;value1&gt; else &lt;value2&gt;
</li>
<li>match/case # pattern matching.
</li>
<li>try/catch/finally # exception handling.
</li>
<li><b>NOTE(dirlt):没有break/continue语句</b>
</li>
</ul>



<hr/>
<p>
对于for来说分为两个部分，一个是循环部分，一个是执行部分。
</p>
<p>
循环部分的大致语法就是arg &lt;- args. 但是允许在后面接上过滤条件，然后允许多重嵌套用;分开。比如下面一段代码
</p>


<pre class="src src-Scala">for(i &lt;- 0 to 4
    if i%2 == 0
    if i%4 == 0;
    j &lt;- 0 to 5
    if j%2 == 1) {
  println(<span style="color: #ffff00;">"i="</span> + i + <span style="color: #ffff00;">",j="</span> + j);
}
</pre>


<p>
但是这样的方式是不产生值的，即使执行部分最后返回值，所以结果为()，如果需要产生值的话那么必须使用yield关键字。yield生成的效果非常类似list comprehension, 将执行部分返回值组成一个collection. 比如下面一段代码
</p>


<pre class="src src-Scala">val x = 
  for(i &lt;- 0 to 4) yield {
    i
  }
println(x) // Vector(0, 1, 2, 3, 4)
</pre>


<p>
上面这段代码效果和python list comprehension非常类似
</p>


<pre class="src src-Python">a = [x+2 for x in range(0,4) if x %2 == 0]
</pre>



<hr/>
<p>
异常的触发和java类似都是throw new Exception(). catch部分可以通过模式匹配来完成。finally则主要用于处理清理资源释放等问题。
</p>


<pre class="src src-Scala">def f() {
  throw new Exception(<span style="color: #ffff00;">"hello"</span>);
}

def g():Int = {
  try {
    f()
    2
  } catch {
    case e:Exception =&gt; 3
    case _:Throwable =&gt; 4
  } finally {
  }
}
</pre>

<p>
finally里面的返回值会被忽略，除非使用return来强制返回。但是建议不要这么做，finally所存在的主要理由应该是用来做cleanup的工作而不是参与计算（The best way to think of finally clauses is as a way to ensure some side effect happens, such as closing an open file.）
</p>
<p>
One difference from Java that you’ll quickly notice in Scala is that unlike Java, Scala does not require you to catch checked exceptions.（不强制捕获检查异常）
</p>

<hr/>
<p>
match和switch非常类似，但是有下面两个比较重要的差别：
</p><ul>
<li>One is that any kind of constant, as well as other things, can be used in cases in Scala, not just the integer-type and enum constants of Java’s case statements.
</li>
<li>Another difference is that there are no breaks at the end of each alternative. Instead the break is implicit, and there is no fall through from one alternative to the next.
</li>
</ul>


<p>
下面是一段示例代码
</p>


<pre class="src src-Scala">val x = <span style="color: #ffff00;">"hello"</span>;
val y = 
  x match {
    case <span style="color: #ffff00;">"world"</span> =&gt; 2;
    case <span style="color: #ffff00;">"hello"</span> =&gt; 3;
    case _ =&gt; 4;
  }
</pre>


<p>
<b>NOTE（dirlt）：限制以及内部实现</b>
</p>
</div>

</div>

<div id="outline-container-1-1-6" class="outline-4">
<h4 id="sec-1-1-6"><span class="section-number-4">1.1.6</span> 等值比较</h4>
<div class="outline-text-4" id="text-1-1-6">

<p>scala下==的和java是不同的。 <b>在java下==是比较引用相等性，而scala下==则是比较值相等性，也就是说会调用equal来做比较</b> 
</p>
<p>
<b>TODO（dirlt）：怎么判断引用相等？</b> 
</p>
</div>

</div>

<div id="outline-container-1-1-7" class="outline-4">
<h4 id="sec-1-1-7"><span class="section-number-4">1.1.7</span> operator</h4>
<div class="outline-text-4" id="text-1-1-7">

<ul>
<li>a op b -&gt; a.op(b)
</li>
<li>a(b) -&gt; a.apply(b)
</li>
<li>a(b)=c -&gt; a.update(b,c)
</li>
<li>a op: b -&gt; b.op(a) # If the method name ends in a colon, the method is invoked on the right operand. 
<ul>
<li><b>NOTE(dirlt):但是evaluation的顺序依然先是a，然后是b</b>
</li>
</ul>

</li>
</ul>





<pre class="src src-Scala">var Id = 0 // for identification.
class Op() {
  val id = Id;
  Id += 1;
  def + (x: Op) {
    println(<span style="color: #ffff00;">"operation by Op#"</span> + id);
  }
  def +: (x: Op) {
    println(<span style="color: #ffff00;">"operation by Op#"</span> + id);
  }
  def apply(p: Int) {
    println(<span style="color: #ffff00;">"apply with "</span> + p)
  }
  def update(p: Int, c:Int) {
    println(<span style="color: #ffff00;">"update with "</span> + p + <span style="color: #ffff00;">", "</span> + c);
  }
}
val a = new Op(); // Op#0
val b = new Op(); // Op#1
a + b;
a +: b;
a(0);
a(0)=1;
</pre>


</div>

</div>

<div id="outline-container-1-1-8" class="outline-4">
<h4 id="sec-1-1-8"><span class="section-number-4">1.1.8</span> 前提断言</h4>
<div class="outline-text-4" id="text-1-1-8">

<ul>
<li>require(expression)
</li>
<li>assert(expression)
</li>
<li>assert(experession,explaination)
</li>
</ul>


</div>
</div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> 面向对象</h3>
<div class="outline-text-3" id="text-1-2">


</div>

<div id="outline-container-1-2-1" class="outline-4">
<h4 id="sec-1-2-1"><span class="section-number-4">1.2.1</span> 单例对象</h4>
<div class="outline-text-4" id="text-1-2-1">

<p>单例对象很好地解决了Java的两个问题，一个是是单例模式没有集成到语言当中去导致代码编写冗余，一个是静态字段和静态方法嵌入在类定义中导致代码结构不清晰。下面是一段Java代码
</p>


<pre class="src src-Java">/* coding:utf-8
 * Copyright (C) dirlt
 */

public class Hello {
  public static final kConstant = 10;
  private static instance;
  public static void init() {
    instance = new Hello();
  }
  public static Hello getInstance() {
    return instance;
  }
  public void method() {
  }
}
</pre>


<p>
而scala引入单例对象方式解决这个问题。单例对象使用object来定义，使用时候直接拿名称引用即可。
</p>


<pre class="src src-Scala">object Hello {
  val kConstant = 10;
  def method() {
  }
}
Hello.method();
println(Hello.kConstant);
</pre>


<p>
When a singleton object shares the same name with a class, it is called that class’s companion object. You must define both the class and its companion object in the same source file. The class is called the companion class of the singleton object. A class and its companion object can access each other’s private members.
</p>
<p>
如果定义了和这个单例对象名称相同的类的话，那么
</p><ul>
<li><b>这两个定义必须放在同一份文件</b>
</li>
<li>这个类称为这个单例对象的 <b>共生类</b>
</li>
<li>这个单例对象称为这个类的 <b>共生对象</b> 
</li>
</ul>


<p>
A singleton object that does not share the same name with a companion class is called a standalone object. You can use standalone objects for many purposes, including collecting related utility methods together, or defining an entry point to a Scala application. 
</p>
</div>

</div>

<div id="outline-container-1-2-2" class="outline-4">
<h4 id="sec-1-2-2"><span class="section-number-4">1.2.2</span> 构造函数</h4>
<div class="outline-text-4" id="text-1-2-2">

<p>scala将构造函数和类定义合并，相比java方式更加简洁。下面是一段Java代码
</p>


<pre class="src src-Java">/* coding:utf-8
 * Copyright (C) dirlt
 */

public class Hello {
  private int n;
  private int d;
  public Hello(int n,int d) {
    this.n = n;
    this.d = d;
  }
  public Hello(int n) {
    this(n,0);
  }
  {
    System.out.println(<span style="color: #ffff00;">"initializing...("</span> + n + <span style="color: #ffff00;">","</span> + d + <span style="color: #ffff00;">")"</span>);
  }
}
</pre>

<p>
可以看到，实际上整个类的初始化是由两个部分来完成的，一个部分是构造函数部分，一个是类初始化执行代码。但是本质上它们都是为初始化类来服务的，或许我们就不应该将它们分开。此外构造函数重新赋值部分显得有点蹩脚，将传入的参数重新赋值到类内部字段上，略显得有点多余。
</p>
<p>
而下面是则是scala对应的代码
</p>


<pre class="src src-Scala">class Hello(pn: Int, pd: Int) {
  private val n = pn;
  private val d = pd;
  println(<span style="color: #ffff00;">"initializing...("</span> + n + <span style="color: #ffff00;">","</span> + d + <span style="color: #ffff00;">")"</span>);
  def this(pn:Int) = this(pn,0);
}
</pre>

<p>
scala将构造函数和初始化代码融合，只是使用初始化代码来作为构造函数，这样我们也不用在纠结到底是构造函数先执行还是初始化代码先执行。这个构造函数成为 <b>primary constructor</b> , 传入的参数称为 <b>class parameters</b> 注意这里parameters可以看做也是以val来定义的. 构造函数this(pn:Int)称为 <b>auxiliary constructor</b> . 
</p>
<p>
对于大部分构造函数来说传入的参数都想留存一份下来。为此scala引入了 <b>parametric fields</b> 这个概念。只需要在class parameters上面稍作扩展即可
</p>


<pre class="src src-Scala">class Hello(private val pn: Int, private val pd: Int) {
  println(<span style="color: #ffff00;">"initializing...("</span> + pn + <span style="color: #ffff00;">","</span> + pd + <span style="color: #ffff00;">")"</span>);
  def this(pn:Int) = this(pn,0);
}
</pre>

<p>
在class parameter之前添加[private|public|protected|override] [val|var]即可，这样既定义了类构造函数参数也定义了对应的字段。
</p>
<p>
如果面向对象角度相比于java，上面这种方式确实简化不少。而scala本意应该是更想到达函数式类构造效果，构造生成对象称为 <b>functional object</b> . 我们之所以想保存这些参数是因为在编写java时候这些参数只能够在构造函数中获得，而在scala里面实际上在整个类里面都是可以获得的，因此对于上面情况来说我们根本没有必要保存这些类参数。在下面closure代码里面我们实际上可以直接引用pn,pd来参与计算。
</p>


<pre class="src src-Scala">class Hello(pn: Int, pd: Int) {
  def n = pn
  def d = pd
  def closure(ratio:Float) = {
    ratio * pn + pd;
  }
}

val h = new Hello(2,1);
println(h.closure(2.0f));
</pre>


</div>

</div>

<div id="outline-container-1-2-3" class="outline-4">
<h4 id="sec-1-2-3"><span class="section-number-4">1.2.3</span> override</h4>
<div class="outline-text-4" id="text-1-2-3">

<p>scala提供了override这个关键字可以确保复写错误几率降低。对于java来说@Override这个注解是可选的，但是对于scala来说override关键字是必须的。如果B继承A复写其方法但是没有提供override关键字的话，就会出现编译错误，这样就强制要求在复写方法的时候提供override。一旦强制写override的话我们就能够发现一些我们原本希望复写某方法但是却没有复写的情况。
</p>



<pre class="src src-Scala">class Hello(pn: Int, pd: Int) {
  def toString() = <span style="color: #ffff00;">"n = "</span> + pn + <span style="color: #ffff00;">", d = "</span> + pd;
}
</pre>


<p>
编译出现错误
</p>


<pre class="example">/Users/dirlt/scala/Hello.scala:2: error: overriding method toString in class Object of type ()String;
 method toString needs `override' modifier
  def toString() = "n = " + pn + ", d = " + pd;
      ^
one error found
</pre>


<p>
可以复写的不仅有方法也包括字段。字段复写相对来说就比较简单只是覆盖基类字段，但是也可能会影响到函数调用。
</p>


<pre class="src src-Scala">class Hello {
  val x = 0;
  def echoX() {
    println(x);
  }
}

class Hello2 extends Hello {
  override val x = 1;
}

val x:Hello = new Hello2();
x.echoX(); // 1
</pre>


</div>

</div>

<div id="outline-container-1-2-4" class="outline-4">
<h4 id="sec-1-2-4"><span class="section-number-4">1.2.4</span> 隐式转换</h4>
<div class="outline-text-4" id="text-1-2-4">

<p>scala可以通过提供隐式转换函数来完成，函数需要添加关键字implicit作为前缀. 注意这个隐式转换函数必须放在类外部来定义。 
</p>


<pre class="src src-Scala">class Hello(p:Int) {
  private val x = p;
  def op(h:Hello) {
    println(<span style="color: #ffff00;">"op("</span> + x + <span style="color: #ffff00;">","</span> + h.x + <span style="color: #ffff00;">")"</span>);
  }
}

implicit def intToHello(x:Int) = {
  println(<span style="color: #ffff00;">"do implicit conversion"</span>);
  new Hello(x);
}

val h = new Hello(1);
h op 2;
</pre>


<p>
但是从一个类型向另外一个类型做隐式转换只能够提供一个函数，不然就会出现歧义. 这里我提供了两个隐式转换函数结果编译出错。 
</p>


<pre class="example">Note that implicit conversions are not applicable because they are ambiguous:
 both method intToHello of type (x: Int)this.Hello
 and method intToHello2 of type (x: Int)this.Hello
 are possible conversion functions from Int(2) to this.Hello
</pre>


<p>
Because im- plicit conversions are applied implicitly by the compiler, not explicitly writ- ten down in the source code, it can be non-obvious to client programmers what implicit conversions are being applied. 
</p>
<p>
所以隐式转换这个东西还是尽量少用比较好。
</p>
</div>

</div>

<div id="outline-container-1-2-5" class="outline-4">
<h4 id="sec-1-2-5"><span class="section-number-4">1.2.5</span> 类型层次</h4>
<div class="outline-text-4" id="text-1-2-5">

<ul>
<li>Unit () # 赋值语句产生()
</li>
<li>Null null
</li>
<li>Nothing
</li>
</ul>


</div>
</div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> 面向函数</h3>
<div class="outline-text-3" id="text-1-3">


</div>

<div id="outline-container-1-3-1" class="outline-4">
<h4 id="sec-1-3-1"><span class="section-number-4">1.3.1</span> 匿名函数</h4>
<div class="outline-text-4" id="text-1-3-1">

<p><b>NOTE（dirlt）：aka. function literal</b> 
</p>



<pre class="example">(&lt;param1&gt;:&lt;type1&gt;,&lt;param2&gt;:&lt;type2&gt;,...) =&gt; { &lt;funciton-body&gt; }
</pre>

<p>
匿名函数不允许指定return-type，也就是说匿名函数必须通过type inference确定返回类型。
</p>
<p>
但是在某些特殊情况则不需要指定parameter-type, 因为parameter-type可以通过上下文推导出来。 
</p>


<pre class="src src-Scala">val x = (0 to 4).filter((x:Int) =&gt; x &gt; 2)
val y = (0 to 4).filter(x =&gt; x &gt; 2)
</pre>

<p>
This is called <b>target typing</b> , because the targeted usage of an expression is allowed to influence the typing of that expression
</p>
<p>
使用placeholder syntax也可以构造一些简单的函数，_相当于一个函数参数占位符。但是因为_之间没有办法做区分，所以就函数功能来说非常有限。
</p>


<pre class="src src-Scala">val y = (0 to 4).filter(_ &gt; 2)
val f = (_:Int) + (_:Int) // (x:Int,y:Int) =&gt; x + y
</pre>


</div>

</div>

<div id="outline-container-1-3-2" class="outline-4">
<h4 id="sec-1-3-2"><span class="section-number-4">1.3.2</span> 偏应用函数</h4>
<div class="outline-text-4" id="text-1-3-2">

<p>偏应用函数(partially applied function)允许我们将部分参数作用在函数上形成特化函数。
</p>


<pre class="src src-Scala">def foo1(x:Int)(y:Int) = x + y
def foo2(x:Int,y:Int) = x + y
val pFoo1 = (y:Int) =&gt; foo1(1)(y)
val pFoo2 = (y:Int) =&gt; foo2(1,y)
</pre>


<p> 
placeholder syntax提供了更简单的方法，并且_能够作为后续多个参数的占位符。
</p>


<pre class="src src-Scala">def foo1(x:Int)(y:Int) = x + y
def foo2(x:Int,y:Int) = x + y
// val pFoo1 = foo1(_) // also OK.
val pFoo1 = foo1(1)(_)
val pFoo2 = foo2(1,_:Int)
</pre>


</div>

</div>

<div id="outline-container-1-3-3" class="outline-4">
<h4 id="sec-1-3-3"><span class="section-number-4">1.3.3</span> closure</h4>
<div class="outline-text-4" id="text-1-3-3">

<p>function literal内部取值通常有三种：
</p><ul>
<li>constant # 常量
</li>
<li>bound variable # 函数参数
</li>
<li>free variable # 外部变量
</li>
</ul>


<p>
以下面两个function literal为例
</p><ul>
<li>(x:Int) =&gt; x + 1 + y
<ul>
<li>x as bound variable
</li>
<li>1 as constant
</li>
<li>y as free variable
</li>
</ul>

</li>
</ul>

<p>对于一个function literal来说的话，内部没有free variable的话，那么称为closed term. 否则称为open term. 
</p>
<p>
<b>open term因为free variable被captured住之后形成的function value称为closure.</b> The resulting function value, which will contain a reference to the captured more variable, is called a closure, therefore, because the function value is the end product of the act of closing the open term.
</p>
</div>
</div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> 面向泛型</h3>
<div class="outline-text-3" id="text-1-4">

</div>
</div>
</div>
</div>

<!-- Baidu Analytics BEGIN --><script type="text/javascript">var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F54a700ad7035f6e485eaf2300641e7e9' type='text/javascript'%3E%3C/script%3E"));</script><!-- Baidu Analytics END --><!-- Google Analytics BEGIN --><script type="text/javascript">  var _gaq = _gaq || [];  _gaq.push(['_setAccount', 'UA-31377772-1']);  _gaq.push(['_trackPageview']);  (function() {    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);  })();</script><!-- Google Analytics END --><!-- Baidu Button BEGIN --><!-- <script type="text/javascript" id="bdshare_js" data="type=tools&amp;uid=6762177" ></script><script type="text/javascript" id="bdshell_js"></script><script type="text/javascript"> document.getElementById("bdshell_js").src = "http://bdimg.share.baidu.com/static/js/shell_v2.js?cdnversion=" + Math.ceil(new Date()/3600000)</script> --><!-- Baidu Button END --><!-- G+ BEGIN --><!-- Place this render call where appropriate --><script type="text/javascript">  (function() {    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;    po.src = 'https://apis.google.com/js/plusone.js';    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);  })();</script><!-- G+ END --><!-- DISQUS BEGIN --><div id="disqus_thread"></div><script type="text/javascript">/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * *//* required: replace example with your forum shortname  */var disqus_shortname = 'dirlt';var disqus_identifier = 'scala.html';var disqus_title = 'scala.html';var disqus_url = 'http://dirlt.com/scala.html';/* * * DON'T EDIT BELOW THIS LINE * * */(function() {var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);})();</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a><!-- DISQUS END --></body>
</html>
