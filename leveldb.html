<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head><!-- <meta name="baidu-site-verification" content="707024a76f8f40b549f07f478abab237"/> -->
<title>leveldb</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="title" content="leveldb"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2013-08-02 01:03:47 CST"/>
<meta name="author" content="dirtysalt"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  div.inlinetask {
    padding:10px;
    border:2px solid gray;
    margin:10px;
    background: #ffffcc;
  }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style><link rel="stylesheet" type="text/css" href="css/site-plain.css" />
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>

</head>
<body><!-- <div id="bdshare" class="bdshare_t bds_tools_32 get-codes-bdshare"><a class="bds_tsina"></a><span class="bds_more"></span><a class="shareCount"></a></div> --><!-- Place this tag where you want the +1 button to render --><g:plusone annotation="inline"></g:plusone>


<div id="content">
<h1 class="title">leveldb</h1>


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="leveldb.html#sec-1">1 leveldb</a>
<ul>
<li><a href="leveldb.html#sec-1-1">1.1 Introduction</a></li>
<li><a href="leveldb.html#sec-1-2">1.2 WriteBatch</a></li>
<li><a href="leveldb.html#sec-1-3">1.3 BloomFilter</a>
<ul>
<li><a href="leveldb.html#sec-1-3-1">1.3.1 Format</a></li>
<li><a href="leveldb.html#sec-1-3-2">1.3.2 FilterBlockBuilder</a></li>
<li><a href="leveldb.html#sec-1-3-3">1.3.3 FilterBlockReader</a></li>
</ul>
</li>
<li><a href="leveldb.html#sec-1-4">1.4 Storage</a>
<ul>
<li><a href="leveldb.html#sec-1-4-1">1.4.1 MemTable</a></li>
<li><a href="leveldb.html#sec-1-4-2">1.4.2 RedoLog</a></li>
<li><a href="leveldb.html#sec-1-4-3">1.4.3 DiskTable</a></li>
</ul>
</li>
<li><a href="leveldb.html#sec-1-5">1.5 Compaction</a></li>
<li><a href="leveldb.html#sec-1-6">1.6 Recovery</a></li>
<li><a href="leveldb.html#sec-1-7">1.7 Snapshot</a></li>
<li><a href="leveldb.html#sec-1-8">1.8 Cache</a></li>
<li><a href="leveldb.html#sec-1-9">1.9 Option</a></li>
<li><a href="leveldb.html#sec-1-10">1.10 Code Analysis</a>
<ul>
<li><a href="leveldb.html#sec-1-10-1">1.10.1 Interface</a>
<ul>
<li><a href="leveldb.html#sec-1-10-1-1">1.10.1.1 cache.h</a></li>
<li><a href="leveldb.html#sec-1-10-1-2">1.10.1.2 comparator.h</a></li>
<li><a href="leveldb.html#sec-1-10-1-3">1.10.1.3 db.h</a></li>
<li><a href="leveldb.html#sec-1-10-1-4">1.10.1.4 env.h</a>
<ul>
<li><a href="leveldb.html#sec-1-10-1-4-1">1.10.1.4.1 Env</a></li>
<li><a href="leveldb.html#sec-1-10-1-4-2">1.10.1.4.2 FileLock</a></li>
<li><a href="leveldb.html#sec-1-10-1-4-3">1.10.1.4.3 Logger</a></li>
<li><a href="leveldb.html#sec-1-10-1-4-4">1.10.1.4.4 RandomAccessFile</a></li>
<li><a href="leveldb.html#sec-1-10-1-4-5">1.10.1.4.5 SequentialFile</a></li>
<li><a href="leveldb.html#sec-1-10-1-4-6">1.10.1.4.6 WritableFile</a></li>
</ul>
</li>
<li><a href="leveldb.html#sec-1-10-1-5">1.10.1.5 filter_policy.h</a></li>
<li><a href="leveldb.html#sec-1-10-1-6">1.10.1.6 iterator.h</a></li>
<li><a href="leveldb.html#sec-1-10-1-7">1.10.1.7 options.h</a>
<ul>
<li><a href="leveldb.html#sec-1-10-1-7-1">1.10.1.7.1 Options</a></li>
<li><a href="leveldb.html#sec-1-10-1-7-2">1.10.1.7.2 ReadOptions</a></li>
<li><a href="leveldb.html#sec-1-10-1-7-3">1.10.1.7.3 WriteOptions</a></li>
</ul>
</li>
<li><a href="leveldb.html#sec-1-10-1-8">1.10.1.8 slice.h</a></li>
<li><a href="leveldb.html#sec-1-10-1-9">1.10.1.9 status.h</a></li>
<li><a href="leveldb.html#sec-1-10-1-10">1.10.1.10 table_builder.h</a></li>
<li><a href="leveldb.html#sec-1-10-1-11">1.10.1.11 table.h</a></li>
<li><a href="leveldb.html#sec-1-10-1-12">1.10.1.12 write_batch.h</a></li>
</ul>
</li>
<li><a href="leveldb.html#sec-1-10-2">1.10.2 Implementation</a></li>
<li><a href="leveldb.html#sec-1-10-3">1.10.3 DB</a>
<ul>
<li><a href="leveldb.html#sec-1-10-3-1">1.10.3.1 FileName</a></li>
<li><a href="leveldb.html#sec-1-10-3-2">1.10.3.2 Config</a></li>
<li><a href="leveldb.html#sec-1-10-3-3">1.10.3.3 DBImpl</a>
<ul>
<li><a href="leveldb.html#sec-1-10-3-3-1">1.10.3.3.1 Open</a></li>
<li><a href="leveldb.html#sec-1-10-3-3-2">1.10.3.3.2 DBImpl</a></li>
<li><a href="leveldb.html#sec-1-10-3-3-3">1.10.3.3.3 NewDB</a></li>
<li><a href="leveldb.html#sec-1-10-3-3-4">1.10.3.3.4 Recover</a></li>
<li><a href="leveldb.html#sec-1-10-3-3-5">1.10.3.3.5 RecoverLogFile</a></li>
<li><a href="leveldb.html#sec-1-10-3-3-6">1.10.3.3.6 MaybeIgnoreError</a></li>
<li><a href="leveldb.html#sec-1-10-3-3-7">1.10.3.3.7 WriteLevel0Table</a></li>
<li><a href="leveldb.html#sec-1-10-3-3-8">1.10.3.3.8 Put</a></li>
<li><a href="leveldb.html#sec-1-10-3-3-9">1.10.3.3.9 Delete</a></li>
<li><a href="leveldb.html#sec-1-10-3-3-10">1.10.3.3.10 LoggingResponsibility</a></li>
<li><a href="leveldb.html#sec-1-10-3-3-11">1.10.3.3.11 MakeRoomForWrite</a></li>
<li><a href="leveldb.html#sec-1-10-3-3-12">1.10.3.3.12 MaybeScheduleCompaction</a></li>
<li><a href="leveldb.html#sec-1-10-3-3-13">1.10.3.3.13 BackgroundCall</a></li>
<li><a href="leveldb.html#sec-1-10-3-3-14">1.10.3.3.14 BackgroundCompaction</a></li>
<li><a href="leveldb.html#sec-1-10-3-3-15">1.10.3.3.15 CompactMemTable</a></li>
<li><a href="leveldb.html#sec-1-10-3-3-16">1.10.3.3.16 CompactRange</a></li>
<li><a href="leveldb.html#sec-1-10-3-3-17">1.10.3.3.17 TEST_CompactMemTable</a></li>
<li><a href="leveldb.html#sec-1-10-3-3-18">1.10.3.3.18 TEST_CompactRange</a></li>
<li><a href="leveldb.html#sec-1-10-3-3-19">1.10.3.3.19 DoCompactionWork</a></li>
<li><a href="leveldb.html#sec-1-10-3-3-20">1.10.3.3.20 CleanupCompaction</a></li>
<li><a href="leveldb.html#sec-1-10-3-3-21">1.10.3.3.21 InstallCompactionResults</a></li>
<li><a href="leveldb.html#sec-1-10-3-3-22">1.10.3.3.22 OpenCompactionOutputFile</a></li>
<li><a href="leveldb.html#sec-1-10-3-3-23">1.10.3.3.23 FinishCompactionOutputFile</a></li>
<li><a href="leveldb.html#sec-1-10-3-3-24">1.10.3.3.24 Write</a></li>
<li><a href="leveldb.html#sec-1-10-3-3-25">1.10.3.3.25 SanitizeOptions</a></li>
<li><a href="leveldb.html#sec-1-10-3-3-26">1.10.3.3.26 GetProperty</a></li>
<li><a href="leveldb.html#sec-1-10-3-3-27">1.10.3.3.27 GetApproximateSizes</a></li>
<li><a href="leveldb.html#sec-1-10-3-3-28">1.10.3.3.28 GetSnapshot</a></li>
<li><a href="leveldb.html#sec-1-10-3-3-29">1.10.3.3.29 ReleaseSnapshot</a></li>
<li><a href="leveldb.html#sec-1-10-3-3-30">1.10.3.3.30 DeleteObsoleteFiles</a></li>
<li><a href="leveldb.html#sec-1-10-3-3-31">1.10.3.3.31 Get</a></li>
<li><a href="leveldb.html#sec-1-10-3-3-32">1.10.3.3.32 NewInternalIterator</a></li>
<li><a href="leveldb.html#sec-1-10-3-3-33">1.10.3.3.33 NewInterator</a></li>
</ul>
</li>
<li><a href="leveldb.html#sec-1-10-3-4">1.10.3.4 DBIter</a>
<ul>
<li><a href="leveldb.html#sec-1-10-3-4-1">1.10.3.4.1 NewDBIterator</a></li>
<li><a href="leveldb.html#sec-1-10-3-4-2">1.10.3.4.2 DBIter</a></li>
<li><a href="leveldb.html#sec-1-10-3-4-3">1.10.3.4.3 ClearSavedValue</a></li>
<li><a href="leveldb.html#sec-1-10-3-4-4">1.10.3.4.4 ParseKey</a></li>
<li><a href="leveldb.html#sec-1-10-3-4-5">1.10.3.4.5 SaveKey</a></li>
<li><a href="leveldb.html#sec-1-10-3-4-6">1.10.3.4.6 Seek</a></li>
<li><a href="leveldb.html#sec-1-10-3-4-7">1.10.3.4.7 Next</a></li>
<li><a href="leveldb.html#sec-1-10-3-4-8">1.10.3.4.8 Prev</a></li>
<li><a href="leveldb.html#sec-1-10-3-4-9">1.10.3.4.9 FindNextUserEntry</a></li>
<li><a href="leveldb.html#sec-1-10-3-4-10">1.10.3.4.10 FindPrevUserEntry</a></li>
<li><a href="leveldb.html#sec-1-10-3-4-11">1.10.3.4.11 SeekToFirst</a></li>
<li><a href="leveldb.html#sec-1-10-3-4-12">1.10.3.4.12 SeekToLast</a></li>
</ul>
</li>
<li><a href="leveldb.html#sec-1-10-3-5">1.10.3.5 LookupKey</a></li>
<li><a href="leveldb.html#sec-1-10-3-6">1.10.3.6 ValueType</a></li>
<li><a href="leveldb.html#sec-1-10-3-7">1.10.3.7 SequenceNumber</a></li>
<li><a href="leveldb.html#sec-1-10-3-8">1.10.3.8 InternalKey</a>
<ul>
<li><a href="leveldb.html#sec-1-10-3-8-1">1.10.3.8.1 ExtracrUserKey</a></li>
<li><a href="leveldb.html#sec-1-10-3-8-2">1.10.3.8.2 ExtractValueType</a></li>
<li><a href="leveldb.html#sec-1-10-3-8-3">1.10.3.8.3 ParsedInternalKey</a></li>
<li><a href="leveldb.html#sec-1-10-3-8-4">1.10.3.8.4 InternalKeyEncodingLength</a></li>
<li><a href="leveldb.html#sec-1-10-3-8-5">1.10.3.8.5 AppendInternalKey</a></li>
<li><a href="leveldb.html#sec-1-10-3-8-6">1.10.3.8.6 PackSequenceAndType</a></li>
<li><a href="leveldb.html#sec-1-10-3-8-7">1.10.3.8.7 ParseInternalKey</a></li>
</ul>
</li>
<li><a href="leveldb.html#sec-1-10-3-9">1.10.3.9 InternalKeyComparator</a>
<ul>
<li><a href="leveldb.html#sec-1-10-3-9-1">1.10.3.9.1 Compare</a></li>
<li><a href="leveldb.html#sec-1-10-3-9-2">1.10.3.9.2 FindShortestSeparator</a></li>
<li><a href="leveldb.html#sec-1-10-3-9-3">1.10.3.9.3 FindShortSuccessor</a></li>
</ul>
</li>
<li><a href="leveldb.html#sec-1-10-3-10">1.10.3.10 FileMetaData</a></li>
<li><a href="leveldb.html#sec-1-10-3-11">1.10.3.11 Version</a>
<ul>
<li><a href="leveldb.html#sec-1-10-3-11-1">1.10.3.11.1 AddIterators</a></li>
<li><a href="leveldb.html#sec-1-10-3-11-2">1.10.3.11.2 NewConcatenatingIterator</a></li>
<li><a href="leveldb.html#sec-1-10-3-11-3">1.10.3.11.3 LevelFileNumIterator</a></li>
<li><a href="leveldb.html#sec-1-10-3-11-4">1.10.3.11.4 GetFileIterator</a></li>
<li><a href="leveldb.html#sec-1-10-3-11-5">1.10.3.11.5 FindFile</a></li>
<li><a href="leveldb.html#sec-1-10-3-11-6">1.10.3.11.6 SomeFileOverlapsRange</a></li>
<li><a href="leveldb.html#sec-1-10-3-11-7">1.10.3.11.7 AfterFile</a></li>
<li><a href="leveldb.html#sec-1-10-3-11-8">1.10.3.11.8 BeforeFile</a></li>
<li><a href="leveldb.html#sec-1-10-3-11-9">1.10.3.11.9 GetStats</a></li>
<li><a href="leveldb.html#sec-1-10-3-11-10">1.10.3.11.10 NewestFirst</a></li>
<li><a href="leveldb.html#sec-1-10-3-11-11">1.10.3.11.11 Get</a></li>
<li><a href="leveldb.html#sec-1-10-3-11-12">1.10.3.11.12 GetValue</a></li>
<li><a href="leveldb.html#sec-1-10-3-11-13">1.10.3.11.13 UpdateStats</a></li>
<li><a href="leveldb.html#sec-1-10-3-11-14">1.10.3.11.14 GetOverlappingInputs</a></li>
<li><a href="leveldb.html#sec-1-10-3-11-15">1.10.3.11.15 OverlapInLevel</a></li>
<li><a href="leveldb.html#sec-1-10-3-11-16">1.10.3.11.16 PickLevelForMemTableOutput</a></li>
<li><a href="leveldb.html#sec-1-10-3-11-17">1.10.3.11.17 DebugString</a></li>
</ul>
</li>
<li><a href="leveldb.html#sec-1-10-3-12">1.10.3.12 VersionSet</a>
<ul>
<li><a href="leveldb.html#sec-1-10-3-12-1">1.10.3.12.1 VersionSet</a></li>
<li><a href="leveldb.html#sec-1-10-3-12-2">1.10.3.12.2 NeedsCompaction</a></li>
<li><a href="leveldb.html#sec-1-10-3-12-3">1.10.3.12.3 AppendVersion</a></li>
<li><a href="leveldb.html#sec-1-10-3-12-4">1.10.3.12.4 NumLevelFiles</a></li>
<li><a href="leveldb.html#sec-1-10-3-12-5">1.10.3.12.5 NumLevelBytes</a></li>
<li><a href="leveldb.html#sec-1-10-3-12-6">1.10.3.12.6 TotalFileSize</a></li>
<li><a href="leveldb.html#sec-1-10-3-12-7">1.10.3.12.7 MarkFileNumberUsed</a></li>
<li><a href="leveldb.html#sec-1-10-3-12-8">1.10.3.12.8 ApproximateOffsetOf</a></li>
<li><a href="leveldb.html#sec-1-10-3-12-9">1.10.3.12.9 AddLiveFiles</a></li>
<li><a href="leveldb.html#sec-1-10-3-12-10">1.10.3.12.10 LevelSummary</a></li>
<li><a href="leveldb.html#sec-1-10-3-12-11">1.10.3.12.11 WriteSnapshot</a></li>
<li><a href="leveldb.html#sec-1-10-3-12-12">1.10.3.12.12 Finalize</a></li>
<li><a href="leveldb.html#sec-1-10-3-12-13">1.10.3.12.13 Recover</a></li>
<li><a href="leveldb.html#sec-1-10-3-12-14">1.10.3.12.14 LogAndApply</a></li>
<li><a href="leveldb.html#sec-1-10-3-12-15">1.10.3.12.15 GetRange</a></li>
<li><a href="leveldb.html#sec-1-10-3-12-16">1.10.3.12.16 PickCompaction</a></li>
<li><a href="leveldb.html#sec-1-10-3-12-17">1.10.3.12.17 CompactRange</a></li>
<li><a href="leveldb.html#sec-1-10-3-12-18">1.10.3.12.18 GetRange2</a></li>
<li><a href="leveldb.html#sec-1-10-3-12-19">1.10.3.12.19 SetupOtherInputs</a></li>
<li><a href="leveldb.html#sec-1-10-3-12-20">1.10.3.12.20 MakeInputIterator</a></li>
</ul>
</li>
<li><a href="leveldb.html#sec-1-10-3-13">1.10.3.13 VersionSetBuilder</a>
<ul>
<li><a href="leveldb.html#sec-1-10-3-13-1">1.10.3.13.1 VersionSetBuilder</a></li>
<li><a href="leveldb.html#sec-1-10-3-13-2">1.10.3.13.2 Apply</a></li>
<li><a href="leveldb.html#sec-1-10-3-13-3">1.10.3.13.3 MaybeAddFile</a></li>
<li><a href="leveldb.html#sec-1-10-3-13-4">1.10.3.13.4 SaveTo</a></li>
</ul>
</li>
<li><a href="leveldb.html#sec-1-10-3-14">1.10.3.14 Compaction</a>
<ul>
<li><a href="leveldb.html#sec-1-10-3-14-1">1.10.3.14.1 Compaction</a></li>
<li><a href="leveldb.html#sec-1-10-3-14-2">1.10.3.14.2 MaxFileSizeForLevel</a></li>
<li><a href="leveldb.html#sec-1-10-3-14-3">1.10.3.14.3 MaxBytesForLevel</a></li>
<li><a href="leveldb.html#sec-1-10-3-14-4">1.10.3.14.4 IsTrivialMove</a></li>
<li><a href="leveldb.html#sec-1-10-3-14-5">1.10.3.14.5 AddInputDeletions</a></li>
<li><a href="leveldb.html#sec-1-10-3-14-6">1.10.3.14.6 IsBaseLevelForKey</a></li>
<li><a href="leveldb.html#sec-1-10-3-14-7">1.10.3.14.7 ShouldStopBefore</a></li>
<li><a href="leveldb.html#sec-1-10-3-14-8">1.10.3.14.8 ReleaseInputs</a></li>
</ul>
</li>
<li><a href="leveldb.html#sec-1-10-3-15">1.10.3.15 CompactionState</a></li>
<li><a href="leveldb.html#sec-1-10-3-16">1.10.3.16 VersionEdit</a>
<ul>
<li><a href="leveldb.html#sec-1-10-3-16-1">1.10.3.16.1 SetCompactPoint</a></li>
<li><a href="leveldb.html#sec-1-10-3-16-2">1.10.3.16.2 AddFile</a></li>
<li><a href="leveldb.html#sec-1-10-3-16-3">1.10.3.16.3 DeleteFile</a></li>
</ul>
</li>
<li><a href="leveldb.html#sec-1-10-3-17">1.10.3.17 ByteWiseComparatorImpl</a></li>
<li><a href="leveldb.html#sec-1-10-3-18">1.10.3.18 SnapshotImpl</a></li>
</ul>
</li>
<li><a href="leveldb.html#sec-1-10-4">1.10.4 Posix</a>
<ul>
<li><a href="leveldb.html#sec-1-10-4-1">1.10.4.1 PosixEnv</a>
<ul>
<li><a href="leveldb.html#sec-1-10-4-1-1">1.10.4.1.1 LockOrUnlock</a></li>
<li><a href="leveldb.html#sec-1-10-4-1-2">1.10.4.1.2 Schedule</a></li>
<li><a href="leveldb.html#sec-1-10-4-1-3">1.10.4.1.3 StartThread</a></li>
<li><a href="leveldb.html#sec-1-10-4-1-4">1.10.4.1.4 Default</a></li>
</ul>
</li>
<li><a href="leveldb.html#sec-1-10-4-2">1.10.4.2 PosixFileLock</a></li>
<li><a href="leveldb.html#sec-1-10-4-3">1.10.4.3 PosixLogger</a></li>
<li><a href="leveldb.html#sec-1-10-4-4">1.10.4.4 PosixRandomAccessFile</a></li>
<li><a href="leveldb.html#sec-1-10-4-5">1.10.4.5 PosixSequentialFile</a></li>
<li><a href="leveldb.html#sec-1-10-4-6">1.10.4.6 PosixMmapFile</a>
<ul>
<li><a href="leveldb.html#sec-1-10-4-6-1">1.10.4.6.1 Roundup</a></li>
<li><a href="leveldb.html#sec-1-10-4-6-2">1.10.4.6.2 TruncateToPageBoundar</a></li>
<li><a href="leveldb.html#sec-1-10-4-6-3">1.10.4.6.3 UnmapCurrentRegion</a></li>
<li><a href="leveldb.html#sec-1-10-4-6-4">1.10.4.6.4 MapNewRegion</a></li>
</ul></li>
</ul>
</li>
<li><a href="leveldb.html#sec-1-10-5">1.10.5 Cache</a>
<ul>
<li><a href="leveldb.html#sec-1-10-5-1">1.10.5.1 ShardedLRUCache</a></li>
<li><a href="leveldb.html#sec-1-10-5-2">1.10.5.2 LRUCache</a>
<ul>
<li><a href="leveldb.html#sec-1-10-5-2-1">1.10.5.2.1 Insert</a></li>
<li><a href="leveldb.html#sec-1-10-5-2-2">1.10.5.2.2 Lookup</a></li>
<li><a href="leveldb.html#sec-1-10-5-2-3">1.10.5.2.3 Release</a></li>
<li><a href="leveldb.html#sec-1-10-5-2-4">1.10.5.2.4 Erase</a></li>
</ul>
</li>
<li><a href="leveldb.html#sec-1-10-5-3">1.10.5.3 LRUHandle</a></li>
<li><a href="leveldb.html#sec-1-10-5-4">1.10.5.4 HandleTable</a></li>
</ul>
</li>
<li><a href="leveldb.html#sec-1-10-6">1.10.6 Batch</a>
<ul>
<li><a href="leveldb.html#sec-1-10-6-1">1.10.6.1 WriteBatch</a>
<ul>
<li><a href="leveldb.html#sec-1-10-6-1-1">1.10.6.1.1 Count</a></li>
<li><a href="leveldb.html#sec-1-10-6-1-2">1.10.6.1.2 Sequence</a></li>
<li><a href="leveldb.html#sec-1-10-6-1-3">1.10.6.1.3 Contents</a></li>
<li><a href="leveldb.html#sec-1-10-6-1-4">1.10.6.1.4 Clear</a></li>
<li><a href="leveldb.html#sec-1-10-6-1-5">1.10.6.1.5 Put</a></li>
<li><a href="leveldb.html#sec-1-10-6-1-6">1.10.6.1.6 Delete</a></li>
<li><a href="leveldb.html#sec-1-10-6-1-7">1.10.6.1.7 InsertInto</a></li>
<li><a href="leveldb.html#sec-1-10-6-1-8">1.10.6.1.8 Iterate</a></li>
</ul>
</li>
<li><a href="leveldb.html#sec-1-10-6-2">1.10.6.2 MemTable</a>
<ul>
<li><a href="leveldb.html#sec-1-10-6-2-1">1.10.6.2.1 MemTable</a></li>
<li><a href="leveldb.html#sec-1-10-6-2-2">1.10.6.2.2 Compare</a></li>
<li><a href="leveldb.html#sec-1-10-6-2-3">1.10.6.2.3 Add</a></li>
<li><a href="leveldb.html#sec-1-10-6-2-4">1.10.6.2.4 Get</a></li>
</ul>
</li>
<li><a href="leveldb.html#sec-1-10-6-3">1.10.6.3 MemTableInserter</a></li>
<li><a href="leveldb.html#sec-1-10-6-4">1.10.6.4 MemtableIterator</a></li>
</ul>
</li>
<li><a href="leveldb.html#sec-1-10-7">1.10.7 Log</a>
<ul>
<li><a href="leveldb.html#sec-1-10-7-1">1.10.7.1 LogFormat</a></li>
<li><a href="leveldb.html#sec-1-10-7-2">1.10.7.2 LogWriter</a>
<ul>
<li><a href="leveldb.html#sec-1-10-7-2-1">1.10.7.2.1 Writer</a></li>
<li><a href="leveldb.html#sec-1-10-7-2-2">1.10.7.2.2 AddRecord</a></li>
<li><a href="leveldb.html#sec-1-10-7-2-3">1.10.7.2.3 EmitPhysicalRecord</a></li>
</ul>
</li>
<li><a href="leveldb.html#sec-1-10-7-3">1.10.7.3 LogReader</a>
<ul>
<li><a href="leveldb.html#sec-1-10-7-3-1">1.10.7.3.1 Reader</a></li>
<li><a href="leveldb.html#sec-1-10-7-3-2">1.10.7.3.2 ReadPhysicalRecord</a></li>
<li><a href="leveldb.html#sec-1-10-7-3-3">1.10.7.3.3 ReadRecord</a></li>
<li><a href="leveldb.html#sec-1-10-7-3-4">1.10.7.3.4 SkipToInitialBlock</a></li>
<li><a href="leveldb.html#sec-1-10-7-3-5">1.10.7.3.5 ReportDrop</a></li>
<li><a href="leveldb.html#sec-1-10-7-3-6">1.10.7.3.6 ReportCorruption</a></li>
<li><a href="leveldb.html#sec-1-10-7-3-7">1.10.7.3.7 LastRecordOffset</a></li>
</ul></li>
</ul>
</li>
<li><a href="leveldb.html#sec-1-10-8">1.10.8 Table</a>
<ul>
<li><a href="leveldb.html#sec-1-10-8-1">1.10.8.1 TableFormat</a></li>
<li><a href="leveldb.html#sec-1-10-8-2">1.10.8.2 BuildTable</a></li>
<li><a href="leveldb.html#sec-1-10-8-3">1.10.8.3 TableCache</a>
<ul>
<li><a href="leveldb.html#sec-1-10-8-3-1">1.10.8.3.1 TableCache</a></li>
<li><a href="leveldb.html#sec-1-10-8-3-2">1.10.8.3.2 Evict</a></li>
<li><a href="leveldb.html#sec-1-10-8-3-3">1.10.8.3.3 NewIterator</a></li>
</ul>
</li>
<li><a href="leveldb.html#sec-1-10-8-4">1.10.8.4 Table</a>
<ul>
<li><a href="leveldb.html#sec-1-10-8-4-1">1.10.8.4.1 Rep</a></li>
<li><a href="leveldb.html#sec-1-10-8-4-2">1.10.8.4.2 Open</a></li>
<li><a href="leveldb.html#sec-1-10-8-4-3">1.10.8.4.3 ApproximateOffsetOf</a></li>
<li><a href="leveldb.html#sec-1-10-8-4-4">1.10.8.4.4 NewIterator</a></li>
<li><a href="leveldb.html#sec-1-10-8-4-5">1.10.8.4.5 DeleteBlock</a></li>
<li><a href="leveldb.html#sec-1-10-8-4-6">1.10.8.4.6 DeleteCachedBlock</a></li>
<li><a href="leveldb.html#sec-1-10-8-4-7">1.10.8.4.7 ReleaseBlock</a></li>
<li><a href="leveldb.html#sec-1-10-8-4-8">1.10.8.4.8 BlockReader</a></li>
</ul>
</li>
<li><a href="leveldb.html#sec-1-10-8-5">1.10.8.5 TableBuilder</a>
<ul>
<li><a href="leveldb.html#sec-1-10-8-5-1">1.10.8.5.1 Rep</a></li>
<li><a href="leveldb.html#sec-1-10-8-5-2">1.10.8.5.2 ChangeOptions</a></li>
<li><a href="leveldb.html#sec-1-10-8-5-3">1.10.8.5.3 Add</a></li>
<li><a href="leveldb.html#sec-1-10-8-5-4">1.10.8.5.4 Flush</a></li>
<li><a href="leveldb.html#sec-1-10-8-5-5">1.10.8.5.5 WriteBlock</a></li>
<li><a href="leveldb.html#sec-1-10-8-5-6">1.10.8.5.6 Finish</a></li>
<li><a href="leveldb.html#sec-1-10-8-5-7">1.10.8.5.7 Abandon</a></li>
</ul>
</li>
<li><a href="leveldb.html#sec-1-10-8-6">1.10.8.6 BlockBuilder</a>
<ul>
<li><a href="leveldb.html#sec-1-10-8-6-1">1.10.8.6.1 PrefixCompressed</a></li>
<li><a href="leveldb.html#sec-1-10-8-6-2">1.10.8.6.2 BlockBuilder</a></li>
<li><a href="leveldb.html#sec-1-10-8-6-3">1.10.8.6.3 Reset</a></li>
<li><a href="leveldb.html#sec-1-10-8-6-4">1.10.8.6.4 CurrentSizeEstimate</a></li>
<li><a href="leveldb.html#sec-1-10-8-6-5">1.10.8.6.5 Finish</a></li>
<li><a href="leveldb.html#sec-1-10-8-6-6">1.10.8.6.6 Add</a></li>
</ul>
</li>
<li><a href="leveldb.html#sec-1-10-8-7">1.10.8.7 Block</a>
<ul>
<li><a href="leveldb.html#sec-1-10-8-7-1">1.10.8.7.1 NumRestarts</a></li>
<li><a href="leveldb.html#sec-1-10-8-7-2">1.10.8.7.2 Block</a></li>
<li><a href="leveldb.html#sec-1-10-8-7-3">1.10.8.7.3 NewIterator</a></li>
</ul>
</li>
<li><a href="leveldb.html#sec-1-10-8-8">1.10.8.8 BlockIterator</a>
<ul>
<li><a href="leveldb.html#sec-1-10-8-8-1">1.10.8.8.1 BlockIterator</a></li>
<li><a href="leveldb.html#sec-1-10-8-8-2">1.10.8.8.2 NextEntryOffset</a></li>
<li><a href="leveldb.html#sec-1-10-8-8-3">1.10.8.8.3 GetRestartPoint</a></li>
<li><a href="leveldb.html#sec-1-10-8-8-4">1.10.8.8.4 SeekToRestartPoint</a></li>
<li><a href="leveldb.html#sec-1-10-8-8-5">1.10.8.8.5 Next</a></li>
<li><a href="leveldb.html#sec-1-10-8-8-6">1.10.8.8.6 SeekToFirst</a></li>
<li><a href="leveldb.html#sec-1-10-8-8-7">1.10.8.8.7 SeekToLast</a></li>
<li><a href="leveldb.html#sec-1-10-8-8-8">1.10.8.8.8 ParseNextKey</a></li>
<li><a href="leveldb.html#sec-1-10-8-8-9">1.10.8.8.9 DecodeEntry</a></li>
<li><a href="leveldb.html#sec-1-10-8-8-10">1.10.8.8.10 Prev</a></li>
<li><a href="leveldb.html#sec-1-10-8-8-11">1.10.8.8.11 Seek</a></li>
</ul>
</li>
<li><a href="leveldb.html#sec-1-10-8-9">1.10.8.9 BlockHandle</a>
<ul>
<li><a href="leveldb.html#sec-1-10-8-9-1">1.10.8.9.1 EncodeTo</a></li>
<li><a href="leveldb.html#sec-1-10-8-9-2">1.10.8.9.2 DecodeFrom</a></li>
</ul>
</li>
<li><a href="leveldb.html#sec-1-10-8-10">1.10.8.10 Footer</a>
<ul>
<li><a href="leveldb.html#sec-1-10-8-10-1">1.10.8.10.1 EncodeTo</a></li>
<li><a href="leveldb.html#sec-1-10-8-10-2">1.10.8.10.2 DecodeFrom</a></li>
</ul>
</li>
<li><a href="leveldb.html#sec-1-10-8-11">1.10.8.11 ReadBlock</a></li>
<li><a href="leveldb.html#sec-1-10-8-12">1.10.8.12 IteratorWrapper</a></li>
<li><a href="leveldb.html#sec-1-10-8-13">1.10.8.13 EmptyIterator</a></li>
<li><a href="leveldb.html#sec-1-10-8-14">1.10.8.14 TwoLevelIterator</a>
<ul>
<li><a href="leveldb.html#sec-1-10-8-14-1">1.10.8.14.1 NewTwoLevelIterator</a></li>
<li><a href="leveldb.html#sec-1-10-8-14-2">1.10.8.14.2 Seek</a></li>
<li><a href="leveldb.html#sec-1-10-8-14-3">1.10.8.14.3 SeekToFirst</a></li>
<li><a href="leveldb.html#sec-1-10-8-14-4">1.10.8.14.4 SeekToLast</a></li>
<li><a href="leveldb.html#sec-1-10-8-14-5">1.10.8.14.5 Next</a></li>
<li><a href="leveldb.html#sec-1-10-8-14-6">1.10.8.14.6 Prev</a></li>
<li><a href="leveldb.html#sec-1-10-8-14-7">1.10.8.14.7 InitDataBlock</a></li>
<li><a href="leveldb.html#sec-1-10-8-14-8">1.10.8.14.8 SetDataIterator</a></li>
<li><a href="leveldb.html#sec-1-10-8-14-9">1.10.8.14.9 SkipEmptyDataBlocksForward</a></li>
<li><a href="leveldb.html#sec-1-10-8-14-10">1.10.8.14.10 SkipEmptyDataBlocksBackward</a></li>
</ul>
</li>
<li><a href="leveldb.html#sec-1-10-8-15">1.10.8.15 MergingIterator</a>
<ul>
<li><a href="leveldb.html#sec-1-10-8-15-1">1.10.8.15.1 NewMergingIterator</a></li>
<li><a href="leveldb.html#sec-1-10-8-15-2">1.10.8.15.2 MergingIterator</a></li>
<li><a href="leveldb.html#sec-1-10-8-15-3">1.10.8.15.3 Key</a></li>
<li><a href="leveldb.html#sec-1-10-8-15-4">1.10.8.15.4 Value</a></li>
<li><a href="leveldb.html#sec-1-10-8-15-5">1.10.8.15.5 Seek</a></li>
<li><a href="leveldb.html#sec-1-10-8-15-6">1.10.8.15.6 SeekToFirst</a></li>
<li><a href="leveldb.html#sec-1-10-8-15-7">1.10.8.15.7 SeekToLast</a></li>
<li><a href="leveldb.html#sec-1-10-8-15-8">1.10.8.15.8 Next</a></li>
<li><a href="leveldb.html#sec-1-10-8-15-9">1.10.8.15.9 Prev</a></li>
<li><a href="leveldb.html#sec-1-10-8-15-10">1.10.8.15.10 FindSmallest</a></li>
<li><a href="leveldb.html#sec-1-10-8-15-11">1.10.8.15.11 FindLargest</a></li>
</ul></li>
</ul>
</li>
<li><a href="leveldb.html#sec-1-10-9">1.10.9 Util</a>
<ul>
<li><a href="leveldb.html#sec-1-10-9-1">1.10.9.1 Arena</a></li>
<li><a href="leveldb.html#sec-1-10-9-2">1.10.9.2 Coding</a></li>
<li><a href="leveldb.html#sec-1-10-9-3">1.10.9.3 Histogram</a></li>
<li><a href="leveldb.html#sec-1-10-9-4">1.10.9.4 SkipList</a>
<ul>
<li><a href="leveldb.html#sec-1-10-9-4-1">1.10.9.4.1 RandomHeight</a></li>
<li><a href="leveldb.html#sec-1-10-9-4-2">1.10.9.4.2 KeyIsAfterNode</a></li>
<li><a href="leveldb.html#sec-1-10-9-4-3">1.10.9.4.3 FindGreaterOrEqual</a></li>
<li><a href="leveldb.html#sec-1-10-9-4-4">1.10.9.4.4 Insert</a></li>
<li><a href="leveldb.html#sec-1-10-9-4-5">1.10.9.4.5 Contains</a></li>
<li><a href="leveldb.html#sec-1-10-9-4-6">1.10.9.4.6 FindLessThan</a></li>
<li><a href="leveldb.html#sec-1-10-9-4-7">1.10.9.4.7 FindLast</a></li>
<li><a href="leveldb.html#sec-1-10-9-4-8">1.10.9.4.8 Node</a></li>
<li><a href="leveldb.html#sec-1-10-9-4-9">1.10.9.4.9 NewNode</a></li>
<li><a href="leveldb.html#sec-1-10-9-4-10">1.10.9.4.10 Iterator</a></li>
</ul>
</li>
<li><a href="leveldb.html#sec-1-10-9-5">1.10.9.5 AtomicPointer</a></li>
<li><a href="leveldb.html#sec-1-10-9-6">1.10.9.6 CRC32C</a></li>
<li><a href="leveldb.html#sec-1-10-9-7">1.10.9.7 Hash</a></li>
<li><a href="leveldb.html#sec-1-10-9-8">1.10.9.8 BloomFilterPolicy</a></li>
</ul></li>
</ul>
</li>
<li><a href="leveldb.html#sec-1-11">1.11 Discussion</a>
<ul>
<li><a href="leveldb.html#sec-1-11-1">1.11.1 leveldb通过iterator遍历，对于相同的key如何保证获取到最新的值（hpplinux)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> leveldb</h2>
<div class="outline-text-2" id="text-1">


<p>
<a href="http://code.google.com/p/leveldb/">http://code.google.com/p/leveldb/</a>
</p>

</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> Introduction</h3>
<div class="outline-text-3" id="text-1-1">

<p>相关资源：
</p><ul>
<li>使用文档. <a href="http://leveldb.googlecode.com/svn/trunk/doc/index.html">http://leveldb.googlecode.com/svn/trunk/doc/index.html</a>
</li>
<li>设计说明. <a href="http://leveldb.googlecode.com/svn/trunk/doc/impl.html">http://leveldb.googlecode.com/svn/trunk/doc/impl.html</a>
</li>
<li>leveldb和baidu内部kv系统对比. <a href="http://hi.baidu.com/little_fxxker/blog/item/1915f300f7548a046b60fb08.html">http://hi.baidu.com/little_fxxker/blog/item/1915f300f7548a046b60fb08.html</a>
</li>
<li><a href="http://blog.csdn.net/anderscloud/article/details/7182165">http://blog.csdn.net/anderscloud/article/details/7182165</a>
</li>
</ul>


<p>
leveldb是一个kv存储系统，其中kv都是二进制。用户接口非常简单就是Put(k,v),Get(k),Delete(k).但是还有以下特性
</p><ul>
<li>k有序存储.因为k是二进制没有解释的所以用户需要提供比较函数
</li>
<li>支持遍历包括前向和反向
</li>
<li>支持atomic write
</li>
<li>支持filter policy(bloomfilter)
</li>
<li>数据支持自动压缩(使用snappy压缩算法.关于snappy分析可以看<a href="http://dirlt.com/Snappy.html">这里</a>)
</li>
<li>底层提供了抽象接口，允许用户定制
</li>
</ul>

<p>当然也存在一定的限制
</p><ul>
<li>不是SQL数据库，没有数据关系模型
</li>
<li>一个table只允许一个process访问
</li>
<li>单机系统没有client-server.
</li>
</ul>


<p>
目录层次划分是这样的(意图是我猜想的)
</p><ul>
<li>db // 和db逻辑相关的内容
</li>
<li>helpers // 里面有一个内存db接口
</li>
<li>include // Interface
</li>
<li>port // 操作系统相关的移植接口
</li>
<li>table // 表存储结构
</li>
<li>util // 公用部分.
</li>
</ul>


<p>
leveldb还是比较麻烦的.开始阅读的时候(像我)很多策略细节就可以直接忽略.比如什么时候触发compaction的,以及挑选什么层次进行compaction的输出,
选择那些文件进行compaction等.阅读的时候需要了解每个类到底是用来做什么的.个人觉得里面最迷惑的东西就是Version/VersionEdit/VersionSet是用来做什么的.
所谓Version就是做一个compaction时候产生的一个对象.VersionSet是当前DB里面所有的Version.VersionEdit是针对Version的修改.包括添加和删除哪些文件等.
每次compaction时候会产生version表示这个哪些文件是需要的.在回收文件的时候会查看每一个version持有的文件,这样就可以确定哪些文件是不需要的了.
每次进行compaction都会产生这么一个version对象.将对version进行的操作称为version_edit.同时会将这个version_edit写入manifest文件里面去.
这样在恢复DB的时候，首先可以从manifest里面读取到挂掉之前的version是怎么样的.然后通过读取剩余的version_edit得到挂掉之前的version.
同时会读取log文件将挂掉之前操作的kv恢复.
</p>
<p>
(dirlt):最近看到一篇文章比较leveldb和mysql存储引擎性能(可能是innodb).里面提到了连续插入性能的抖动很大.这可能
和底层为了达到读取高效率不断地进行compaction有关的.关于compaction挑选以及触发这个策略的话以后可以好好研究一下.
</p>
<p>
NOTE(dirlt):compaction策略没有仔细分析，但是这个部分是精髓。如何控制compaction策略来针对应用达到最好的读写平衡。另外对于Recovery部分没有仔细看代码，
但是我觉得这个部分倒不是很大的问题，可能学到的东西不多但是需要非常仔细地阅读才行。
</p>
</div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> WriteBatch</h3>
<div class="outline-text-3" id="text-1-2">

<p>leveldb使用WriteBatch来达到atomic write操作.WriteBatch过程非常简单，就是将atomic write的内容全部写到一个内存buffer上，然后提交这个WriteBatch.
至于具体的分析可以查看"Code Analysis/Batch/WriteBatch"这节的分析。使用WriteBatch一方面可以做到原子操作，另外一方面可以提高吞吐。
</p>
</div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> BloomFilter</h3>
<div class="outline-text-3" id="text-1-3">

<p>相关资源：
</p><ul>
<li>Bloom Filter. <a href="http://en.wikipedia.org/wiki/Bloom_filter">http://en.wikipedia.org/wiki/Bloom_filter</a>
</li>
<li>LevelDB Bloom Filter实现. <a href="http://duanple.blog.163.com/blog/static/7097176720123227403134/">http://duanple.blog.163.com/blog/static/7097176720123227403134/</a>
</li>
</ul>


<p>
bloom filter原理非常简单，似乎没有必要详细分析。关于代码部分的话可以看Code Analysis/Util/BloomFilter.
至于filter在磁盘上面是如何存储的可以参看下面一节Storage/DiskTable分析。NOTE(dirlt):还是移动到这里吧.
</p>
<p>
meta block存放了bloom filter信息，这样可以减少磁盘读取。关于Table内部支持bloom filter在table/filter_block.h有实现。
分别是FilterBlockBuilder和FilterBlockReader.
</p>

</div>

<div id="outline-container-1-3-1" class="outline-4">
<h4 id="sec-1-3-1"><span class="section-number-4">1.3.1</span> Format</h4>
<div class="outline-text-4" id="text-1-3-1">

<p>leveldb是这么分配filter block的.以base(2KB)计算.如果block offset在[base*i,base*(i+1)-1]之间的话，那么就在filter i上面。存储格式是这样的。
</p>


<pre class="example">[filter 0]
[filter 1]
[filter 2]
...
[filter N-1]
[offset of filter 0]                  : 4 bytes
[offset of filter 1]                  : 4 bytes
[offset of filter 2]                  : 4 bytes
...
[offset of filter N-1]                : 4 bytes
[offset of beginning of offset array] : 4 bytes
lg(base)                              : 1 byte
</pre>

<p>
那么这个就是一个filter block的格式。filter block存放在meta block里面。在meta index block内部会记录key,filter block handle.其中key就是这个filter的名字,handle就是这个filter block offset.看看下面代码会更容易理解。
</p>
</div>

</div>

<div id="outline-container-1-3-2" class="outline-4">
<h4 id="sec-1-3-2"><span class="section-number-4">1.3.2</span> FilterBlockBuilder</h4>
<div class="outline-text-4" id="text-1-3-2">

<p>对于Table在初始化之前会调用StartBlock.并且在每次进行Flush Data Block时候也会根据Data Block offset调用。
</p>


<pre class="src src-C++">void FilterBlockBuilder::StartBlock(uint64_t block_offset) {
  uint64_t filter_index = (block_offset / kFilterBase);
  assert(filter_index &gt;= filter_offsets_.size());
  while (filter_index &gt; filter_offsets_.size()) {
    GenerateFilter();
  }
}
</pre>

<p>
可以看到两个data block offset跨越超过base的话那么会产生几个empty filter.但是默认实现的话empty filter不占用太多空间。
</p>
<p>
然后每次Table在AddKey时候也会调用FilterBlock::AddKey
</p>


<pre class="src src-C++">void FilterBlockBuilder::AddKey(const Slice&amp; key) {
  Slice k = key;
  start_.push_back(keys_.size());
  keys_.append(k.data(), k.size());
}
</pre>

<p>
注意这里keys_是一个string.start_记录每个新增key的偏移。AddKey是将这段时间内添加的Key全部缓存下来。
</p>
<p>
然后每次Flush的时候都会产生filter.
</p>


<pre class="src src-C++">void FilterBlockBuilder::GenerateFilter() {
  const size_t num_keys = start_.size();
  if (num_keys == 0) {
    // Fast path if there are no keys for this filter
    filter_offsets_.push_back(result_.size());
    return;
  }

  // Make list of keys from flattened key structure
  start_.push_back(keys_.size());  // Simplify length computation
  tmp_keys_.resize(num_keys);
  for (size_t i = 0; i &lt; num_keys; i++) {
    const char* base = keys_.data() + start_[i];
    size_t length = start_[i+1] - start_[i];
    tmp_keys_[i] = Slice(base, length);
  }

  // Generate filter for current set of keys and append to result_.
  filter_offsets_.push_back(result_.size()); // &#35760;&#24405;&#27599;&#20010;filter&#30340;&#20559;&#31227;.
  policy_-&gt;CreateFilter(&amp;tmp_keys_[0], num_keys, &amp;result_);

  tmp_keys_.clear();
  keys_.clear();
  start_.clear();
}
</pre>


<p>
最后filter block需要刷新出去调用Flush方法。
</p>


<pre class="src src-C++">Slice FilterBlockBuilder::Finish() {
  if (!start_.empty()) {
    GenerateFilter();
  }

  // Append array of per-filter offsets
  const uint32_t array_offset = result_.size();
  for (size_t i = 0; i &lt; filter_offsets_.size(); i++) {
    PutFixed32(&amp;result_, filter_offsets_[i]); // &#36825;&#37324;&#20351;&#29992;Fixed32&#34920;&#31034;&#20063;&#38750;&#24120;&#22909;&#29702;&#35299;
    // &#36825;&#26679;&#25165;&#33021;&#24555;&#36895;&#22320;&#26144;&#23556;&#21040;&#23545;&#24212;&#30340;filter&#19978;&#38754;&#12290;
  }

  PutFixed32(&amp;result_, array_offset); // &#36825;&#20010;array offset&#34920;&#31034;filter offset&#30340;&#36215;&#22987;&#22320;&#22336;
  result_.push_back(kFilterBaseLg);  // Save encoding parameter in result
  return Slice(result_); // &#36825;&#20010;slice&#23601;&#26159;&#26368;&#32456;&#38656;&#35201;write&#30340;&#25968;&#25454;.
}
</pre>


</div>

</div>

<div id="outline-container-1-3-3" class="outline-4">
<h4 id="sec-1-3-3"><span class="section-number-4">1.3.3</span> FilterBlockReader</h4>
<div class="outline-text-4" id="text-1-3-3">

<p>了解上面的filter block的存储格式之后Reader就非常简单。构造函数首先计算出各个参数。simple huh?
</p>


<pre class="src src-C++">FilterBlockReader::FilterBlockReader(const FilterPolicy* policy,
                                     const Slice&amp; contents)
    : policy_(policy),
      data_(NULL),
      offset_(NULL),
      num_(0),
      base_lg_(0) {
  size_t n = contents.size();
  if (n &lt; 5) return;  // 1 byte for base_lg_ and 4 for start of offset array
  base_lg_ = contents[n-1];
  uint32_t last_word = DecodeFixed32(contents.data() + n - 5);
  if (last_word &gt; n - 5) return;
  data_ = contents.data();
  offset_ = data_ + last_word;
  num_ = (n - 5 - last_word) / 4;
}
</pre>


<p>
阅读完成后面的Storage一节之后就会发现query key的话首先是在data index block找到这个key所在的data block offset的。
所以这里filter就是判断某个offset的data block是否含所有key.
</p>


<pre class="src src-C++">bool FilterBlockReader::KeyMayMatch(uint64_t block_offset, const Slice&amp; key) {
  uint64_t index = block_offset &gt;&gt; base_lg_;
  if (index &lt; num_) {
    uint32_t start = DecodeFixed32(offset_ + index*4); // filter&#36215;&#22987;&#22320;&#22336;
    uint32_t limit = DecodeFixed32(offset_ + index*4 + 4); // filter&#32456;&#27490;&#22320;&#22336;
    if (start &lt;= limit &amp;&amp; limit &lt;= (offset_ - data_)) {
      Slice filter = Slice(data_ + start, limit - start);
      return policy_-&gt;KeyMayMatch(key, filter); // filter&#21028;&#26029;&#26159;&#21542;&#23384;&#22312;key.
    } else if (start == limit) {
      // Empty filters do not match any keys
      return false;
    }
  }
  return true;  // Errors are treated as potential matches
}
</pre>


</div>
</div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> Storage</h3>
<div class="outline-text-3" id="text-1-4">

<p>相关资源：
</p><ul>
<li>Table Format. <a href="http://leveldb.googlecode.com/svn/trunk/doc/table_format.txt">http://leveldb.googlecode.com/svn/trunk/doc/table_format.txt</a> sst table存储格式。
</li>
<li>Log Format. <a href="http://leveldb.googlecode.com/svn/trunk/doc/log_format.txt">http://leveldb.googlecode.com/svn/trunk/doc/log_format.txt</a> block存储格式。
</li>
<li>LevelDB SSTable格式详解. <a href="http://vdisk.weibo.com/s/40kWC">http://vdisk.weibo.com/s/40kWC</a>
</li>
</ul>



</div>

<div id="outline-container-1-4-1" class="outline-4">
<h4 id="sec-1-4-1"><span class="section-number-4">1.4.1</span> MemTable</h4>
<div class="outline-text-4" id="text-1-4-1">

<p>memtable在leveldb内部实现就是一个skiplist.所有的update都不是in-place的，对于memtable里面的修改来说的话使用的也是使用添加的方式完成的。
对于每个操作都会分配一个sequence number.所以底层也没有办法直接覆盖。对于sequence number很明显就是需要实现snapshot.底层的话leveldb
持有两个memtable,一个memtable用于接收当前的操作是mutable的，一个memtable是immutable专门用于dump to disk的，内部实现类似于双buffer机制。
</p>
</div>

</div>

<div id="outline-container-1-4-2" class="outline-4">
<h4 id="sec-1-4-2"><span class="section-number-4">1.4.2</span> RedoLog</h4>
<div class="outline-text-4" id="text-1-4-2">

<p>我们首先阅读Log Format文档看看log存储格式(leveldb采用redo-log来记日志)。每个block都划分成为32KB，里面可能会存在很多条记录，
对于跨块的记录来说的里面存在type字段用来标记这个块是否已经结束。另外值得注意的就是每个记录之前带上了32bit的checksum.对于每条记录多4字节还是很大开销的，
但是其实这也反应了leveldb的定位，就是针对fault-tolerant的分布式系统设计。这些分布式系统架在commodity PC上面，磁盘可能很容易出现问题。
在文档最后作者也给给出了这种block存储方式(recordio)的利弊。
</p>


<pre class="example">Some benefits over the recordio format:

(1) We do not need any heuristics for resyncing - just go to next
block boundary and scan.  If there is a corruption, skip to the next
block.  As a side-benefit, we do not get confused when part of the
contents of one log file are embedded as a record inside another log
file.

(2) Splitting at approximate boundaries (e.g., for mapreduce) is
simple: find the next block boundary and skip records until we
hit a FULL or FIRST record.

(3) We do not need extra buffering for large records.

Some downsides compared to recordio format:

(1) No packing of tiny records.  This could be fixed by adding a new
record type, so it is a shortcoming of the current implementation,
not necessarily the format.

(2) No compression.  Again, this could be fixed by adding new record types.
</pre>

<p>
pros有：
</p><ul>
<li>如果磁盘数据发生损坏的话，那么对于数据定位的话非常简单。如果这个block出现问题的话那么直接跳过这个block即可。
</li>
<li>程序处理方面可以很容易地找到边界。NOTE(dirlt):这个也是相对的
</li>
<li>对于单条大数据处理的话我们不需要分配很大的内存来做buffer.
</li>
</ul>

<p>cons有：
</p><ul>
<li>没有针对小record进行优化，比如如果record足够小的话完全可以在length部分使用1个字节。
</li>
<li>没有进行压缩。对于压缩率完全取决于实现。对于小数据来说的话压缩比可能不高，对于大数据来说比如超过32KB的话，
</li>
</ul>

<p>取决于是按照32KB单个block压缩呢(压缩率可能不高),还是先针对整体压缩(压缩率可能比较耗，但是却需要很大的buffer).
</p>
</div>

</div>

<div id="outline-container-1-4-3" class="outline-4">
<h4 id="sec-1-4-3"><span class="section-number-4">1.4.3</span> DiskTable</h4>
<div class="outline-text-4" id="text-1-4-3">

<p>然后可以看看Table Format文档关于table存储格式。table存储格式里面主要包括几个部分：
</p><ul>
<li>data block
</li>
<li>meta block
</li>
<li>meta index block
</li>
<li>data index block
</li>
<li>footer
</li>
</ul>

<p>footer部分是放在最末尾的，里面包含了data index block以及meta index block的偏移信息，读取table时候从末尾读取。
</p>
<p>
首先我们看看data block是如何组织的。对于DiskTable(TableBuilder)就是不断地Add(Key,Value).当缓存的数据达到一定大小之后，
就会调用Flush这样就形成了一个Block.对于一个Block内部而言的话，有个很重要的概念就是restart point.所谓restart point就是为了解决
前缀压缩的问题的，所谓的restart point就是基准key。假设我们顺序加入abcd,abce,abcf.我们以abcd为restart point的话，那么abce可以存储为
(3,e),abcf存储为(3,f).对于restart point采用全量存储，而对于之后的部分采用增量存储。一个restart block可能存在多个restart point,
将这些restart point在整个table offset记录下来，然后放在data block最后面。每个data block尾部还有一个type和CRC32.其中type可以选择是否
需要针对这个data block进行snappy压缩，而CRC32是针对这个data block的校验。
</p>
<p>
data index block组织形式和data block非常类似，只不过有两个不同。1)data index block从不刷新直到Table构造完成之后才会刷新，所以
对于一个table而言的话只有一个data index block.2)data index block添加的key/value是在data block形成的时候添加的，添加key非常取巧
，是上一个data block和这个data block的一个key seperator.比如上一个data block的max key是abcd,而这个data block的min key是ad.那么这个
seperator可以设置成为ac.seperator的生成可以参考Comparator.使用尽量短的seperator可以减小磁盘开销并且提高效率。而对于添加的value就是
这个data block的offset.同样在data index block也会存在restart point.
</p>
<p>
然后看看进行一个key的query是如何进行的。首先读取出data index block(这个部分可以常驻内存)，得到里面的restart point部分。针对restart point
进行二分。因为restart point指向的key都是全量的key.如果确定在某两个restart point之间之后，就可以遍历这个restart point之间范围分析seperator.
得到想要查找的seperator之后对应的value就是某个data block offset.读取这个data block和之前的方法一样就可以查找key了。对于遍历来说，过程是一样的。
</p>
<p>
这里我们稍微分析一下这样的工作方式的优缺点。对于写或者是merge来说的话，效率相当的高，所有写都是顺序写并且还可以进行压缩。影响写效率的话一个重要参数就是flush block的参数。
但是对于读来说的话，个人觉得过程有点麻烦，但是可以实现得高效率。对于flush block调节会影响到data index block和data block占用内存大小。如果flush block过大的话，
那么会造成data index block耗费内存小，但是每次读取出一个data block内存很大。如果flush block过小的话，那么data index block耗费内存很大，但是每次读取data block内存很小。
而restart point数量会影响过多的话，那么可能会占用稍微大一些的内存空间，但是会使得查找过程更快(遍历数更少).
</p>
</div>
</div>

</div>

<div id="outline-container-1-5" class="outline-3">
<h3 id="sec-1-5"><span class="section-number-3">1.5</span> Compaction</h3>
<div class="outline-text-3" id="text-1-5">

<p>对于Compaction触发的策略牵扯到了算法问题，自己表示没有仔细看这个策略(其实当时看了但是完全没有理解).这里谈谈compaction如何删除文件的问题。
在leveldb里面每次做一个compaction都会产生一个version对象添加到versionset里面，version里面包含了这个version管理了哪些文件。
每次进行读取都会从某个version读取，然后针对这个version做一个引用计数。然后每次需要删除一些不必要的文件时候就会遍历versionset了解哪些文件
还需要，然后对比文件系统目录下面的文件就知道哪些文件不再需要，即可删除。
</p>
<p>
NOTE(dirlt):这里稍微总结一下 <a href="http://leveldb.googlecode.com/svn/trunk/doc/impl.html">http://leveldb.googlecode.com/svn/trunk/doc/impl.html</a> 提到的compaction策略。可能阅读完了这些策略之后反过头来看看
代码可能会更好，只是记得当时阅读compaction策略太痛苦了所以直接忽略了。
</p>
<p>
每个level都有一定的大小限制，并且每个level里面的文件的key都是不会overlap的(L0除外).触发条件很多，文档上描述是某个level超过一定限制。
但是之前阅读代码发现其实并不是这样的，可以参看函数VersionSet::PickCompaction.可以看到有两个触发条件size_compaction和seek_compaction.
所谓的size_compaction就是说某个level超过一定大小，而seek_compaction指某个文件被seek次数超过一定次数之后会触发(关于这个值的更新可以查看VersionSet::Builder::Apply,
在一个文件初始创建的时候就已经设置好了allowed_seeks次数).
</p>
<p>
前面是触发条件，后面来说说compaction策略.文档上描述非常简单但是事实不是这样。如果需要compact某个level的话，如果level&gt;0的话那么对于这个level
只会选出一个file来和level+1中存在overlap的文件进行合并然后生成一个新的文件。如果level==0的话那么对于这个level可能选择多个文件出来和level+1中overlap
文件合并。对于选取level中文件来说的话是采用rotate keyspace的方式来挑选的。在生成新文件的时候，通常会有两个情况拆分出一个新文件。1)
文件过大 2)文件和level+2中超过10个存在overlap. 2)情况非常好理解，因为如果产生一个大文件和level+2 overlap文件数量过多的话，那么进行level+1的compaction
时间就会非常长并且随机读非常严重。
</p>
<p>
<a href="http://leveldb.googlecode.com/svn/trunk/doc/impl.html">http://leveldb.googlecode.com/svn/trunk/doc/impl.html</a> 文档Timing这节个人感觉非常有价值。作者估算了一下compaction对于整个系统带宽带来的影响。
按照2MB一个sst文件在level(&gt;0)上面的compaction来计算的话，一次compaction需要read 26MB和write 26MB~=50MB.假设磁盘带宽100MB/s我们通过后台线程限制速度的话，
那么做compaction需要耗费5s时间。假设用户写速度也在10MS/s的话，那么会生成50MB数据相当于25个sst level0文件。这样对读来说会造成很大影响。
作者给出的建议包括：
</p>


<pre class="example">Solution 1: To reduce this problem, we might want to increase the log switching threshold when the number of level-0 files is large.
Though the downside is that the larger this threshold, the more memory we will need to hold the corresponding memtable.

Solution 2: We might want to decrease write rate artificially when the number of level-0 files goes up.

Solution 3: We work on reducing the cost of very wide merges. Perhaps most of the level-0 files will have their blocks sitting uncompressed
in the cache and we will only need to worry about the O(N) complexity in the merging iterator.
</pre>

<p>
其中第二点感觉非常好就是认为控制写入速度当level0文件过多的时候。在db_impl.cc DBImpl::MakeRoomForWrite这个应该是在memtable缺少空间的时候的函数.
</p>


<pre class="src src-C++">  allow_delay &amp;&amp;
  versions_-&gt;NumLevelFiles(0) &gt;= config::kL0_SlowdownWritesTrigger) {
// We are getting close to hitting a hard limit on the number of
// L0 files.  Rather than delaying a single write by several
// seconds when we hit the hard limit, start delaying each
// individual write by 1ms to reduce latency variance.  Also,
// this delay hands over some CPU to the compaction thread in
// case it is sharing the same core as the writer.
mutex_.Unlock();
env_-&gt;SleepForMicroseconds(1000);
allow_delay = false;  // Do not delay a single write more than once
mutex_.Lock();
</pre>


</div>

</div>

<div id="outline-container-1-6" class="outline-3">
<h3 id="sec-1-6"><span class="section-number-3">1.6</span> Recovery</h3>
<div class="outline-text-3" id="text-1-6">

<p>TODO(dirlt):too much details but basically rely on redo log.复杂原因主要是因为需要考虑snapshot和compaction.
I think read through <a href="http://leveldb.googlecode.com/svn/trunk/doc/impl.html">http://leveldb.googlecode.com/svn/trunk/doc/impl.html</a> will help.
</p>
<p>
NOTE(dirlt):这里稍微总结一下 <a href="http://leveldb.googlecode.com/svn/trunk/doc/impl.html">http://leveldb.googlecode.com/svn/trunk/doc/impl.html</a> 提到的关于recovery的部分。幸运的是在阅读这个文档的时候
也让我重新仔细地思考了一下这个recovery过程可能会如何进行的。
</p>
<p>
我们主要关注三个数据的恢复：
</p><ul>
<li>用户的data(log)
</li>
<li>leveldb所管理的文件(MANIFEST)
</li>
<li>内部生成的sequence number(MANIFEST)
</li>
</ul>


<p>
对于用户的data而言可以通过记录log来完成。注意这个log里面都是db的insert/delete等操作。值得注意的是，每次生成新的memtable也会生成新的log文件。
这点是非常必要的，因为这样才可以将需要恢复哪些log对应起来。并且log里面每条日志都带上了sequence number,所以log里面的sequence number也有助于
sequence number恢复。
</p>
<p>
记录leveldb所管理的文件非常简单。我们观察管理文件变化只会发生在compaction的时候，在当前version下面删除一部分文件生成一部分文件。我们将
这些变化称为VersionEdit.每次compaction完成之后的话我们将这个version edit记录在MANIFEST内部，同时生成一个Version。version edit是增量,version是全量。
(至于如何记录这个没有仔细看.但是看代码里面似乎有全量也有增量的记录).如果创建一个新的MANIFEST文件的话，会将MANIFEST文件名称记录在CURRENT内部。
这样启动之后就知道读取哪个MANIFEST文件了。当然记录在MANIFEST内部的不仅仅是文件的变化，还有生成这个Version时候对应的log以及sequence number.
</p>
<p>
这样我们的recovery过程就非常简单了。读取CURRENT文件知道读取哪个MANIFEST文件。从MANIFEST文件里面构造Version并且回放VersionEdit.
根据当前的状态知道需要读取哪些log.然后回放log更新sequence number等状态。
</p>
</div>

</div>

<div id="outline-container-1-7" class="outline-3">
<h3 id="sec-1-7"><span class="section-number-3">1.7</span> Snapshot</h3>
<div class="outline-text-3" id="text-1-7">

<p>Snapshot集合在leveldb里面组织成为一个链表，oldest的节点必然最小的snapshot。对于每一个snapshot配备一个sequence number,
所以很明显oldest的节点的sequence number应该是最小的。每次进行compaction的时候会判断当前最小的sequence number
是多少然后将一些不必要的节点删除。另外在查询key的时候也会结合这个snapshot sequence number结合成为一个复合key进行查询。
</p>
</div>

</div>

<div id="outline-container-1-8" class="outline-3">
<h3 id="sec-1-8"><span class="section-number-3">1.8</span> Cache</h3>
<div class="outline-text-3" id="text-1-8">

<p>对于leveldb来说的话存在两个cache系统，一个是TableCache，一个是BlockCache.其中TableCache是用来缓存文件描述符的，
而BlockCache是用来做data block的缓存的(Table::BlockeReader).对于leveldb只有一个cache实现在Code Analysis/Cache里面做了详细分析。
</p>
<p>
我们这里最感兴趣的东西，应该就是每个cache的kv分别是什么。对于TableCahce的k是file_number,v是Table的Iterator
(Table::NewIterator).对于leveldb来说的话文件的file_number都是自增的所以使用file_number没有任何问题。对于BlockCache
来说的话k是(cache_id,offset),v是Block的内存。TODO(dirlt):(对于这个cache_id现在还不是非常理解，但是个人觉得
这个cache_id可以==file_number.使用cache_id就是每次Open的时候这个cache_id都会改变)
</p>
<p>
和BlockCache是针对disk block来进行cache的，另外一种cache方案就是Record Cache.相对Block Cache,Record Cache无疑更能够
提高使用效率包括内存大小以及Cache命中率。但是大家拒绝在内部使用RecordCache的原因非常简答，就是这个在应用层完成似乎更好，
应用层可以更好地进行Cache。在应用层完成同时会引入一个问题就是Cache一致性，但是其实维持这个一致性并不是一件很复杂的事情，
Cache主要用来解决读取问题，做写穿透并且让Cache失效即可。leveldb维护BlockCache一致性并不麻烦，因为leveldb的update并不是in-place的。
</p>
<p>
NOTE(dirlt):不过后来仔细想了一下觉得Record Cache还是在应用层做比较好，可以控制缓存策略比如大小失效时间。对于底层库还是在
做BlockCache会比较好一些.
</p>
</div>

</div>

<div id="outline-container-1-9" class="outline-3">
<h3 id="sec-1-9"><span class="section-number-3">1.9</span> Option</h3>
<div class="outline-text-3" id="text-1-9">

<p>在options.h里面有一些leveldb可选的选项。
</p><ul>
<li>comparator.用户可以指定比较器
</li>
<li>create_if_missing.如果数据库不存在就创建
</li>
<li>error_if_exists.如果数据库存在就报错
</li>
<li>paranoid_checks.尽可能多地进行错误检查
</li>
<li>env.用户可以模拟db环境
</li>
<li>info_log.leveldb本身logger.
</li>
<li>write_buffer_size.memtable大小
</li>
<li>max_open_files.最大打开fd数量
</li>
<li>block_cache.Table读取data block的cache.
</li>
<li>block_size.Table里面Block大小
</li>
<li>block_restart_interval.在一个Block里面每隔多少个key创建一个restart point.
</li>
<li>compression.DataBlock是否需要压缩
</li>
<li>filter_policy.过滤策略默认就是bloom filter.
</li>
<li>verify_checksums.读取block时候是否校验checksum
</li>
<li>fill_cache.读取block是否会Cache.通常scan时候不要做cache
</li>
<li>sync.leveldb内部发起write的话是否会调用fsync.
</li>
</ul>


</div>

</div>

<div id="outline-container-1-10" class="outline-3">
<h3 id="sec-1-10"><span class="section-number-3">1.10</span> Code Analysis</h3>
<div class="outline-text-3" id="text-1-10">


</div>

<div id="outline-container-1-10-1" class="outline-4">
<h4 id="sec-1-10-1"><span class="section-number-4">1.10.1</span> Interface</h4>
<div class="outline-text-4" id="text-1-10-1">

<p>我们首先看看leveldb给我们暴露的头文件有哪些.稍微简单地看看接口提供了哪些功能.头文件目录是include/leveldb
</p><ul>
<li>cache.h // kv内存cache接口
</li>
<li>c.h // leveldb C接口
</li>
<li>comparator.h // Slice的比较接口
</li>
<li>db.h // db对象接口
</li>
<li>env.h // 和环境相关的接口
</li>
<li>filter_policy.h // 过滤策略相关的接口
</li>
<li>iterator.h // 遍历接口
</li>
<li>options.h // db操作的选项对象
</li>
<li>slice.h // db操作的key对象(Slice)
</li>
<li>status.h // db操作返回状态的对象
</li>
<li>table_builder.h // 构建table
</li>
<li>table.h // immutable persistent sortedtable.
</li>
<li>write_batch.h // 批量(原子)写入对象
</li>
</ul>

<p>leveldb里面对象的实现方式，很多都是采用抽象类然后提供工厂模式来创建的，这样的话允许用户更换具体实现。
</p>

</div>

<div id="outline-container-1-10-1-1" class="outline-5">
<h5 id="sec-1-10-1-1"><span class="section-number-5">1.10.1.1</span> cache.h</h5>
<div class="outline-text-5" id="text-1-10-1-1">

<p>Cache主要是用来作为kv查询cache部分.Cache接口非常简单，其中Handle是了为了管理cache item.注释写得非常好
</p>


<pre class="src src-C++">class Cache {
 public:
  Cache() { }

  // Destroys all existing entries by calling the <span style="color: #ffff00;">"deleter"</span>
  // function that was passed to the constructor.
  virtual ~Cache();

  // Opaque handle to an entry stored in the cache.
  struct Handle { };

  // Insert a mapping from key-&gt;value into the cache and assign it
  // the specified charge against the total cache capacity.
  //
  // Returns a handle that corresponds to the mapping.  The caller
  // must call this-&gt;Release(handle) when the returned mapping is no
  // longer needed.
  //
  // When the inserted entry is no longer needed, the key and
  // value will be passed to <span style="color: #ffff00;">"deleter"</span>.
  virtual Handle* Insert(const Slice&amp; key, void* value, size_t charge,
                         void (*deleter)(const Slice&amp; key, void* value)) = 0;

  // If the cache has no mapping for <span style="color: #ffff00;">"key"</span>, returns NULL.
  //
  // Else return a handle that corresponds to the mapping.  The caller
  // must call this-&gt;Release(handle) when the returned mapping is no
  // longer needed.
  virtual Handle* Lookup(const Slice&amp; key) = 0;

  // Release a mapping returned by a previous Lookup().
  // REQUIRES: handle must not have been released yet.
  // REQUIRES: handle must have been returned by a method on *this.
  virtual void Release(Handle* handle) = 0;

  // Return the value encapsulated in a handle returned by a
  // successful Lookup().
  // REQUIRES: handle must not have been released yet.
  // REQUIRES: handle must have been returned by a method on *this.
  virtual void* Value(Handle* handle) = 0;

  // If the cache contains entry for key, erase it.  Note that the
  // underlying entry will be kept around until all existing handles
  // to it have been released.
  virtual void Erase(const Slice&amp; key) = 0;

  // Return a new numeric id.  May be used by multiple clients who are
  // sharing the same cache to partition the key space.  Typically the
  // client will allocate a new id at startup and prepend the id to
  // its cache keys.
  virtual uint64_t NewId() = 0;

 private:
  void LRU_Remove(Handle* e);
  void LRU_Append(Handle* e);
  void Unref(Handle* e); // &#21487;&#20197;&#30475;&#21040;Handle&#21487;&#33021;&#23454;&#38469;&#19978;&#24213;&#23618;&#26377;&#24341;&#29992;&#35745;&#25968;&#23384;&#22312;.

  struct Rep;
  Rep* rep_; // opaque&#23454;&#29616;&#25351;&#38024;&#30340;&#23384;&#22312;.
};
</pre>

<p>
一般底层Handle有引用计数，然后调用Release的话会atomic dec.如果==0的话那么会调用Insert时候的deleter接口进行释放。
这里稍微总结一下Cache提供的接口
</p><ul>
<li>Insert // 插入kv返回Handle
</li>
<li>Lookup // 查询k返回Handle
</li>
<li>Value // 传入handle得到对应的value
</li>
<li>Erase // 删除kv
</li>
<li>NewId // 产生一个新id.
</li>
</ul>


<p>
实现是ShardedLRUCache.这个后面会具体分析.
</p>


<pre class="src src-C++">extern Cache* NewLRUCache(size_t capacity);
Cache* NewLRUCache(size_t capacity) {
  return new ShardedLRUCache(capacity);
}
</pre>


</div>

</div>

<div id="outline-container-1-10-1-2" class="outline-5">
<h5 id="sec-1-10-1-2"><span class="section-number-5">1.10.1.2</span> comparator.h</h5>
<div class="outline-text-5" id="text-1-10-1-2">

<p>comparator提供了slice对象的比较方法接口.但是还有两个接口值得提一下
</p>


<pre class="src src-C++">// Advanced functions: these are used to reduce the space requirements
// for internal data structures like index blocks.

// If *start &lt; limit, changes *start to a short string in [start,limit).
// Simple comparator implementations may return with *start unchanged,
// i.e., an implementation of this method that does nothing is correct.
virtual void FindShortestSeparator(
    std::string* start,
    const Slice&amp; limit) const = 0;

// Changes *key to a short string &gt;= *key.
// Simple comparator implementations may return with *key unchanged,
// i.e., an implementation of this method that does nothing is correct.
virtual void FindShortSuccessor(std::string* key) const = 0;
</pre>

<p>
关于这两个接口注释都解释得十分清楚了。
</p>
<p>
实现是ByteWiseComparatorImpl.
</p>


<pre class="src src-C++">// Intentionally not destroyed to prevent destructor racing
// with background threads.
static const Comparator* bytewise = new BytewiseComparatorImpl;

const Comparator* BytewiseComparator() {
  return bytewise;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-1-3" class="outline-5">
<h5 id="sec-1-10-1-3"><span class="section-number-5">1.10.1.3</span> db.h</h5>
<div class="outline-text-5" id="text-1-10-1-3">

<p>db.h下面有几个对象
</p><ul>
<li>Snapshot(接口)
</li>
<li>Range
</li>
<li>DB(接口)
</li>
</ul>


<p>
Snapshot结构非常简单，只是提供了一些虚析构函数接口。实现是SnapshotImpl.
</p>
<p>
Range的话就是两个Slice表示范围，表示[start,limit)
// A range of keys
struct Range {
  Slice start;          // Included in the range
  Slice limit;          // Not included in the range
</p>
<p>
  Range() { }
  Range(const Slice&amp; s, const Slice&amp; l) : start(s), limit(l) { }
};
</p>
<p>
DB是我们发起操作的对象。然后我们看看最关键的DB提供了哪些接口.注释写得清晰真的没有必要解释了:).
</p>


<pre class="src src-C++">// A DB is a persistent ordered map from keys to values.
// A DB is safe for concurrent access from multiple threads without
// any external synchronization.
class DB {
 public:
  // Open the database with the specified <span style="color: #ffff00;">"name"</span>.
  // Stores a pointer to a heap-allocated database in *dbptr and returns
  // OK on success.
  // Stores NULL in *dbptr and returns a non-OK status on error.
  // Caller should delete *dbptr when it is no longer needed.
  static Status Open(const Options&amp; options,
                     const std::string&amp; name,
                     DB** dbptr);

  DB() { }
  virtual ~DB();

  // Set the database entry for <span style="color: #ffff00;">"key"</span> to <span style="color: #ffff00;">"value"</span>.  Returns OK on success,
  // and a non-OK status on error.
  // Note: consider setting options.sync = true.
  virtual Status Put(const WriteOptions&amp; options,
                     const Slice&amp; key,
                     const Slice&amp; value) = 0;

  // Remove the database entry (if any) for <span style="color: #ffff00;">"key"</span>.  Returns OK on
  // success, and a non-OK status on error.  It is not an error if <span style="color: #ffff00;">"key"</span>
  // did not exist in the database.
  // Note: consider setting options.sync = true.
  virtual Status Delete(const WriteOptions&amp; options, const Slice&amp; key) = 0;

  // Apply the specified updates to the database.
  // Returns OK on success, non-OK on failure.
  // Note: consider setting options.sync = true.
  virtual Status Write(const WriteOptions&amp; options, WriteBatch* updates) = 0;

  // If the database contains an entry for <span style="color: #ffff00;">"key"</span> store the
  // corresponding value in *value and return OK.
  //
  // If there is no entry for <span style="color: #ffff00;">"key"</span> leave *value unchanged and return
  // a status for which Status::IsNotFound() returns true.
  //
  // May return some other Status on an error.
  virtual Status Get(const ReadOptions&amp; options,
                     const Slice&amp; key, std::string* value) = 0;

  // Return a heap-allocated iterator over the contents of the database.
  // The result of NewIterator() is initially invalid (caller must
  // call one of the Seek methods on the iterator before using it).
  //
  // Caller should delete the iterator when it is no longer needed.
  // The returned iterator should be deleted before this db is deleted.
  virtual Iterator* NewIterator(const ReadOptions&amp; options) = 0;

  // Return a handle to the current DB state.  Iterators created with
  // this handle will all observe a stable snapshot of the current DB
  // state.  The caller must call ReleaseSnapshot(result) when the
  // snapshot is no longer needed.
  virtual const Snapshot* GetSnapshot() = 0;

  // Release a previously acquired snapshot.  The caller must not
  // use <span style="color: #ffff00;">"snapshot"</span> after this call.
  virtual void ReleaseSnapshot(const Snapshot* snapshot) = 0;

  // DB implementations can export properties about their state
  // via this method.  If <span style="color: #ffff00;">"property"</span> is a valid property understood by this
  // DB implementation, fills <span style="color: #ffff00;">"*value"</span> with its current value and returns
  // true.  Otherwise returns false.
  //
  //
  // Valid property names include:
  //
  //  <span style="color: #ffff00;">"leveldb.num-files-at-level&lt;N&gt;"</span> - return the number of files at level &lt;N&gt;,
  //     where &lt;N&gt; is an ASCII representation of a level number (e.g. <span style="color: #ffff00;">"0"</span>).
  //  <span style="color: #ffff00;">"leveldb.stats"</span> - returns a multi-line string that describes statistics
  //     about the internal operation of the DB.
  //  <span style="color: #ffff00;">"leveldb.sstables"</span> - returns a multi-line string that describes all
  //     of the sstables that make up the db contents.
  virtual bool GetProperty(const Slice&amp; property, std::string* value) = 0;

  // For each i in [0,n-1], store in <span style="color: #ffff00;">"sizes[i]"</span>, the approximate
  // file system space used by keys in <span style="color: #ffff00;">"[range[i].start .. range[i].limit)"</span>.
  //
  // Note that the returned sizes measure file system space usage, so
  // if the user data compresses by a factor of ten, the returned
  // sizes will be one-tenth the size of the corresponding user data size.
  //
  // The results may not include the sizes of recently written data.
  virtual void GetApproximateSizes(const Range* range, int n,
                                   uint64_t* sizes) = 0;

  // Compact the underlying storage for the key range [*begin,*end].
  // In particular, deleted and overwritten versions are discarded,
  // and the data is rearranged to reduce the cost of operations
  // needed to access the data.  This operation should typically only
  // be invoked by users who understand the underlying implementation.
  //
  // begin==NULL is treated as a key before all keys in the database.
  // end==NULL is treated as a key after all keys in the database.
  // Therefore the following call will compact the entire database:
  //    db-&gt;CompactRange(NULL, NULL);
  virtual void CompactRange(const Slice* begin, const Slice* end) = 0;
};
</pre>

<p>
实现是DBImpl.这里稍微总结一下DB提供的接口
</p><ul>
<li>Open // 创建DB
</li>
<li>Put //
</li>
<li>Delete //
</li>
<li>Write // batch(atomic)写入.
</li>
<li>Get //
</li>
<li>NewInterator // 创建迭代器
</li>
<li>GetSnapshot // 创建snapshot
</li>
<li>ReleaseSnapShot // 销毁snapshot
</li>
<li>GetProperty // 获取属性
</li>
<li>GetApproximateSizes // 根据range这个部分内容占用磁盘大小
</li>
<li>CompactRange // 压缩range这个部分内容
</li>
</ul>


<p>
此外还提供了两个函数用于删除DB以及修复DB.这个会单独讨论.
</p>


<pre class="src src-C++">// Destroy the contents of the specified database.
// Be very careful using this method.
Status DestroyDB(const std::string&amp; name, const Options&amp; options);

// If a DB cannot be opened, you may attempt to call this method to
// resurrect as much of the contents of the database as possible.
// Some data may be lost, so be careful when calling this function
// on a database that contains important information.
Status RepairDB(const std::string&amp; dbname, const Options&amp; options);
</pre>


</div>

</div>

<div id="outline-container-1-10-1-4" class="outline-5">
<h5 id="sec-1-10-1-4"><span class="section-number-5">1.10.1.4</span> env.h</h5>
<div class="outline-text-5" id="text-1-10-1-4">

<p>env.h里面抽象了环境，这样用户可以很方便低进行定制.可以看到leveldb大量的设计依赖于虚函数。
对于这种存储系统用虚函数带来的开销应该是可以接受的。但是对于压缩或者是传输协议的话那么虚函数开销就不可以忽略了。
提供提供了默认环境实现在util/env_posix.cc里面。这个会在后面详细分析。所谓环境包括下面几个对象.
</p>

</div>

<div id="outline-container-1-10-1-4-1" class="outline-6">
<h6 id="sec-1-10-1-4-1"><span class="section-number-6">1.10.1.4.1</span> Env</h6>
<div class="outline-text-6" id="text-1-10-1-4-1">




<pre class="src src-C++">class Env {
 public:
  Env() { }
  virtual ~Env();

  // Return a default environment suitable for the current operating
  // system.  Sophisticated users may wish to provide their own Env
  // implementation instead of relying on this default environment.
  //
  // The result of Default() belongs to leveldb and must never be deleted.
  static Env* Default();

  // Create a brand new sequentially-readable file with the specified name.
  // On success, stores a pointer to the new file in *result and returns OK.
  // On failure stores NULL in *result and returns non-OK.  If the file does
  // not exist, returns a non-OK status.
  //
  // The returned file will only be accessed by one thread at a time.
  virtual Status NewSequentialFile(const std::string&amp; fname,
                                   SequentialFile** result) = 0;

  // Create a brand new random access read-only file with the
  // specified name.  On success, stores a pointer to the new file in
  // *result and returns OK.  On failure stores NULL in *result and
  // returns non-OK.  If the file does not exist, returns a non-OK
  // status.
  //
  // The returned file may be concurrently accessed by multiple threads.
  virtual Status NewRandomAccessFile(const std::string&amp; fname,
                                     RandomAccessFile** result) = 0;

  // Create an object that writes to a new file with the specified
  // name.  Deletes any existing file with the same name and creates a
  // new file.  On success, stores a pointer to the new file in
  // *result and returns OK.  On failure stores NULL in *result and
  // returns non-OK.
  //
  // The returned file will only be accessed by one thread at a time.
  virtual Status NewWritableFile(const std::string&amp; fname,
                                 WritableFile** result) = 0;

  // Returns true iff the named file exists.
  virtual bool FileExists(const std::string&amp; fname) = 0;

  // Store in *result the names of the children of the specified directory.
  // The names are relative to <span style="color: #ffff00;">"dir"</span>.
  // Original contents of *results are dropped.
  virtual Status GetChildren(const std::string&amp; dir,
                             std::vector&lt;std::string&gt;* result) = 0;

  // Delete the named file.
  virtual Status DeleteFile(const std::string&amp; fname) = 0;

  // Create the specified directory.
  virtual Status CreateDir(const std::string&amp; dirname) = 0;

  // Delete the specified directory.
  virtual Status DeleteDir(const std::string&amp; dirname) = 0;

  // Store the size of fname in *file_size.
  virtual Status GetFileSize(const std::string&amp; fname, uint64_t* file_size) = 0;

  // Rename file src to target.
  virtual Status RenameFile(const std::string&amp; src,
                            const std::string&amp; target) = 0;

  // Lock the specified file.  Used to prevent concurrent access to
  // the same db by multiple processes.  On failure, stores NULL in
  // *lock and returns non-OK.
  //
  // On success, stores a pointer to the object that represents the
  // acquired lock in *lock and returns OK.  The caller should call
  // UnlockFile(*lock) to release the lock.  If the process exits,
  // the lock will be automatically released.
  //
  // If somebody else already holds the lock, finishes immediately
  // with a failure.  I.e., this call does not wait for existing locks
  // to go away.
  //
  // May create the named file if it does not already exist.
  virtual Status LockFile(const std::string&amp; fname, FileLock** lock) = 0;

  // Release the lock acquired by a previous successful call to LockFile.
  // REQUIRES: lock was returned by a successful LockFile() call
  // REQUIRES: lock has not already been unlocked.
  virtual Status UnlockFile(FileLock* lock) = 0;

  // Arrange to run <span style="color: #ffff00;">"(*function)(arg)"</span> once in a background thread.
  //
  // <span style="color: #ffff00;">"function"</span> may run in an unspecified thread.  Multiple functions
  // added to the same Env may run concurrently in different threads.
  // I.e., the caller may not assume that background work items are
  // serialized.
  virtual void Schedule(
      void (*function)(void* arg),
      void* arg) = 0;

  // Start a new thread, invoking <span style="color: #ffff00;">"function(arg)"</span> within the new thread.
  // When <span style="color: #ffff00;">"function(arg)"</span> returns, the thread will be destroyed.
  virtual void StartThread(void (*function)(void* arg), void* arg) = 0;

  // *path is set to a temporary directory that can be used for testing. It may
  // or many not have just been created. The directory may or may not differ
  // between runs of the same process, but subsequent calls will return the
  // same directory.
  virtual Status GetTestDirectory(std::string* path) = 0;

  // Create and return a log file for storing informational messages.
  virtual Status NewLogger(const std::string&amp; fname, Logger** result) = 0;

  // Returns the number of micro-seconds since some fixed point in time. Only
  // useful for computing deltas of time.
  virtual uint64_t NowMicros() = 0;

  // Sleep/delay the thread for the perscribed number of micro-seconds.
  virtual void SleepForMicroseconds(int micros) = 0;
};
</pre>

<p>
稍微总结一下这些接口.对于这些接口创建的抽象对象，在后面也会详细解释。实现是PosixEnv.
</p><ul>
<li>Default // 获得默认的环境
</li>
<li>NewSequentialFile // 创建顺序文件
</li>
<li>NewRandomAccessFile // 创建随机文件
</li>
<li>NewWritableFile // 创建可写文件
</li>
<li>FileExists // 文件是否存在
</li>
<li>GetChildren // 目录下面的文件
</li>
<li>DeleteFile // 删除文件
</li>
<li>CreateDir // 创建目录
</li>
<li>DeleteDir // 删除目录
</li>
<li>GetFileSize // filesize.
</li>
<li>RenameFile // rename.
</li>
<li>LockFile // 锁住文件
</li>
<li>UnlockFile // 解锁文件
</li>
<li>StartThread // 创建线程
</li>
<li>GetTestDirectory // 测试目录
</li>
<li>NewLogger // 创建logger打印到对应文件
</li>
<li>NowMicros // 当前us.
</li>
<li>SleepForMicroseconds // sleep us
</li>
</ul>

<p>环境还提供了一个EnvWrapper.这个类就是得到一个Env*对象然后重新转发出去。
</p>
</div>

</div>

<div id="outline-container-1-10-1-4-2" class="outline-6">
<h6 id="sec-1-10-1-4-2"><span class="section-number-6">1.10.1.4.2</span> FileLock</h6>
<div class="outline-text-6" id="text-1-10-1-4-2">

<p>FileLock接口非常简单，可以说就没有接口.唯一要做的事情就是和Env里面的LockFile与UnlockFile配合。实现是PosixFileLock.
</p>


<pre class="src src-C++">// Identifies a locked file.
class FileLock {
 public:
  FileLock() { }
  virtual ~FileLock();
 private:
  // No copying allowed
  FileLock(const FileLock&amp;);
  void operator=(const FileLock&amp;);
};
</pre>


</div>

</div>

<div id="outline-container-1-10-1-4-3" class="outline-6">
<h6 id="sec-1-10-1-4-3"><span class="section-number-6">1.10.1.4.3</span> Logger</h6>
<div class="outline-text-6" id="text-1-10-1-4-3">

<p>Logger接口也非常简单，就是Logv.允许打印变长参数.实现是PosixLogger.
</p>


<pre class="src src-C++">// An interface for writing log messages.
class Logger {
 public:
  Logger() { }
  virtual ~Logger();

  // Write an entry to the log file with the specified format.
  virtual void Logv(const char* format, va_list ap) = 0;

 private:
  // No copying allowed
  Logger(const Logger&amp;);
  void operator=(const Logger&amp;);
};
</pre>


<p>
为了编写方便提供了这么一个宏
</p>


<pre class="src src-C++">// Log the specified data to *info_log if info_log is non-NULL.
extern void Log(Logger* info_log, const char* format, ...)
#   if defined(__GNUC__) || defined(__clang__)
    __attribute__((__format__ (__printf__, 2, 3)))
#   endif
    ;
</pre>


</div>

</div>

<div id="outline-container-1-10-1-4-4" class="outline-6">
<h6 id="sec-1-10-1-4-4"><span class="section-number-6">1.10.1.4.4</span> RandomAccessFile</h6>
<div class="outline-text-6" id="text-1-10-1-4-4">

<p>RandomAccessFile所提供的语义就是能够随机从offset读取n个字节，存放在scratch里面。
然后将result里面的内容指向scratch.随机读取并且要求能够多线程安全。实现是PosixRandomAccessFile.
</p>



<pre class="src src-C++">// A file abstraction for randomly reading the contents of a file.
class RandomAccessFile {
 public:
  RandomAccessFile() { }
  virtual ~RandomAccessFile();

  // Read up to <span style="color: #ffff00;">"n"</span> bytes from the file starting at <span style="color: #ffff00;">"offset"</span>.
  // <span style="color: #ffff00;">"scratch[0..n-1]"</span> may be written by this routine.  Sets <span style="color: #ffff00;">"*result"</span>
  // to the data that was read (including if fewer than <span style="color: #ffff00;">"n"</span> bytes were
  // successfully read).  May set <span style="color: #ffff00;">"*result"</span> to point at data in
  // <span style="color: #ffff00;">"scratch[0..n-1]"</span>, so <span style="color: #ffff00;">"scratch[0..n-1]"</span> must be live when
  // <span style="color: #ffff00;">"*result"</span> is used.  If an error was encountered, returns a non-OK
  // status.
  //
  // Safe for concurrent use by multiple threads.
  virtual Status Read(uint64_t offset, size_t n, Slice* result,
                      char* scratch) const = 0;
};
</pre>


</div>

</div>

<div id="outline-container-1-10-1-4-5" class="outline-6">
<h6 id="sec-1-10-1-4-5"><span class="section-number-6">1.10.1.4.5</span> SequentialFile</h6>
<div class="outline-text-6" id="text-1-10-1-4-5">

<p>SequentialFile提供的语义包括顺序读取以及Skip字节。这些都是外部来保证同步的。实现是PosixSequentialFile.
</p>


<pre class="src src-C++">// A file abstraction for reading sequentially through a file
class SequentialFile {
 public:
  SequentialFile() { }
  virtual ~SequentialFile();

  // Read up to <span style="color: #ffff00;">"n"</span> bytes from the file.  <span style="color: #ffff00;">"scratch[0..n-1]"</span> may be
  // written by this routine.  Sets <span style="color: #ffff00;">"*result"</span> to the data that was
  // read (including if fewer than <span style="color: #ffff00;">"n"</span> bytes were successfully read).
  // May set <span style="color: #ffff00;">"*result"</span> to point at data in <span style="color: #ffff00;">"scratch[0..n-1]"</span>, so
  // <span style="color: #ffff00;">"scratch[0..n-1]"</span> must be live when <span style="color: #ffff00;">"*result"</span> is used.
  // If an error was encountered, returns a non-OK status.
  //
  // REQUIRES: External synchronization
  virtual Status Read(size_t n, Slice* result, char* scratch) = 0;

  // Skip <span style="color: #ffff00;">"n"</span> bytes from the file. This is guaranteed to be no
  // slower that reading the same data, but may be faster.
  //
  // If end of file is reached, skipping will stop at the end of the
  // file, and Skip will return OK.
  //
  // REQUIRES: External synchronization
  virtual Status Skip(uint64_t n) = 0;
};
</pre>


</div>

</div>

<div id="outline-container-1-10-1-4-6" class="outline-6">
<h6 id="sec-1-10-1-4-6"><span class="section-number-6">1.10.1.4.6</span> WritableFile</h6>
<div class="outline-text-6" id="text-1-10-1-4-6">

<p>WritableFile语义就是允许Append,Close,Flush,Sync.这里Flush的语义应该是将内部缓存数据完全写入，
而Sync表示让磁盘进行同步。因为可能外部会调用小对象的写入，所以这里需要进行缓存。实现是PosixMmapFile.
</p>



<pre class="src src-C++">// A file abstraction for sequential writing.  The implementation
// must provide buffering since callers may append small fragments
// at a time to the file.
class WritableFile {
 public:
  WritableFile() { }
  virtual ~WritableFile();

  virtual Status Append(const Slice&amp; data) = 0;
  virtual Status Close() = 0;
  virtual Status Flush() = 0;
  virtual Status Sync() = 0;

 private:
  // No copying allowed
  WritableFile(const WritableFile&amp;);
  void operator=(const WritableFile&amp;);
};
</pre>


</div>
</div>

</div>

<div id="outline-container-1-10-1-5" class="outline-5">
<h5 id="sec-1-10-1-5"><span class="section-number-5">1.10.1.5</span> filter_policy.h</h5>
<div class="outline-text-5" id="text-1-10-1-5">

<p>通过阅读注释还是可以很容易地了解到filter_policy提供的语义的。另外还可以看到leveldb本身提供了bloomfilter的实现。
TODO(dirlt):这里对于bits_per_key含义不是很了解。
</p>
<p>
NOTE(dirlt):所谓的bits_per_key就是希望为每个key分配多少个bits来进行检测。但是这个并不等于检测bits.在leveldb这个
bloomfilter里面的话这个数值叫做probe.
</p>



<pre class="src src-C++">class FilterPolicy {
 public:
  virtual ~FilterPolicy();

  // &#29992;&#26469;&#20570;&#20860;&#23481;&#21028;&#26029;&#12290;&#22914;&#26524;&#26032;&#30340;filter policy&#21457;&#29983;&#25913;&#21464;&#30340;&#35805;&#65292;&#37027;&#20040;&#36825;&#20010;&#21517;&#23383;&#20063;&#24517;&#39035;&#21464;&#21270;&#12290;
  // Return the name of this policy.  Note that if the filter encoding
  // changes in an incompatible way, the name returned by this method
  // must be changed.  Otherwise, old incompatible filters may be
  // passed to methods of this type.
  virtual const char* Name() const = 0;

  // keys&#37117;&#26159;&#25490;&#22909;&#24207;&#30340;&#65292;&#23558;&#36825;&#20123;keys&#21152;&#20837;filter.&#30456;&#24403;&#20110;&#21578;&#30693;&#36825;&#20123;keys&#24050;&#32463;&#23384;&#22312;&#12290;
  // keys[0,n-1] contains a list of keys (potentially with duplicates)
  // that are ordered according to the user supplied comparator.
  // Append a filter that summarizes keys[0,n-1] to *dst.
  //
  // Warning: do not change the initial contents of *dst.  Instead,
  // append the newly constructed filter to *dst.
  virtual void CreateFilter(const Slice* keys, int n, std::string* dst)
      const = 0;

  // &#21028;&#26029;key&#26159;&#21542;&#22312;filter&#37324;&#38754;&#12290;&#36825;&#20010;filter&#26159;&#22312;CreateFilter&#37324;&#38754;&#30340;dst&#21253;&#35013;&#20986;&#26469;&#30340;&#12290;
  // <span style="color: #ffff00;">"filter"</span> contains the data appended by a preceding call to
  // CreateFilter() on this class.  This method must return true if
  // the key was in the list of keys passed to CreateFilter().
  // This method may return true or false if the key was not on the
  // list, but it should aim to return false with a high probability.
  virtual bool KeyMayMatch(const Slice&amp; key, const Slice&amp; filter) const = 0;
};

// Return a new filter policy that uses a bloom filter with approximately
// the specified number of bits per key.  A good value for bits_per_key
// is 10, which yields a filter with ~ 1% false positive rate.
//
// Callers must delete the result after any database that is using the
// result has been closed.
//
// Note: if you are using a custom comparator that ignores some parts
// of the keys being compared, you must not use NewBloomFilterPolicy()
// and must provide your own FilterPolicy that also ignores the
// corresponding parts of the keys.  For example, if the comparator
// ignores trailing spaces, it would be incorrect to use a
// FilterPolicy (like NewBloomFilterPolicy) that does not ignore
// trailing spaces in keys.
extern const FilterPolicy* NewBloomFilterPolicy(int bits_per_key);
</pre>


</div>

</div>

<div id="outline-container-1-10-1-6" class="outline-5">
<h5 id="sec-1-10-1-6"><span class="section-number-5">1.10.1.6</span> iterator.h</h5>
<div class="outline-text-5" id="text-1-10-1-6">

<p>遍历器接口非常简单，支持前向和反向遍历。还支持seek到某一个key.支持注册cleanup函数.实现是DBIter.
</p>


<pre class="src src-C++">class Iterator {
 public:
  Iterator();
  virtual ~Iterator();

  // An iterator is either positioned at a key/value pair, or
  // not valid.  This method returns true iff the iterator is valid.
  virtual bool Valid() const = 0;

  // Position at the first key in the source.  The iterator is Valid()
  // after this call iff the source is not empty.
  virtual void SeekToFirst() = 0;

  // Position at the last key in the source.  The iterator is
  // Valid() after this call iff the source is not empty.
  virtual void SeekToLast() = 0;

  // Position at the first key in the source that at or past target
  // The iterator is Valid() after this call iff the source contains
  // an entry that comes at or past target.
  virtual void Seek(const Slice&amp; target) = 0;

  // Moves to the next entry in the source.  After this call, Valid() is
  // true iff the iterator was not positioned at the last entry in the source.
  // REQUIRES: Valid()
  virtual void Next() = 0;

  // Moves to the previous entry in the source.  After this call, Valid() is
  // true iff the iterator was not positioned at the first entry in source.
  // REQUIRES: Valid()
  virtual void Prev() = 0;

  // Return the key for the current entry.  The underlying storage for
  // the returned slice is valid only until the next modification of
  // the iterator.
  // REQUIRES: Valid()
  virtual Slice key() const = 0;

  // Return the value for the current entry.  The underlying storage for
  // the returned slice is valid only until the next modification of
  // the iterator.
  // REQUIRES: !AtEnd() &amp;&amp; !AtStart()
  virtual Slice value() const = 0;

  // If an error has occurred, return it.  Else return an ok status.
  virtual Status status() const = 0;

  // Clients are allowed to register function/arg1/arg2 triples that
  // will be invoked when this iterator is destroyed.
  //
  // Note that unlike all of the preceding methods, this method is
  // not abstract and therefore clients should not override it.
  typedef void (*CleanupFunction)(void* arg1, void* arg2);
  void RegisterCleanup(CleanupFunction function, void* arg1, void* arg2);

 private:
  struct Cleanup {
    CleanupFunction function;
    void* arg1;
    void* arg2;
    Cleanup* next;
  };
  Cleanup cleanup_;

  // No copying allowed
  Iterator(const Iterator&amp;);
  void operator=(const Iterator&amp;);
};
</pre>

<p>
这个里面部分实现在table/iterator.cc里面有.都非常简单.创建好cleanup对象然后组织称为链表,在析构函数时候调用.
</p>


<pre class="src src-C++">Iterator::Iterator() {
  cleanup_.function = NULL;
  cleanup_.next = NULL;
}

Iterator::~Iterator() {
  if (cleanup_.function != NULL) {
    (*cleanup_.function)(cleanup_.arg1, cleanup_.arg2);
    for (Cleanup* c = cleanup_.next; c != NULL; ) {
      (*c-&gt;function)(c-&gt;arg1, c-&gt;arg2);
      Cleanup* next = c-&gt;next;
      delete c;
      c = next;
    }
  }
}

void Iterator::RegisterCleanup(CleanupFunction func, void* arg1, void* arg2) {
  assert(func != NULL);
  Cleanup* c;
  if (cleanup_.function == NULL) {
    c = &amp;cleanup_;
  } else {
    c = new Cleanup;
    c-&gt;next = cleanup_.next;
    cleanup_.next = c;
  }
  c-&gt;function = func;
  c-&gt;arg1 = arg1;
  c-&gt;arg2 = arg2;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-1-7" class="outline-5">
<h5 id="sec-1-10-1-7"><span class="section-number-5">1.10.1.7</span> options.h</h5>
<div class="outline-text-5" id="text-1-10-1-7">

<p>对于options来说存在3种
</p><ul>
<li>Options // 控制DB行为.
</li>
<li>ReadOptions // 控制读取行为
</li>
<li>WriteOptions // 控制写入行为
</li>
</ul>



</div>

<div id="outline-container-1-10-1-7-1" class="outline-6">
<h6 id="sec-1-10-1-7-1"><span class="section-number-6">1.10.1.7.1</span> Options</h6>
<div class="outline-text-6" id="text-1-10-1-7-1">

<p>Options控制DB行为，在DB::Open时候就传入.我们需要针对这些字段仔细看看.
</p>


<pre class="src src-C++">// DB contents are stored in a set of blocks, each of which holds a
// sequence of key,value pairs.  Each block may be compressed before
// being stored in a file.  The following enum describes which
// compression method (if any) is used to compress a block.
enum CompressionType {
  // NOTE: do not change the values of existing entries, as these are
  // part of the persistent format on disk.
  kNoCompression     = 0x0,
  kSnappyCompression = 0x1
};

// Options to control the behavior of a database (passed to DB::Open)
struct Options {
  // -------------------
  // Parameters that affect behavior

  // Comparator used to define the order of keys in the table.
  // Default: a comparator that uses lexicographic byte-wise ordering
  //
  // REQUIRES: The client must ensure that the comparator supplied
  // here has the same name and orders keys *exactly* the same as the
  // comparator provided to previous open calls on the same DB.
  const Comparator* comparator; // &#22914;&#20309;&#36827;&#34892;slice compare

  // If true, the database will be created if it is missing.
  // Default: false
  bool create_if_missing; // database&#19981;&#23384;&#22312;&#26159;&#21542;&#38656;&#35201;&#21019;&#24314;.

  // If true, an error is raised if the database already exists.
  // Default: false
  bool error_if_exists; // &#22914;&#26524;&#25968;&#25454;&#24211;&#23384;&#22312;&#26159;&#21542;error

  // If true, the implementation will do aggressive checking of the
  // data it is processing and will stop early if it detects any
  // errors.  This may have unforeseen ramifications: for example, a
  // corruption of one DB entry may cause a large number of entries to
  // become unreadable or for the entire DB to become unopenable.
  // Default: false
  bool paranoid_checks; // &#20250;&#26356;&#22810;&#22320;&#26816;&#26597;&#25968;&#25454;&#27491;&#30830;&#24615;.&#36825;&#20010;&#22312;&#26085;&#24535;&#22238;&#25918;&#30340;&#26102;&#20505;&#26377;&#25928;.
  // MaybeIgnoreError&#37324;&#38754;&#20351;&#29992;.

  // Use the specified object to interact with the environment,
  // e.g. to read/write files, schedule background work, etc.
  // Default: Env::Default()
  Env* env; // &#25805;&#20316;&#29615;&#22659;.

  // Any internal progress/error information generated by the db will
  // be written to info_log if it is non-NULL, or to a file stored
  // in the same directory as the DB contents if info_log is NULL.
  // Default: NULL
  Logger* info_log; // Logger.

  // -------------------
  // Parameters that affect performance

  // Amount of data to build up in memory (backed by an unsorted log
  // on disk) before converting to a sorted on-disk file.
  //
  // Larger values increase performance, especially during bulk loads.
  // Up to two write buffers may be held in memory at the same time,
  // so you may wish to adjust this parameter to control memory usage.
  // Also, a larger write buffer will result in a longer recovery time
  // the next time the database is opened.
  //
  // Default: 4MB
  size_t write_buffer_size; // memtable&#36229;&#36807;&#36825;&#20123;&#20869;&#23384;&#22823;&#23567;&#30340;&#35805;&#23601;&#20250;&#20889;table.

  // Number of open files that can be used by the DB.  You may need to
  // increase this if your database has a large working set (budget
  // one open file per 2MB of working set).
  //
  // Default: 1000
  int max_open_files; // &#26368;&#22823;&#25991;&#20214;&#21477;&#26564;&#25968;.

  // Control over blocks (user data is stored in a set of blocks, and
  // a block is the unit of reading from disk).

  // If non-NULL, use the specified cache for blocks.
  // If NULL, leveldb will automatically create and use an 8MB internal cache.
  // Default: NULL
  Cache* block_cache; // &#20869;&#37096;cahce.

  // Approximate size of user data packed per block.  Note that the
  // block size specified here corresponds to uncompressed data.  The
  // actual size of the unit read from disk may be smaller if
  // compression is enabled.  This parameter can be changed dynamically.
  //
  // Default: 4K
  size_t block_size; // SSTable&#37324;&#38754;&#30340;Block&#22823;&#23567;.&#20855;&#20307;&#21487;&#20197;&#30475;BlockBuilder.

  // Number of keys between restart points for delta encoding of keys.
  // This parameter can be changed dynamically.  Most clients should
  // leave this parameter alone.
  //
  // Default: 16
  int block_restart_interval; // block&#37324;&#38754;&#30340;restart&#38388;&#38548;.&#20855;&#20307;&#21487;&#20197;&#30475;BlockBuilder.

  // Compress blocks using the specified compression algorithm.  This
  // parameter can be changed dynamically.
  //
  // Default: kSnappyCompression, which gives lightweight but fast
  // compression.
  //
  // Typical speeds of kSnappyCompression on an Intel(R) Core(TM)2 2.4GHz:
  //    ~200-500MB/s compression
  //    ~400-800MB/s decompression
  // Note that these speeds are significantly faster than most
  // persistent storage speeds, and therefore it is typically never
  // worth switching to kNoCompression.  Even if the input data is
  // incompressible, the kSnappyCompression implementation will
  // efficiently detect that and will switch to uncompressed mode.
  CompressionType compression; // &#21387;&#32553;&#31867;&#22411;.&#19981;&#21387;&#32553;&#21644;Snappy&#21387;&#32553;.

  // Create an Options object with default values for all fields.
  Options();
};
</pre>


</div>

</div>

<div id="outline-container-1-10-1-7-2" class="outline-6">
<h6 id="sec-1-10-1-7-2"><span class="section-number-6">1.10.1.7.2</span> ReadOptions</h6>
<div class="outline-text-6" id="text-1-10-1-7-2">

<p>和Options一样里面也都是控制字段.
</p>


<pre class="src src-C++">// Options that control read operations
struct ReadOptions {
  // If true, all data read from underlying storage will be
  // verified against corresponding checksums.
  // Default: false
  bool verify_checksums; // &#35835;&#21462;&#26102;&#20505;&#36827;&#34892;checksum&#26657;&#39564;

  // Should the data read for this iteration be cached in memory?
  // Callers may wish to set this field to false for bulk scans.
  // Default: true
  bool fill_cache; // &#26159;&#21542;&#38656;&#35201;&#20174;cache&#37324;&#38754;&#26597;&#25214;.&#22914;&#26524;&#26159;bulk scans&#30340;&#35805;&#37027;&#20040;&#35774;&#32622;false.

  // If <span style="color: #ffff00;">"snapshot"</span> is non-NULL, read as of the supplied snapshot
  // (which must belong to the DB that is being read and which must
  // not have been released).  If <span style="color: #ffff00;">"snapshot"</span> is NULL, use an impliicit
  // snapshot of the state at the beginning of this read operation.
  // Default: NULL
  const Snapshot* snapshot; // &#22914;&#26524;&#23384;&#22312;Snapshot&#30340;&#35805;&#37027;&#20040;&#23601;&#22312;snapshot&#19978;&#38754;&#35835;&#21462;.

  ReadOptions()
      : verify_checksums(false),
        fill_cache(true),
        snapshot(NULL) {
  }
};
</pre>


</div>

</div>

<div id="outline-container-1-10-1-7-3" class="outline-6">
<h6 id="sec-1-10-1-7-3"><span class="section-number-6">1.10.1.7.3</span> WriteOptions</h6>
<div class="outline-text-6" id="text-1-10-1-7-3">

<p>和Options一样里面也都是控制字段.
</p>


<pre class="src src-C++">// Options that control write operations
struct WriteOptions {
  // If true, the write will be flushed from the operating system
  // buffer cache (by calling WritableFile::Sync()) before the write
  // is considered complete.  If this flag is true, writes will be
  // slower.
  //
  // If this flag is false, and the machine crashes, some recent
  // writes may be lost.  Note that if it is just the process that
  // crashes (i.e., the machine does not reboot), no writes will be
  // lost even if sync==false.
  //
  // In other words, a DB write with sync==false has similar
  // crash semantics as the <span style="color: #ffff00;">"write()"</span> system call.  A DB write
  // with sync==true has similar crash semantics to a <span style="color: #ffff00;">"write()"</span>
  // system call followed by <span style="color: #ffff00;">"fsync()"</span>.
  //
  // Default: false
  bool sync; // &#26159;&#21542;&#27599;&#27425;&#20889;&#37117;&#38656;&#35201;fsync.

  WriteOptions()
      : sync(false) {
  }
};
</pre>


</div>
</div>

</div>

<div id="outline-container-1-10-1-8" class="outline-5">
<h5 id="sec-1-10-1-8"><span class="section-number-5">1.10.1.8</span> slice.h</h5>
<div class="outline-text-5" id="text-1-10-1-8">

<p>leveldb里面的Slice对象是用来作为key使用的。内部实现非常简单，仅仅是存储二进制的指针和大小。
我们可能需要稍微注意一下slice对象的compare方法.首先按照最小长度比较，如果相等然后按照比较长度。
</p>


<pre class="src src-C++">inline int Slice::compare(const Slice&amp; b) const {
  const int min_len = (size_ &lt; b.size_) ? size_ : b.size_;
  int r = memcmp(data_, b.data_, min_len);
  if (r == 0) {
    if (size_ &lt; b.size_) r = -1;
    else if (size_ &gt; b.size_) r = +1;
  }
  return r;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-1-9" class="outline-5">
<h5 id="sec-1-10-1-9"><span class="section-number-5">1.10.1.9</span> status.h</h5>
<div class="outline-text-5" id="text-1-10-1-9">

<p>status就是一个非常简单的封装.内部持有一个char* status_;从注释里面可以看出如何安排的。
实现在util/status.cc里面，没有必要仔细阅读。不过我到觉得直接返回一个int就算了。
没有必要开辟char[].不过如果这个部分没有性能问题也就无所谓了。
</p>



<pre class="src src-C++">class Status {
 public:
  // Create a success status.
  Status() : state_(NULL) { }
  ~Status() { delete[] state_; }

  // Copy the specified status.
  Status(const Status&amp; s);
  void operator=(const Status&amp; s);

  // Return a success status.
  static Status OK() { return Status(); }

  // Return error status of an appropriate type.
  static Status NotFound(const Slice&amp; msg, const Slice&amp; msg2 = Slice()) {
    return Status(kNotFound, msg, msg2);
  }
  static Status Corruption(const Slice&amp; msg, const Slice&amp; msg2 = Slice()) {
    return Status(kCorruption, msg, msg2);
  }
  static Status NotSupported(const Slice&amp; msg, const Slice&amp; msg2 = Slice()) {
    return Status(kNotSupported, msg, msg2);
  }
  static Status InvalidArgument(const Slice&amp; msg, const Slice&amp; msg2 = Slice()) {
    return Status(kInvalidArgument, msg, msg2);
  }
  static Status IOError(const Slice&amp; msg, const Slice&amp; msg2 = Slice()) {
    return Status(kIOError, msg, msg2);
  }

  // Returns true iff the status indicates success.
  bool ok() const { return (state_ == NULL); }

  // Returns true iff the status indicates a NotFound error.
  bool IsNotFound() const { return code() == kNotFound; }

  // Return a string representation of this status suitable for printing.
  // Returns the string <span style="color: #ffff00;">"OK"</span> for success.
  std::string ToString() const;

 private:
  // OK status has a NULL state_.  Otherwise, state_ is a new[] array
  // of the following form:
  //    state_[0..3] == length of message
  //    state_[4]    == code
  //    state_[5..]  == message
  const char* state_;

  enum Code {
    kOk = 0,
    kNotFound = 1,
    kCorruption = 2,
    kNotSupported = 3,
    kInvalidArgument = 4,
    kIOError = 5
  };

  Code code() const {
    return (state_ == NULL) ? kOk : static_cast&lt;Code&gt;(state_[4]);
  }

  Status(Code code, const Slice&amp; msg, const Slice&amp; msg2);
  static const char* CopyState(const char* s);
};

inline Status::Status(const Status&amp; s) {
  state_ = (s.state_ == NULL) ? NULL : CopyState(s.state_);
}
inline void Status::operator=(const Status&amp; s) {
  // The following condition catches both aliasing (when this == &amp;s),
  // and the common case where both s and *this are ok.
  if (state_ != s.state_) {
    delete[] state_;
    state_ = (s.state_ == NULL) ? NULL : CopyState(s.state_);
  }
}
</pre>


</div>

</div>

<div id="outline-container-1-10-1-10" class="outline-5">
<h5 id="sec-1-10-1-10"><span class="section-number-5">1.10.1.10</span> table_builder.h</h5>
<div class="outline-text-5" id="text-1-10-1-10">

<p>TableBuilder用来帮助构建Table.而Table本身只是用来进行查询遍历等操作.用户在完成之后需要Finish或者是Abandon.
具体实现会在后面分析.
</p>


<pre class="src src-C++">class TableBuilder {
 public:
  // Create a builder that will store the contents of the table it is
  // building in *file.  Does not close the file.  It is up to the
  // caller to close the file after calling Finish().
  TableBuilder(const Options&amp; options, WritableFile* file); // &#20256;&#20837;options&#21644;&#21487;&#20889;&#25991;&#20214;(&#36861;&#21152;&#20889;&#27169;&#24335;)

  // REQUIRES: Either Finish() or Abandon() has been called.
  ~TableBuilder();

  // Change the options used by this builder.  Note: only some of the
  // option fields can be changed after construction.  If a field is
  // not allowed to change dynamically and its value in the structure
  // passed to the constructor is different from its value in the
  // structure passed to this method, this method will return an error
  // without changing any fields.
  Status ChangeOptions(const Options&amp; options); // &#19968;&#26086;&#26500;&#24314;&#22909;&#20043;&#21518;&#21482;&#20801;&#35768;&#20462;&#25913;&#37096;&#20998;&#23383;&#27573;.

  // Add key,value to the table being constructed.
  // REQUIRES: key is after any previously added key according to comparator.
  // REQUIRES: Finish(), Abandon() have not been called
  void Add(const Slice&amp; key, const Slice&amp; value); // &#28155;&#21152;kv

  // Advanced operation: flush any buffered key/value pairs to file.
  // Can be used to ensure that two adjacent entries never live in
  // the same data block.  Most clients should not need to use this method.
  // REQUIRES: Finish(), Abandon() have not been called
  void Flush(); // &#23558;buffered&#30340;kv&#21047;&#26032;&#21040;&#25991;&#20214;

  // Return non-ok iff some error has been detected.
  Status status() const;

  // Finish building the table.  Stops using the file passed to the
  // constructor after this function returns.
  // REQUIRES: Finish(), Abandon() have not been called
  Status Finish(); // &#26500;&#24314;&#23436;&#25104;.

  // Indicate that the contents of this builder should be abandoned.  Stops
  // using the file passed to the constructor after this function returns.
  // If the caller is not going to call Finish(), it must call Abandon()
  // before destroying this builder.
  // REQUIRES: Finish(), Abandon() have not been called
  void Abandon(); // &#22914;&#26524;&#25918;&#24323;&#26500;&#24314;&#30340;&#35805;

  // Number of calls to Add() so far.
  uint64_t NumEntries() const; // &#28155;&#21152;&#20102;&#22810;&#23569;&#27425;

  // Size of the file generated so far.  If invoked after a successful
  // Finish() call, returns the size of the final generated file.
  uint64_t FileSize() const; // &#24403;&#21069;&#24050;&#32463;&#20889;&#20837;&#22810;&#23569;&#25991;&#20214;&#20102;.

 private:
  bool ok() const { return status().ok(); }
  void WriteBlock(BlockBuilder* block, BlockHandle* handle);

  struct Rep;
  Rep* rep_;

  // No copying allowed
  TableBuilder(const TableBuilder&amp;);
  void operator=(const TableBuilder&amp;);
};
</pre>

<p>
下面是一些比较重要的接口.
</p><ul>
<li>ChangeOptions // 修改选项
</li>
<li>Add // 添加kv.k必须是有序
</li>
<li>Flush // 刷新
</li>
<li>Finish // 结束
</li>
<li>Abandon // 放弃
</li>
</ul>


</div>

</div>

<div id="outline-container-1-10-1-11" class="outline-5">
<h5 id="sec-1-10-1-11"><span class="section-number-5">1.10.1.11</span> table.h</h5>
<div class="outline-text-5" id="text-1-10-1-11">

<p>Table就是持久化并且不可变的sortedtable.下面来看看接口.具体实现会在后面分析.
</p>


<pre class="src src-C++">// A Table is a sorted map from strings to strings.  Tables are
// immutable and persistent.  A Table may be safely accessed from
// multiple threads without external synchronization.
class Table {
 public:
  // Attempt to open the table that is stored in bytes [0..file_size)
  // of <span style="color: #ffff00;">"file"</span>, and read the metadata entries necessary to allow
  // retrieving data from the table.
  //
  // If successful, returns ok and sets <span style="color: #ffff00;">"*table"</span> to the newly opened
  // table.  The client should delete <span style="color: #ffff00;">"*table"</span> when no longer needed.
  // If there was an error while initializing the table, sets <span style="color: #ffff00;">"*table"</span>
  // to NULL and returns a non-ok status.  Does not take ownership of
  // <span style="color: #ffff00;">"*source"</span>, but the client must ensure that <span style="color: #ffff00;">"source"</span> remains live
  // for the duration of the returned table's lifetime.
  //
  // *file must remain live while this Table is in use.
  static Status Open(const Options&amp; options,
                     RandomAccessFile* file,
                     uint64_t file_size,
                     Table** table);

  ~Table();

  // Returns a new iterator over the table contents.
  // The result of NewIterator() is initially invalid (caller must
  // call one of the Seek methods on the iterator before using it).
  Iterator* NewIterator(const ReadOptions&amp;) const;

  // Given a key, return an approximate byte offset in the file where
  // the data for that key begins (or would begin if the key were
  // present in the file).  The returned value is in terms of file
  // bytes, and so includes effects like compression of the underlying data.
  // E.g., the approximate offset of the last key in the table will
  // be close to the file length.
  uint64_t ApproximateOffsetOf(const Slice&amp; key) const;

 private:
  struct Rep;
  Rep* rep_;

  explicit Table(Rep* rep) { rep_ = rep; }
  static Iterator* BlockReader(void*, const ReadOptions&amp;, const Slice&amp;);

  // No copying allowed
  Table(const Table&amp;);
  void operator=(const Table&amp;);
};
</pre>

<p>
主要提供的接口如下
</p><ul>
<li>Open. // 这个接口可以看出访问的是随机文件.
</li>
<li>NewIterator // 创建一个迭代器.
</li>
<li>ApproximateOffsetOf // 可以通过key查找到大致位置然后后续可以发起读操作.
</li>
</ul>


</div>

</div>

<div id="outline-container-1-10-1-12" class="outline-5">
<h5 id="sec-1-10-1-12"><span class="section-number-5">1.10.1.12</span> write_batch.h</h5>
<div class="outline-text-5" id="text-1-10-1-12">

<p>WriteBatch用来持有批量写入的内容.注意底层实现有Handler是需要具体实现的。关于这个具体实现部分会在后面分析.
</p>


<pre class="src src-C++">class WriteBatch {
 public:
  WriteBatch();
  ~WriteBatch();

  // Store the mapping <span style="color: #ffff00;">"key-&gt;value"</span> in the database.
  void Put(const Slice&amp; key, const Slice&amp; value);

  // If the database contains a mapping for <span style="color: #ffff00;">"key"</span>, erase it.  Else do nothing.
  void Delete(const Slice&amp; key);

  // Clear all updates buffered in this batch.
  void Clear();

  // Support for iterating over the contents of a batch.
  class Handler {
   public:
    virtual ~Handler();
    virtual void Put(const Slice&amp; key, const Slice&amp; value) = 0;
    virtual void Delete(const Slice&amp; key) = 0;
  };
  Status Iterate(Handler* handler) const;
  // &#38405;&#35835;&#21518;&#38754;&#20250;&#21457;&#29616;&#65292;&#36825;&#20010;&#24847;&#24605;&#26159;&#36941;&#21382;&#25152;&#26377;&#30340;WriteBatch&#37324;&#38754;&#30340;item
  // &#28982;&#21518;&#25805;&#20316;handler.handler&#21487;&#33021;&#26159;&#19968;&#20010;memtable.&#36825;&#26679;&#21487;&#20197;&#23558;&#37324;&#38754;&#25152;&#26377;&#30340;&#20869;&#23481;
  // &#20840;&#37096;&#23384;&#25918;&#21040;memtable&#37324;&#38754;&#21435;.

 private:
  friend class WriteBatchInternal; // &#24213;&#23618;&#23454;&#29616;&#26159;&#36825;&#20010;.

  std::string rep_;  // See comment in write_batch.cc for the format of rep_ // &#23558;&#25152;&#26377;&#30340;&#25805;&#20316;&#35831;&#27714;&#20570;&#25104;&#20108;&#36827;&#21046;&#23384;&#25918;&#22312;rep_

  // Intentionally copyable
};
</pre>


</div>
</div>

</div>

<div id="outline-container-1-10-2" class="outline-4">
<h4 id="sec-1-10-2"><span class="section-number-4">1.10.2</span> Implementation</h4>
<div class="outline-text-4" id="text-1-10-2">

<p>实现部分我按照功能划分了几个部分.
</p><ul>
<li>DB
</li>
<li>Posix
</li>
<li>Cache
</li>
<li>Batch
</li>
<li>Log
</li>
<li>Table
</li>
<li>Util
</li>
</ul>


</div>

</div>

<div id="outline-container-1-10-3" class="outline-4">
<h4 id="sec-1-10-3"><span class="section-number-4">1.10.3</span> DB</h4>
<div class="outline-text-4" id="text-1-10-3">


</div>

<div id="outline-container-1-10-3-1" class="outline-5">
<h5 id="sec-1-10-3-1"><span class="section-number-5">1.10.3.1</span> FileName</h5>
<div class="outline-text-5" id="text-1-10-3-1">

<p>db/filename.cc 这里面都是关于文件名称操作的方法.文件包括
</p><ul>
<li>db/CURRENT // 当前文件
</li>
<li>db/LOCK // DB锁文件
</li>
<li>db/LOG // info log.日志文件.
</li>
<li>db/LOG.old // info log.日志文件.
</li>
<li>db/MANIFEST-[0-9]+ // 描述文件
</li>
<li>db/[0-9]+.log // db日志文件
</li>
<li>db/[0-9]+.sst // dbtable文件
</li>
<li>db/[0-9]+.dbtmp // db临时文件
</li>
</ul>

<p>这里[0-9]+都表示一个sequence number.这里还有另外一个不是操作FileName的函数.SetCurrentFile
</p>


<pre class="src src-C++">Status SetCurrentFile(Env* env, const std::string&amp; dbname,
                      uint64_t descriptor_number) {
  // Remove leading <span style="color: #ffff00;">"dbname/"</span> and add newline to manifest file name
  std::string manifest = DescriptorFileName(dbname, descriptor_number);
  Slice contents = manifest;
  assert(contents.starts_with(dbname + <span style="color: #ffff00;">"/"</span>));
  contents.remove_prefix(dbname.size() + 1);
  std::string tmp = TempFileName(dbname, descriptor_number);
  Status s = WriteStringToFile(env, contents.ToString() + <span style="color: #ffff00;">"\n"</span>, tmp);
  if (s.ok()) {
    s = env-&gt;RenameFile(tmp, CurrentFileName(dbname));
  }
  if (!s.ok()) {
    env-&gt;DeleteFile(tmp);
  }
  return s;
}
</pre>

<p>
就是将MANIFEST-%(descriptor_number)llu+"\n"写入到.dbtmp下面去然后rename成为CURRENT文件.
</p>
</div>

</div>

<div id="outline-container-1-10-3-2" class="outline-5">
<h5 id="sec-1-10-3-2"><span class="section-number-5">1.10.3.2</span> Config</h5>
<div class="outline-text-5" id="text-1-10-3-2">

<p>db/dbformat.h config下面是一些静态常数.这里可以仔细看看.
</p>


<pre class="src src-C++">// Grouping of constants.  We may want to make some of these
// parameters set via options.
namespace config {
// leveldb&#26368;&#22823;level&#22810;&#23569;.
static const int kNumLevels = 7;

// Level-0 compaction is started when we hit this many files.
// level0&#25991;&#20214;&#36229;&#36807;&#22810;&#23569;&#20010;&#35302;&#21457;compaction.
static const int kL0_CompactionTrigger = 4;

// &#19979;&#38754;&#20004;&#20010;&#21487;&#20197;&#22312;MakeRoomForWrite&#37324;&#38754;&#30475;&#21040;.
// Soft limit on number of level-0 files.  We slow down writes at this point.
// &#22914;&#26524;level0&#25991;&#20214;&#36229;&#36807;&#36825;&#20040;&#22810;&#30340;&#35805;&#37027;&#20040;&#21487;&#33021;&#20250;&#25918;&#32531;memtable&#20889;&#20026;level0&#30340;&#36895;&#24230;.&#27604;&#22914;delay 1s&#21861;&#30340;.
static const int kL0_SlowdownWritesTrigger = 8;

// Maximum number of level-0 files.  We stop writes at this point.
// &#22914;&#26524;level0&#25991;&#20214;&#36229;&#36807;&#36825;&#20040;&#22810;&#30340;&#35805;&#37027;&#19981;&#20250;memtable&#20889;&#20026;level0.
static const int kL0_StopWritesTrigger = 12;

// &#23545;&#20110;memtable&#36827;&#34892;compaction&#30340;&#35805;&#36873;&#25321;&#30340;&#26368;&#39640;level.
// &#36825;&#20010;&#21487;&#20197;&#22312;PickLevelForMemtableOutput&#37324;&#38754;&#21487;&#20197;&#30475;&#21040;.
// Maximum level to which a new compacted memtable is pushed if it
// does not create overlap.  We try to push to level 2 to avoid the
// relatively expensive level 0=&gt;1 compactions and to avoid some
// expensive manifest file operations.  We do not push all the way to
// the largest level since that can generate a lot of wasted disk
// space if the same key space is being repeatedly overwritten.
static const int kMaxMemCompactLevel = 2;

}  // namespace config
</pre>


</div>

</div>

<div id="outline-container-1-10-3-3" class="outline-5">
<h5 id="sec-1-10-3-3"><span class="section-number-5">1.10.3.3</span> DBImpl</h5>
<div class="outline-text-5" id="text-1-10-3-3">

<p>db/db_impl.cc DBImpl这个结构体挺大的。我们先过一个这个结构然后仔细看看每个字段是什么
</p>


<pre class="src src-C++">class DBImpl : public DB {
 private:
  // Constant after construction
  Env* const env_; // &#29615;&#22659;.
  const InternalKeyComparator internal_comparator_; // &#20869;&#37096;&#27604;&#36739;&#22120;.
  const Options options_;  // options_.comparator == &amp;internal_comparator_ // &#36873;&#39033;.
  bool owns_info_log_; // &#26159;&#21542;&#33258;&#24049;&#20998;&#37197;&#30340;log.
  bool owns_cache_; // &#26159;&#21542;&#33258;&#24049;&#20998;&#37197;&#30340;cache.
  const std::string dbname_; // db&#21517;&#31216;.

  // table_cache_ provides its own synchronization
  TableCache* table_cache_; // TableCache.

  // Lock over the persistent DB state.  Non-NULL iff successfully acquired.
  FileLock* db_lock_; // db FileLock. // &#23545;&#20110;&#22806;&#37096;&#36827;&#31243;&#26631;&#35760;DB&#23545;&#35937;&#20114;&#26021;&#38145;.

  // State below is protected by mutex_
  port::Mutex mutex_; // &#25972;&#20010;DB&#23545;&#35937;&#20114;&#26021;&#38145;.
  port::AtomicPointer shutting_down_; // &#26631;&#35760;&#36825;&#20010;DB&#23545;&#35937;&#27491;&#22312;&#36864;&#20986;&#12290;&#21518;&#21488;&#32447;&#31243;&#25110;&#30475;&#21040;&#20043;&#21518;&#19981;&#24212;&#35813;&#36827;&#34892;&#20219;&#20309;&#25805;&#20316;&#12290;
  port::CondVar bg_cv_;          // Signalled when background work finishes
  MemTable* mem_; // &#27491;&#22312;&#25805;&#20316;&#30340;memtable.
  MemTable* imm_;                // Memtable being compacted.&#27491;&#22312;&#34987;compacted&#30340;memtable
  port::AtomicPointer has_imm_;  // So bg thread can detect non-NULL imm_
  WritableFile* logfile_;
  uint64_t logfile_number_;
  log::Writer* log_;
  LoggerId* logger_;            // NULL, or the id of the current logging thread
  port::CondVar logger_cv_;     // For threads waiting to log.&#21644;mutex_&#20851;&#32852;.
  SnapshotList snapshots_; // &#24403;&#21069;&#25152;&#26377;&#30340;snapshot

  // Set of table files to protect from deletion because they are
  // part of ongoing compactions.
  std::set&lt;uint64_t&gt; pending_outputs_; // &#27491;&#22312;&#36755;&#20986;&#25110;&#32773;&#26159;&#36827;&#34892;compaction&#30340;file.
  // &#20445;&#23384;&#36825;&#20010;&#20449;&#24687;&#30340;&#35805;&#36825;&#26679;&#22312;delete&#25991;&#20214;&#30340;&#25918;&#32622;&#19981;&#34987;&#21024;&#38500;.

  // Has a background compaction been scheduled or is running?
  bool bg_compaction_scheduled_; // &#21518;&#21488;&#32447;&#31243;&#26159;&#21542;&#22312;&#36816;&#34892;.&#36824;&#26159;&#21487;&#20197;&#36864;&#20986;.

  // Information for a manual compaction
  struct ManualCompaction {
    int level;
    bool done;
    const InternalKey* begin;   // NULL means beginning of key range
    const InternalKey* end;     // NULL means end of key range
    InternalKey tmp_storage;    // Used to keep track of compaction progress
  };
  ManualCompaction* manual_compaction_;

  VersionSet* versions_; // &#29256;&#26412;&#38598;&#21512;.

  // Have we encountered a background error in paranoid mode?
  Status bg_error_; // &#21518;&#21488;&#32447;&#31243;&#36816;&#34892;&#29366;&#24577;.

  // Per level compaction stats.  stats_[level] stores the stats for
  // compactions that produced data for the specified <span style="color: #ffff00;">"level"</span>.
  struct CompactionStats { // &#21387;&#32553;&#29366;&#24577;&#20449;&#24687;.
    int64_t micros;
    int64_t bytes_read;
    int64_t bytes_written;

    CompactionStats() : micros(0), bytes_read(0), bytes_written(0) { }

    void Add(const CompactionStats&amp; c) {
      this-&gt;micros += c.micros;
      this-&gt;bytes_read += c.bytes_read;
      this-&gt;bytes_written += c.bytes_written;
    }
  };
  CompactionStats stats_[config::kNumLevels]; // &#21508;&#20010;&#32423;&#21035;&#30340;&#21387;&#32553;&#29366;&#24577;&#20449;&#24687;.
};
</pre>



</div>

<div id="outline-container-1-10-3-3-1" class="outline-6">
<h6 id="sec-1-10-3-3-1"><span class="section-number-6">1.10.3.3.1</span> Open</h6>
<div class="outline-text-6" id="text-1-10-3-3-1">

<p>在Interface部分的db.h里面可以知道构造这个DB对象是通过DB::Open来构造的。
</p>


<pre class="src src-C++">Status DB::Open(const Options&amp; options, const std::string&amp; dbname,
                DB** dbptr) {
  *dbptr = NULL;

  DBImpl* impl = new DBImpl(options, dbname); // &#21019;&#24314;DBImpl&#23454;&#20363;.
  impl-&gt;mutex_.Lock(); // &#20284;&#20046;&#27809;&#26377;&#22826;&#22823;&#24517;&#35201;.&#36825;&#37324;&#24212;&#35813;&#27809;&#26377;&#31454;&#20105;.
  VersionEdit edit;
  // &#22238;&#22797;&#33258;&#19978;&#27425;&#20381;&#36182;&#30340;edit&#25152;&#26377;&#20869;&#23481;.&#28982;&#21518;&#22312;&#21518;&#38754;&#30452;&#25509;log and apply&#36825;&#20010;edit&#23545;&#35937;.
  Status s = impl-&gt;Recover(&amp;edit); // Handles create_if_missing, error_if_exists
  // &#19979;&#38754;&#27599;&#20010;&#27493;&#39588;&#22823;&#33268;&#19978;&#37117;&#24456;&#28165;&#26970;
  // 1.&#21019;&#24314;&#26032;&#30340;log&#25991;&#20214;
  // 2.&#22238;&#25918;&#21407;&#26469;log&#20449;&#24687;
  // 3.&#21024;&#38500;&#19981;&#24517;&#35201;&#30340;&#25991;&#20214;
  // 4.&#36827;&#34892;compaction.
  if (s.ok()) {
    uint64_t new_log_number = impl-&gt;versions_-&gt;NewFileNumber();
    WritableFile* lfile;
    s = options.env-&gt;NewWritableFile(LogFileName(dbname, new_log_number),
                                     &amp;lfile);
    if (s.ok()) {
      edit.SetLogNumber(new_log_number);
      impl-&gt;logfile_ = lfile;
      impl-&gt;logfile_number_ = new_log_number;
      impl-&gt;log_ = new log::Writer(lfile);
      s = impl-&gt;versions_-&gt;LogAndApply(&amp;edit, &amp;impl-&gt;mutex_);
    }
    if (s.ok()) {
      impl-&gt;DeleteObsoleteFiles();
      impl-&gt;MaybeScheduleCompaction();
    }
  }
  // &#23558;&#20135;&#29983;&#30340;DB&#23545;&#35937;&#36820;&#22238;.
  impl-&gt;mutex_.Unlock();
  if (s.ok()) {
    *dbptr = impl;
  } else {
    delete impl;
  }
  return s;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-3-2" class="outline-6">
<h6 id="sec-1-10-3-3-2"><span class="section-number-6">1.10.3.3.2</span> DBImpl</h6>
<div class="outline-text-6" id="text-1-10-3-3-2">

<p>先看看构造函数
</p>


<pre class="src src-C++">DBImpl::DBImpl(const Options&amp; options, const std::string&amp; dbname)
    : env_(options.env),
      internal_comparator_(options.comparator),
      // &#27880;&#24847;&#36825;&#37324;&#30340;&#39034;&#24207;.&#24517;&#39035;&#20808;&#35843;&#29992;SanitizeOptions.
      options_(SanitizeOptions(dbname, &amp;internal_comparator_, options)),
      // &#21028;&#26029;&#26159;&#21542;&#33258;&#24049;&#25345;&#26377;info log&#21644;block cache.
      owns_info_log_(options_.info_log != options.info_log),
      owns_cache_(options_.block_cache != options.block_cache),
      dbname_(dbname),
      db_lock_(NULL),
      shutting_down_(NULL),
      bg_cv_(&amp;mutex_),
      // &#21019;&#24314;&#26032;&#30340;MemTable&#23545;&#35937;.
      mem_(new MemTable(internal_comparator_)),
      imm_(NULL),
      // &#36825;&#37324;log&#37117;&#26159;&#25351;db&#30340;log&#32780;&#19981;&#26159;&#31243;&#24207;log.
      logfile_(NULL),
      logfile_number_(0),
      log_(NULL),
      logger_(NULL),
      logger_cv_(&amp;mutex_),
      bg_compaction_scheduled_(false),
      manual_compaction_(NULL) {
  mem_-&gt;Ref();
  has_imm_.Release_Store(NULL);

  // Reserve ten files or so for other uses and give the rest to TableCache.
  const int table_cache_size = options.max_open_files - 10;
  // &#23545;&#20110;&#25991;&#20214;&#25551;&#36848;&#31526;&#38480;&#21046;&#21487;&#20197;&#36890;&#36807;TableCache&#26469;&#23436;&#25104;.&#19981;&#38169;:).
  table_cache_ = new TableCache(dbname_, &amp;options_, table_cache_size);
  // &#21019;&#24314;VersionSet.
  versions_ = new VersionSet(dbname_, &amp;options_, table_cache_,
                             &amp;internal_comparator_);
}
</pre>


<p>
然后看看析构函数
</p>


<pre class="src src-C++">DBImpl::~DBImpl() {
  // Wait for background work to finish
  mutex_.Lock();
  // &#35774;&#32622;shuting down&#26631;&#35760;.&#21518;&#21488;&#32447;&#31243;&#31561;&#24453;&#26631;&#35760;&#36864;&#20986;.
  // &#31561;&#24453;bg_compaction_scheduled_&#32622;&#20301;&#65292;&#36825;&#26679;bg&#32447;&#31243;&#23601;&#36864;&#20986;&#20102;&#12290;
  shutting_down_.Release_Store(this);  // Any non-NULL value is ok
  while (bg_compaction_scheduled_) {
    bg_cv_.Wait();
  }
  mutex_.Unlock();

  // &#37322;&#25918;db&#38145;&#25991;&#20214;.
  if (db_lock_ != NULL) {
    env_-&gt;UnlockFile(db_lock_);
  }

  // &#21024;&#38500;VersionSet.
  delete versions_;
  // &#37322;&#25918;&#24341;&#29992;&#35745;&#25968;
  if (mem_ != NULL) mem_-&gt;Unref();
  if (imm_ != NULL) imm_-&gt;Unref();
  // &#21024;&#38500;&#21487;&#33021;&#20135;&#29983;&#30340;log,logfile&#20197;&#21450;table_cache.
  delete log_;
  delete logfile_;
  delete table_cache_;

  // &#37322;&#25918;&#31243;&#24207;log&#20197;&#21450;cache.
  if (owns_info_log_) {
    delete options_.info_log;
  }
  if (owns_cache_) {
    delete options_.block_cache;
  }
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-3-3" class="outline-6">
<h6 id="sec-1-10-3-3-3"><span class="section-number-6">1.10.3.3.3</span> NewDB</h6>
<div class="outline-text-6" id="text-1-10-3-3-3">

<p>但从名字上我们不知道里面做了哪些事情，所以还是来看看代码.
通过代码阅读会发现，完成的事情大致就是建立一个Manifest文件，然后将这个版本的Manifest文件
的文件名作为内容写入CURRENT文件。Manifest文件里面包含的就是VersionEdit信息。VersionEdit
可以认为就是这个数据库的元信息。
</p>


<pre class="src src-C++">Status DBImpl::NewDB() {
  VersionEdit new_db;
  // &#21019;&#24314;&#26032;&#30340;VersionEdit.&#35774;&#32622;&#22909;comparator&#30340;&#21517;&#23383;&#20197;&#21450;&#24517;&#35201;&#23383;&#27573;
  // &#20851;&#20110;VersionEdit&#30340;&#20449;&#24687;&#20250;&#22312;&#21518;&#38754;&#20180;&#32454;&#20998;&#26512;.
  new_db.SetComparatorName(user_comparator()-&gt;Name());
  new_db.SetLogNumber(0); // &#20174;log number&#20174;0&#24320;&#22987;&#20998;&#37197;.
  new_db.SetNextFile(2);  // &#19979;&#19968;&#20010;number&#20174;2&#24320;&#22987;&#20998;&#37197;
  new_db.SetLastSequence(0);

  // &#21019;&#24314;&#26032;&#30340;Manifest&#25991;&#20214;.&#28982;&#21518;&#20316;&#20026;writable&#25991;&#20214;&#25171;&#24320;.
  // 1&#20998;&#37197;&#32473;manifest&#25991;&#20214;.
  const std::string manifest = DescriptorFileName(dbname_, 1);
  WritableFile* file;
  Status s = env_-&gt;NewWritableFile(manifest, &amp;file);
  if (!s.ok()) {
    return s;
  }
  // &#25991;&#20214;&#20316;&#20026;log&#26684;&#24335;&#25171;&#24320;.&#23558;VersionEdit&#24207;&#21015;&#21270;&#20043;&#21518;&#20316;&#20026;log&#20889;&#20837;.
  {
    log::Writer log(file);
    std::string record;
    new_db.EncodeTo(&amp;record);
    s = log.AddRecord(record);
    if (s.ok()) {
      s = file-&gt;Close();
    }
  }
  delete file;
  // &#28982;&#21518;&#23558;CURRENT&#37324;&#38754;&#30340;&#25991;&#20214;&#35774;&#32622;&#20026;&#29256;&#26412;1&#30340;manifest&#25991;&#20214;.
  if (s.ok()) {
    // Make <span style="color: #ffff00;">"CURRENT"</span> file that points to the new manifest file.
    s = SetCurrentFile(env_, dbname_, 1);
  } else {
    env_-&gt;DeleteFile(manifest);
  }
  return s;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-3-4" class="outline-6">
<h6 id="sec-1-10-3-3-4"><span class="section-number-6">1.10.3.3.4</span> Recover</h6>
<div class="outline-text-6" id="text-1-10-3-3-4">

<p>恢复状态并且将恢复对于version日志操作.
</p>


<pre class="src src-C++">Status DBImpl::Recover(VersionEdit* edit) {
  mutex_.AssertHeld();

  // Ignore error from CreateDir since the creation of the DB is
  // committed only when the descriptor is created, and this directory
  // may already exist from a previous failed creation attempt.
  env_-&gt;CreateDir(dbname_);
  assert(db_lock_ == NULL);
  Status s = env_-&gt;LockFile(LockFileName(dbname_), &amp;db_lock_);
  if (!s.ok()) {
    return s;
  }

  if (!env_-&gt;FileExists(CurrentFileName(dbname_))) {
    if (options_.create_if_missing) {
      s = NewDB(); // &#21019;&#24314;DB.
      if (!s.ok()) {
        return s;
      }
    } else {
      return Status::InvalidArgument(
          dbname_, <span style="color: #ffff00;">"does not exist (create_if_missing is false)"</span>);
    }
  } else {
    if (options_.error_if_exists) {
      return Status::InvalidArgument(
          dbname_, <span style="color: #ffff00;">"exists (error_if_exists is true)"</span>);
    }
  }

  s = versions_-&gt;Recover(); // &#23545;&#20110;VersionSet&#39318;&#20808;&#36827;&#34892;&#24674;&#22797;.
  // &#24674;&#22797;&#20043;&#21518;,&#26681;&#25454;&#37324;&#38754;&#30340;&#20869;&#23481;&#28982;&#21518;&#35835;&#21462;&#37324;&#38754;&#23545;&#24212;&#30340;version edit&#20869;&#23481;.
  // &#19981;&#36807;&#20174;versionset&#30340;Recover&#26041;&#27861;&#26469;&#30475;&#30340;&#35805;&#37324;&#38754;&#25152;&#26377;&#30340;&#20869;&#23481;&#24050;&#32463;&#20840;&#37096;&#24674;&#22797;&#20102;.
  // &#21518;&#38754;edit&#30340;&#20869;&#23481;&#26159;&#22240;&#20026;&#22312;&#24674;&#22797;log&#37324;&#38754;&#30340;&#20869;&#23481;&#36896;&#25104;&#30340;.&#28982;&#21518;&#23558;&#36825;&#20010;&#37096;&#20998;&#36896;&#25104;&#30340;edit
  // &#20043;&#21518;&#35843;&#29992;LogAndApply.
  if (s.ok()) {
    SequenceNumber max_sequence(0);

    // Recover from all newer log files than the ones named in the
    // descriptor (new log files may have been added by the previous
    // incarnation without registering them in the descriptor).
    //
    // Note that PrevLogNumber() is no longer used, but we pay
    // attention to it in case we are recovering a database
    // produced by an older version of leveldb.
    // &#20174;&#27880;&#37322;&#36825;&#37324;&#30475;&#20197;&#30475;&#20986;prev_log&#24050;&#32463;&#19981;&#36866;&#29992;&#20102;.
    const uint64_t min_log = versions_-&gt;LogNumber();
    const uint64_t prev_log = versions_-&gt;PrevLogNumber();
    std::vector&lt;std::string&gt; filenames;
    s = env_-&gt;GetChildren(dbname_, &amp;filenames);
    if (!s.ok()) {
      return s;
    }
    uint64_t number;
    FileType type;
    std::vector&lt;uint64_t&gt; logs;
    // &#20998;&#26512;logs&#25991;&#20214;&#28982;&#21518;&#21028;&#26029;&#21738;&#20123;log&#25991;&#20214;&#26159;&#21518;&#26469;&#36861;&#21152;&#25105;&#20204;&#38656;&#35201;&#37325;&#25918;&#30340;.
    for (size_t i = 0; i &lt; filenames.size(); i++) {
      if (ParseFileName(filenames[i], &amp;number, &amp;type)
          &amp;&amp; type == kLogFile
          &amp;&amp; ((number &gt;= min_log) || (number == prev_log))) {
        logs.push_back(number);
      }
    }

    // Recover in the order in which the logs were generated
    // &#25353;&#29031;&#39034;&#24207;&#36827;&#34892;&#37325;&#25918;.
    std::sort(logs.begin(), logs.end());
    for (size_t i = 0; i &lt; logs.size(); i++) {
      // &#24674;&#22797;&#26576;&#20010;log&#25991;&#20214;.&#24182;&#19988;&#23558;&#37324;&#38754;&#30340;&#25805;&#20316;&#20462;&#25913;&#22635;&#20889;&#21040;edit
      // &#21516;&#26102;&#30693;&#36947;&#24403;&#21069;&#26368;&#22823;&#30340;sequence&#26159;&#22810;&#23569;.
      s = RecoverLogFile(logs[i], edit, &amp;max_sequence);

      // The previous incarnation may not have written any MANIFEST
      // records after allocating this log number.  So we manually
      // update the file number allocation counter in VersionSet.
      // &#26631;&#35760;file number&#24050;&#32463;&#34987;&#20351;&#29992;&#20102;.
      versions_-&gt;MarkFileNumberUsed(logs[i]);
    }

    if (s.ok()) {
      // &#26356;&#26032;&#19968;&#19979;sequence number.
      if (versions_-&gt;LastSequence() &lt; max_sequence) {
        versions_-&gt;SetLastSequence(max_sequence);
      }
    }
  }

  return s;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-3-5" class="outline-6">
<h6 id="sec-1-10-3-3-5"><span class="section-number-6">1.10.3.3.5</span> RecoverLogFile</h6>
<div class="outline-text-6" id="text-1-10-3-3-5">

<p>从单个log恢复写入的内容.并且根据log里面内容了解到对于version修改以及max_sequence.
</p>


<pre class="src src-C++">Status DBImpl::RecoverLogFile(uint64_t log_number,
                              VersionEdit* edit,
                              SequenceNumber* max_sequence) {
  struct LogReporter : public log::Reader::Reporter {
    Env* env;
    Logger* info_log;
    const char* fname;
    Status* status;  // NULL if options_.paranoid_checks==false
    virtual void Corruption(size_t bytes, const Status&amp; s) {
      Log(info_log, <span style="color: #ffff00;">"%s%s: dropping %d bytes; %s"</span>,
          (this-&gt;status == NULL ? <span style="color: #ffff00;">"(ignoring error) "</span> : <span style="color: #ffff00;">""</span>),
          fname, static_cast&lt;int&gt;(bytes), s.ToString().c_str());
      if (this-&gt;status != NULL &amp;&amp; this-&gt;status-&gt;ok()) *this-&gt;status = s;
    }
  };

  mutex_.AssertHeld();

  // &#25171;&#24320;&#26085;&#24535;&#25991;&#20214;
  // Open the log file
  std::string fname = LogFileName(dbname_, log_number);
  SequentialFile* file;
  Status status = env_-&gt;NewSequentialFile(fname, &amp;file);
  if (!status.ok()) {
    MaybeIgnoreError(&amp;status);
    return status;
  }

  // &#26500;&#36896;reporter&#23545;&#35937;.
  // Create the log reader.
  LogReporter reporter;
  reporter.env = env_;
  reporter.info_log = options_.info_log;
  reporter.fname = fname.c_str();
  reporter.status = (options_.paranoid_checks ? &amp;status : NULL);
  // We intentially make log::Reader do checksumming even if
  // paranoid_checks==false so that corruptions cause entire commits
  // to be skipped instead of propagating bad information (like overly
  // large sequence numbers).
  // &#35835;&#21462;&#26085;&#24535;&#25991;&#20214;.&#20570;&#26657;&#39564;&#24182;&#19988;&#20174;0&#20559;&#31227;&#24320;&#22987;&#35835;&#21462;.
  log::Reader reader(file, &amp;reporter, true/*checksum*/,
                     0/*initial_offset*/);
  Log(options_.info_log, <span style="color: #ffff00;">"Recovering log #%llu"</span>,
      (unsigned long long) log_number);

  // Read all the records and add to a memtable
  std::string scratch;
  Slice record;
  WriteBatch batch;
  MemTable* mem = NULL;
  // &#19981;&#26029;&#22320;&#35835;&#21462;
  while (reader.ReadRecord(&amp;record, &amp;scratch) &amp;&amp;
         status.ok()) {
    if (record.size() &lt; 12) {
      reporter.Corruption(
          record.size(), Status::Corruption(<span style="color: #ffff00;">"log record too small"</span>));
      continue;
    }
    // log&#37324;&#38754;&#37117;&#26159;write batch&#30340;&#20869;&#23481;
    // &#25152;&#20197;&#21487;&#20197;&#30452;&#25509;&#35774;&#32622;.
    WriteBatchInternal::SetContents(&amp;batch, record);

    if (mem == NULL) {
      // &#21019;&#24314;mem table.
      mem = new MemTable(internal_comparator_);
      mem-&gt;Ref();
    }
    status = WriteBatchInternal::InsertInto(&amp;batch, mem);
    // &#23545;&#20110;&#26085;&#24535;&#24674;&#22797;&#30340;&#35805;&#25105;&#20204;&#20063;&#21487;&#20197;&#36873;&#25321;&#24615;&#22320;&#36827;&#34892;status&#21028;&#26029;&#26816;&#26597;.
    MaybeIgnoreError(&amp;status);
    if (!status.ok()) {
      break;
    }
    // &#26356;&#26032;sequence.
    const SequenceNumber last_seq =
        WriteBatchInternal::Sequence(&amp;batch) +
        WriteBatchInternal::Count(&amp;batch) - 1;
    if (last_seq &gt; *max_sequence) {
      *max_sequence = last_seq;
    }

    // &#22914;&#26524;&#21344;&#29992;&#20869;&#23384;&#22823;&#20110;&#36825;&#20010;&#22823;&#23567;&#30340;&#35805;&#37027;&#20040;&#23601;&#20250;&#20889;level0.
    if (mem-&gt;ApproximateMemoryUsage() &gt; options_.write_buffer_size) {
      status = WriteLevel0Table(mem, edit, NULL);
      if (!status.ok()) {
        // Reflect errors immediately so that conditions like full
        // file-systems cause the DB::Open() to fail.
        break;
      }
      mem-&gt;Unref();
      mem = NULL;
    }
  }

  // &#21097;&#19979;&#30340;&#20869;&#23384;&#25991;&#20214;&#20063;&#20250;&#20570;table.
  if (status.ok() &amp;&amp; mem != NULL) {
    status = WriteLevel0Table(mem, edit, NULL);
    // Reflect errors immediately so that conditions like full
    // file-systems cause the DB::Open() to fail.
  }

  if (mem != NULL) mem-&gt;Unref();
  delete file;
  return status;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-3-6" class="outline-6">
<h6 id="sec-1-10-3-3-6"><span class="section-number-6">1.10.3.3.6</span> MaybeIgnoreError</h6>
<div class="outline-text-6" id="text-1-10-3-3-6">

<p>这个是在日志恢复部分是否进行错误恢复.
</p>


<pre class="src src-C++">void DBImpl::MaybeIgnoreError(Status* s) const {
  if (s-&gt;ok() || options_.paranoid_checks) {
    // No change needed
  } else {
    Log(options_.info_log, <span style="color: #ffff00;">"Ignoring error %s"</span>, s-&gt;ToString().c_str());
    *s = Status::OK();
  }
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-3-7" class="outline-6">
<h6 id="sec-1-10-3-3-7"><span class="section-number-6">1.10.3.3.7</span> WriteLevel0Table</h6>
<div class="outline-text-6" id="text-1-10-3-3-7">

<p>将memtable写到level0.不过现在就实现来看的话不一定是写到level0.对于产生或者是删除的文件等
对于version的操作都会反映到edit里面
</p>


<pre class="src src-C++">Status DBImpl::WriteLevel0Table(MemTable* mem, VersionEdit* edit,
                                Version* base) {
  mutex_.AssertHeld();
  // &#20250;&#38024;&#23545;&#36825;&#20010;&#25805;&#20316;&#36827;&#34892;&#35745;&#26102;.
  const uint64_t start_micros = env_-&gt;NowMicros();
  FileMetaData meta;
  // &#20135;&#29983;&#26032;&#30340;file number.
  meta.number = versions_-&gt;NewFileNumber();
  //
  pending_outputs_.insert(meta.number);
  Iterator* iter = mem-&gt;NewIterator();
  Log(options_.info_log, <span style="color: #ffff00;">"Level-0 table #%llu: started"</span>,
      (unsigned long long) meta.number);

  Status s;
  {
    mutex_.Unlock();
    // &#27880;&#24847;&#20889;&#30913;&#30424;&#30340;&#26102;&#20505;&#27809;&#26377;&#24517;&#35201;&#21152;&#38145;.
    s = BuildTable(dbname_, env_, options_, table_cache_, iter, &amp;meta);
    mutex_.Lock();
  }

  Log(options_.info_log, <span style="color: #ffff00;">"Level-0 table #%llu: %lld bytes %s"</span>,
      (unsigned long long) meta.number,
      (unsigned long long) meta.file_size,
      s.ToString().c_str());
  delete iter;
  pending_outputs_.erase(meta.number);


  // Note that if file_size is zero, the file has been deleted and
  // should not be added to the manifest.
  int level = 0;
  if (s.ok() &amp;&amp; meta.file_size &gt; 0) {
    const Slice min_user_key = meta.smallest.user_key();
    const Slice max_user_key = meta.largest.user_key();
    if (base != NULL) {
      // &#22914;&#26524;&#23384;&#22312;base version&#30340;&#35805;
      // &#37027;&#20040;&#20250;&#26681;&#25454;base version&#20197;&#21450;range&#26469;&#36873;&#25321;&#26032;&#30340;level&#36827;&#34892;&#24207;&#21015;&#21270;.
      level = base-&gt;PickLevelForMemTableOutput(min_user_key, max_user_key);
    }
    edit-&gt;AddFile(level, meta.number, meta.file_size,
                  meta.smallest, meta.largest);
  }

  CompactionStats stats;
  stats.micros = env_-&gt;NowMicros() - start_micros;
  stats.bytes_written = meta.file_size;
  // &#20462;&#25913;&#36825;&#20010;level&#30340;compaction&#25968;&#25454;.
  stats_[level].Add(stats);
  return s;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-3-8" class="outline-6">
<h6 id="sec-1-10-3-3-8"><span class="section-number-6">1.10.3.3.8</span> Put</h6>
<div class="outline-text-6" id="text-1-10-3-3-8">




<pre class="src src-C++">Status DBImpl::Put(const WriteOptions&amp; o, const Slice&amp; key, const Slice&amp; val) {
  return DB::Put(o, key, val);
}
Status DB::Put(const WriteOptions&amp; opt, const Slice&amp; key, const Slice&amp; value) {
  WriteBatch batch;
  batch.Put(key, value); // &#23558;&#20869;&#23481;&#20889;&#21040;WriteBatch&#37324;&#38754;.&#28982;&#21518;&#36890;&#36807;
  return Write(opt, &amp;batch); // Write&#20889;&#20837;&#21040;db&#20869;&#37096;.
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-3-9" class="outline-6">
<h6 id="sec-1-10-3-3-9"><span class="section-number-6">1.10.3.3.9</span> Delete</h6>
<div class="outline-text-6" id="text-1-10-3-3-9">




<pre class="src src-C++">Status DBImpl::Delete(const WriteOptions&amp; options, const Slice&amp; key) {
  return DB::Delete(options, key);
}
Status DB::Delete(const WriteOptions&amp; opt, const Slice&amp; key) {
  WriteBatch batch;
  batch.Delete(key); // &#23558;&#21024;&#38500;&#20869;&#23481;&#20889;&#21040;WriteBatch&#37324;&#38754;&#65292;&#28982;&#21518;&#36890;&#36807;
  return Write(opt, &amp;batch); // Write&#20889;&#20837;&#21040;db&#20869;&#37096;.
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-3-10" class="outline-6">
<h6 id="sec-1-10-3-3-10"><span class="section-number-6">1.10.3.3.10</span> LoggingResponsibility</h6>
<div class="outline-text-6" id="text-1-10-3-3-10">

<p>对于Log信息的打印的话确保每次只有一个实例在操作.这里logger_cv和mutex_关联起来的.可以看到
在调用AcquireLoggingResponsibility的地方之前都会加锁
</p>


<pre class="src src-C++">// There is at most one thread that is the current logger.  This call
// waits until preceding logger(s) have finished and becomes the
// current logger.
void DBImpl::AcquireLoggingResponsibility(LoggerId* self) {
  while (logger_ != NULL) {
    logger_cv_.Wait();
  }
  logger_ = self;
}
</pre>


<p>
而ReleaseLoggingResponsibility是释放logger的所有权.注意这里我们不会去主动操作解锁而是外部解锁。
</p>


<pre class="src src-C++">void DBImpl::ReleaseLoggingResponsibility(LoggerId* self) {
  assert(logger_ == self);
  logger_ = NULL;
  logger_cv_.SignalAll();
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-3-11" class="outline-6">
<h6 id="sec-1-10-3-3-11"><span class="section-number-6">1.10.3.3.11</span> MakeRoomForWrite</h6>
<div class="outline-text-6" id="text-1-10-3-3-11">

<p>仅仅从函数名称上面开不出到底是开辟什么空间.看看实现吧.代码里面可以分析出这个部分是存在compaction的.
我们这里稍微总结一下逻辑
</p><ul>
<li>如果允许delay的话并且level0文件数目超过slowdown的阈值的话，那么就会先尝试delay 1s.下次不会进行delay
</li>
<li>如果不是force的话并且memtable空间允许的话那么直接返回
</li>
<li>剩下的逻辑就是force出一个memtable了.那么这个时候必须进行compaction to level0.
</li>
<li>先检查是否正在被memtable compaction.如果正在的话那么等待
</li>
<li>然后查看level0文件数目是否过多.如果过多的话那么也等待
</li>
<li>最后创建新的memtable以及logfile.将原来的memtable保存起来准备后台compaction
</li>
<li>发起compaction.并且force=false.
</li>
</ul>

<p>按照性能角度出发的话，这种逻辑应该非常make sense.
</p>


<pre class="src src-C++">// REQUIRES: mutex_ is held
// REQUIRES: this thread is the current logger
Status DBImpl::MakeRoomForWrite(bool force) {
  mutex_.AssertHeld();
  assert(logger_ != NULL);
  bool allow_delay = !force; // &#22914;&#26524;&#35774;&#32622;force&#30340;&#35805;
  // &#22914;&#26524;&#31354;&#38388;&#19981;&#22815;&#30340;&#35805;&#37027;&#20040;&#23601;&#20250;&#21457;&#36215;compaction&#25805;&#20316;
  // &#28982;&#21518;&#31561;&#24453;compaction&#25805;&#20316;&#23436;&#25104;&#30475;&#31354;&#38388;&#26159;&#21542;&#36275;&#22815;.
  Status s;
  while (true) {
    // &#22914;&#26524;&#21518;&#21488;&#23384;&#22312;&#38169;&#35823;&#30340;&#35805;&#37027;&#20040;&#30452;&#25509;&#36820;&#22238;.
    if (!bg_error_.ok()) {
      // yield previous error
      s = bg_error_;
      break;
    } else if (
        allow_delay &amp;&amp;
        versions_-&gt;NumLevelFiles(0) &gt;= config::kL0_SlowdownWritesTrigger) {
      // We are getting close to hitting a hard limit on the number of
      // L0 files.  Rather than delaying a single write by several
      // seconds when we hit the hard limit, start delaying each
      // individual write by 1ms to reduce latency variance.  Also,
      // this delay hands over some CPU to the compaction thread in
      // case it is sharing the same core as the writer.
      mutex_.Unlock();
      env_-&gt;SleepForMicroseconds(1000); // &#24310;&#36831;1s&#26469;&#30475;level0&#25991;&#20214;&#20010;&#25968;.
      allow_delay = false;  // Do not delay a single write more than once
      mutex_.Lock();
    } else if (!force &amp;&amp;
               (mem_-&gt;ApproximateMemoryUsage() &lt;= options_.write_buffer_size)) {
      // &#22914;&#26524;memtable&#20801;&#35768;&#20889;&#20837;&#30340;&#35805;&#37027;&#20040;&#27809;&#26377;&#20219;&#20309;&#38382;&#39064;.
      // There is room in current memtable
      break;
    } else if (imm_ != NULL) {
      // We have filled up the current memtable, but the previous
      // one is still being compacted, so we wait.
      // imm_&#24212;&#35813;&#26159;&#34920;&#31034;&#27491;&#22312;&#36827;&#34892;compact&#30340;memtable.
      // &#36825;&#37324;&#25105;&#25285;&#24515;condition&#26159;&#36793;&#32536;&#35302;&#21457;&#32780;&#19981;&#26159;&#27700;&#24179;&#35302;&#21457;&#30340;&#35805;&#37027;&#20040;signal&#23601;&#20250;&#20002;&#22833;.
      bg_cv_.Wait();
    } else if (versions_-&gt;NumLevelFiles(0) &gt;= config::kL0_StopWritesTrigger) {
      // There are too many level-0 files.
      // level0&#25991;&#20214;&#20010;&#25968;&#36807;&#22810;&#30340;&#35805;&#37027;&#20040;&#31561;&#24453;compaction&#30340;&#23436;&#25104;.
      // NOTE(dirlt):&#36825;&#20010;&#37096;&#20998;&#38750;&#24120;&#37325;&#35201;&#65292;&#36825;&#26679;&#21487;&#20197;&#38480;&#21046;&#20889;&#20837;&#36895;&#24230;&#20445;&#35777;&#31995;&#32479;balance.
      Log(options_.info_log, <span style="color: #ffff00;">"waiting...\n"</span>);
      bg_cv_.Wait();
    } else {
      // Attempt to switch to a new memtable and trigger compaction of old
      // &#35797;&#22270;&#21019;&#24314;&#19968;&#20010;&#26032;&#30340;memtable&#29992;&#26469;&#20889;.&#21019;&#24314;memtable&#30340;&#35805;&#21516;&#26102;&#20063;&#21019;&#24314;&#19968;&#20010;log&#25991;&#20214;.
      assert(versions_-&gt;PrevLogNumber() == 0);
      uint64_t new_log_number = versions_-&gt;NewFileNumber();
      WritableFile* lfile = NULL;
      s = env_-&gt;NewWritableFile(LogFileName(dbname_, new_log_number), &amp;lfile);
      if (!s.ok()) {
        break;
      }
      // &#38144;&#27585;&#21407;&#26469;&#30340;log&#25991;&#20214;b&#24182;&#19988;&#21019;&#24314;&#26032;&#30340;memtable.
      // &#26032;memtable&#23384;&#25918;&#22312;imm&#37324;&#38754;.&#21518;&#21488;&#24212;&#35813;&#26159;&#23558;imm&#36827;&#34892;compaction&#25110;&#32773;&#26159;level disk files&#20043;&#38388;&#36827;&#34892;compaction.
      delete log_;
      delete logfile_;
      logfile_ = lfile;
      logfile_number_ = new_log_number;
      log_ = new log::Writer(lfile);
      imm_ = mem_; // &#23558;&#21407;&#26469;&#30340;mem_&#23384;&#25918;&#36215;&#26469;.
      has_imm_.Release_Store(imm_); // imm&#23384;&#22312;&#26631;&#35760;.
      mem_ = new MemTable(internal_comparator_); // &#26032;&#21019;&#24314;memtable.
      mem_-&gt;Ref();
      force = false;   // Do not force another compaction if have room
      MaybeScheduleCompaction(); // &#23581;&#35797;&#36827;&#34892;compaction.&#36825;&#20010;&#20989;&#25968;&#25105;&#20204;&#21518;&#38754;&#20998;&#26512;.
    }
  }
  return s;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-3-12" class="outline-6">
<h6 id="sec-1-10-3-3-12"><span class="section-number-6">1.10.3.3.12</span> MaybeScheduleCompaction</h6>
<div class="outline-text-6" id="text-1-10-3-3-12">

<p>发起compaction调度.
</p>


<pre class="src src-C++">void DBImpl::MaybeScheduleCompaction() {
  mutex_.AssertHeld();
  if (bg_compaction_scheduled_) { // &#22914;&#26524;&#24050;&#32463;&#34987;&#35843;&#24230;&#30340;&#35805;.&#37027;&#20040;&#27809;&#26377;&#24517;&#35201;&#20135;&#33021;&#37325;&#26032;&#21457;&#36215;.
    // Already scheduled
  } else if (shutting_down_.Acquire_Load()) { // &#22914;&#26524;&#24050;&#32463;&#20851;&#38381;&#30340;&#35805;&#37027;&#20040;&#24573;&#30053;.
    // DB is being deleted; no more background compactions
  } else if (imm_ == NULL &amp;&amp; // &#22914;&#26524;memtable&#27809;&#26377;
             manual_compaction_ == NULL &amp;&amp; // &#22914;&#26524;&#27809;&#26377;&#20154;&#24037;compaction
             !versions_-&gt;NeedsCompaction()) { // &#22914;&#26524;leveldb&#26412;&#36523;&#20063;&#27809;&#26377;&#24517;&#35201;&#35748;&#20026;compaction.
    // No work to be done
  } else {
    // compaction&#20043;&#21069;&#26631;&#35760;
    bg_compaction_scheduled_ = true;
    // &#24182;&#19988;&#36825;&#20010;&#26102;&#20505;&#21457;&#36215;compaction&#25805;&#20316;.&#36825;&#20010;&#21518;&#38754;&#20250;&#20180;&#32454;&#20998;&#26512;BGWork&#36825;&#20010;&#36807;&#31243;.
    // BGWork&#26159;pthread_create&#23553;&#35013;&#30340;&#25509;&#21475;&#65292;&#37324;&#38754;&#20165;&#20165;&#26159;&#35843;&#29992;&#20102;BackgroundCall&#36825;&#20010;&#20989;&#25968;.
    env_-&gt;Schedule(&amp;DBImpl::BGWork, this);
  }
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-3-13" class="outline-6">
<h6 id="sec-1-10-3-3-13"><span class="section-number-6">1.10.3.3.13</span> BackgroundCall</h6>
<div class="outline-text-6" id="text-1-10-3-3-13">




<pre class="src src-C++">void DBImpl::BackgroundCall() {
  MutexLock l(&amp;mutex_);
  assert(bg_compaction_scheduled_);
  if (!shutting_down_.Acquire_Load()) { // &#22914;&#26524;&#27809;&#26377;&#20851;&#38381;&#30340;&#35805;.
    BackgroundCompaction(); // &#37027;&#20040;&#20250;&#35843;&#29992;&#36825;&#20010;&#20989;&#25968;&#21457;&#36215;compaction.
  }
  bg_compaction_scheduled_ = false;

  // Previous compaction may have produced too many files in a level,
  // so reschedule another compaction if needed.
  MaybeScheduleCompaction(); // &#36825;&#37324;&#21487;&#33021;&#20250;&#37325;&#26032;&#21457;&#36215;compaction.
  bg_cv_.SignalAll();
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-3-14" class="outline-6">
<h6 id="sec-1-10-3-3-14"><span class="section-number-6">1.10.3.3.14</span> BackgroundCompaction</h6>
<div class="outline-text-6" id="text-1-10-3-3-14">

<p>这个部分是真正进行compaction的部分.我们仔细分析其中的行为.
</p>


<pre class="src src-C++">void DBImpl::BackgroundCompaction() {
  mutex_.AssertHeld();

  // &#20174;&#20195;&#30721;&#23454;&#29616;&#19978;&#26469;&#30475;&#30340;&#35805;&#65292;&#22914;&#26524;&#30495;&#23454;&#22320;&#36827;&#34892;compaction&#30340;&#35805;
  // &#23545;&#20110;version&#36896;&#25104;&#30340;&#20462;&#25913;&#37117;&#20250;&#35760;&#24405;&#20026;edit,&#28982;&#21518;&#35843;&#29992;VersionSet::LogAndApply&#20445;&#23384;&#36215;&#26469;.
  if (imm_ != NULL) {
    CompactMemTable(); // &#22914;&#26524;imm!=NULL&#30340;&#35805;&#37027;&#20040;&#39318;&#20808;&#23545;imm&#36827;&#34892;compaction.
    return;
  }

  // &#27880;&#24847;&#36825;&#37324;imm_==NULL.
  Compaction* c;
  bool is_manual = (manual_compaction_ != NULL);
  InternalKey manual_end;
  if (is_manual) {
    // &#22914;&#26524;&#26159;manual compaction&#30340;&#35805;
    // &#37027;&#20040;compaction&#37324;&#38754;&#38656;&#35201;&#25552;&#20379;level&#20197;&#21450;range.
    // &#20294;&#26159;&#25105;&#29468;&#24819;&#20165;&#20165;&#26159;&#23558;&#36825;&#20010;compaction&#25552;&#20379;&#19968;&#20010;&#21253;&#35013;&#20449;&#24687;&#20986;&#26469;
    // &#20855;&#20307;&#25805;&#20316;&#24310;&#36831;&#21040;&#21518;&#38754;&#36827;&#34892;.
    ManualCompaction* m = manual_compaction_;
    c = versions_-&gt;CompactRange(m-&gt;level, m-&gt;begin, m-&gt;end);
    m-&gt;done = (c == NULL);
    if (c != NULL) {
      manual_end = c-&gt;input(0, c-&gt;num_input_files(0) - 1)-&gt;largest;
    }
    Log(options_.info_log,
        <span style="color: #ffff00;">"Manual compaction at level-%d from %s .. %s; will stop at %s\n"</span>,
        m-&gt;level,
        (m-&gt;begin ? m-&gt;begin-&gt;DebugString().c_str() : <span style="color: #ffff00;">"(begin)"</span>),
        (m-&gt;end ? m-&gt;end-&gt;DebugString().c_str() : <span style="color: #ffff00;">"(end)"</span>),
        (m-&gt;done ? <span style="color: #ffff00;">"(end)"</span> : manual_end.DebugString().c_str()));
  } else { // &#22914;&#26524;&#19981;&#26159;manual compaction&#37027;&#20040;&#25361;&#36873;&#19968;&#20010;&#20986;&#26469;.
    c = versions_-&gt;PickCompaction();
  }

  Status status;
  if (c == NULL) {
    // Nothing to do
  } else if (!is_manual &amp;&amp; c-&gt;IsTrivialMove()) {
    // Move file to next level
    assert(c-&gt;num_input_files(0) == 1);
    FileMetaData* f = c-&gt;input(0, 0);
    c-&gt;edit()-&gt;DeleteFile(c-&gt;level(), f-&gt;number);
    c-&gt;edit()-&gt;AddFile(c-&gt;level() + 1, f-&gt;number, f-&gt;file_size,
                       f-&gt;smallest, f-&gt;largest);
    status = versions_-&gt;LogAndApply(c-&gt;edit(), &amp;mutex_);
    VersionSet::LevelSummaryStorage tmp;
    Log(options_.info_log, <span style="color: #ffff00;">"Moved #%lld to level-%d %lld bytes %s: %s\n"</span>,
        static_cast&lt;unsigned long long&gt;(f-&gt;number),
        c-&gt;level() + 1,
        static_cast&lt;unsigned long long&gt;(f-&gt;file_size),
        status.ToString().c_str(),
        versions_-&gt;LevelSummary(&amp;tmp));
  } else { // &#23558;compaction&#20449;&#24687;&#21253;&#35013;&#31216;&#20026;state&#36827;&#34892;&#25805;&#20316;.
    CompactionState* compact = new CompactionState(c);
    status = DoCompactionWork(compact);
    CleanupCompaction(compact);
  }
  delete c;

  if (status.ok()) {
    // Done
  } else if (shutting_down_.Acquire_Load()) {
    // Ignore compaction errors found during shutting down
  } else {
    Log(options_.info_log,
        <span style="color: #ffff00;">"Compaction error: %s"</span>, status.ToString().c_str());
    if (options_.paranoid_checks &amp;&amp; bg_error_.ok()) {
      bg_error_ = status;
    }
  }

  if (is_manual) { // &#22914;&#26524;&#26159;manual_compaction&#30340;&#35805;&#37027;&#20040;&#25105;&#20204;
    // &#26377;&#26041;&#27861;&#21487;&#20197;&#30693;&#36947;&#36825;&#27425;manual compaction&#23454;&#38469;&#25805;&#20316;&#33539;&#22260;&#26377;&#22810;&#23569;.
    // &#23454;&#38469;&#33539;&#22260;&#23601;&#26159;range&#25152;&#23545;&#24212;&#25991;&#20214;&#30340;largest key.:).&#36825;&#20010;&#20043;&#21069;&#21487;&#20197;&#30475;&#21040;.
    ManualCompaction* m = manual_compaction_;
    if (!m-&gt;done) {
      // We only compacted part of the requested range.  Update *m
      // to the range that is left to be compacted.
      m-&gt;tmp_storage = manual_end;
      m-&gt;begin = &amp;m-&gt;tmp_storage;
    }
    manual_compaction_ = NULL;
  }
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-3-15" class="outline-6">
<h6 id="sec-1-10-3-3-15"><span class="section-number-6">1.10.3.3.15</span> CompactMemTable</h6>
<div class="outline-text-6" id="text-1-10-3-3-15">

<p>对memtable进行compaction.注意这里针对的对象是imm_.mem对象是write操作的对象.
</p>


<pre class="src src-C++">Status DBImpl::CompactMemTable() {
  mutex_.AssertHeld();
  assert(imm_ != NULL);

  // Save the contents of the memtable as a new Table
  VersionEdit edit;
  Version* base = versions_-&gt;current();
  base-&gt;Ref();
  Status s = WriteLevel0Table(imm_, &amp;edit, base);
  base-&gt;Unref();

  if (s.ok() &amp;&amp; shutting_down_.Acquire_Load()) {
    s = Status::IOError(<span style="color: #ffff00;">"Deleting DB during memtable compaction"</span>);
  }

  // Replace immutable memtable with the generated Table
  if (s.ok()) {
    // &#19968;&#26086;&#36825;&#20010;memtable&#36827;&#34892;compaction&#23436;&#25104;&#20043;&#21518;
    // &#37027;&#20040;&#23601;&#21487;&#20197;&#35748;&#20026;&#36825;&#20010;log file number&#19981;&#38656;&#35201;&#20102;.
    // &#23558;&#36825;&#20010;&#20449;&#24687;&#35760;&#24405;&#22312;version edit&#37324;&#38754;.
    edit.SetPrevLogNumber(0);
    edit.SetLogNumber(logfile_number_);  // Earlier logs no longer needed
    s = versions_-&gt;LogAndApply(&amp;edit, &amp;mutex_);
  }

  // &#28982;&#21518;&#37322;&#25918;imm&#36825;&#20010;&#20869;&#23384;&#24182;&#19988;&#21024;&#38500;&#22810;&#20313;&#25991;&#20214;.
  if (s.ok()) {
    // Commit to the new state
    imm_-&gt;Unref();
    imm_ = NULL;
    has_imm_.Release_Store(NULL);
    DeleteObsoleteFiles();
  }

  return s;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-3-16" class="outline-6">
<h6 id="sec-1-10-3-3-16"><span class="section-number-6">1.10.3.3.16</span> CompactRange</h6>
<div class="outline-text-6" id="text-1-10-3-3-16">

<p>这个语义应该是针对某个range来进行compaction的.
</p><ul>
<li>首先查看和这些range存在overlap的最大level是多少
</li>
<li>首先对memtable进行compaction(不管是否存在overlap)(TEST_CompactMemTable)
</li>
<li>然后遍历这些level,分别对每层进行compact range.(TEST_CompactRange)
</li>
</ul>




<pre class="src src-C++">void DBImpl::CompactRange(const Slice* begin, const Slice* end) {
  int max_level_with_files = 1;
  {
    MutexLock l(&amp;mutex_);
    Version* base = versions_-&gt;current();
    for (int level = 1; level &lt; config::kNumLevels; level++) {
      if (base-&gt;OverlapInLevel(level, begin, end)) {
        max_level_with_files = level;
      }
    }
  }
  TEST_CompactMemTable(); // TODO(sanjay): Skip if memtable does not overlap
  for (int level = 0; level &lt; max_level_with_files; level++) {
    TEST_CompactRange(level, begin, end);
  }
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-3-17" class="outline-6">
<h6 id="sec-1-10-3-3-17"><span class="section-number-6">1.10.3.3.17</span> TEST_CompactMemTable</h6>
<div class="outline-text-6" id="text-1-10-3-3-17">




<pre class="src src-C++">Status DBImpl::TEST_CompactMemTable() {
  MutexLock l(&amp;mutex_);
  LoggerId self;
  AcquireLoggingResponsibility(&amp;self);
  // &#36825;&#37324;&#24212;&#35813;&#26159;&#35201;&#27714;imm==NULL&#20063;&#23601;&#26159;&#35828;&#27809;&#26377;memtable&#22312;&#36827;&#34892;compaction&#30340;.
  // &#37027;&#20040;&#36825;&#26679;&#30340;&#34892;&#20026;&#38750;&#24120;&#26126;&#26174;&#23601;&#26159;&#24076;&#26395;mem&#37325;&#26032;&#24320;&#36767;
  // &#23558;&#21407;&#26469;&#30340;mem&#36827;&#34892;compaction
  Status s = MakeRoomForWrite(true /* force compaction */);
  ReleaseLoggingResponsibility(&amp;self);
  if (s.ok()) {
    // Wait until the compaction completes
    // &#24182;&#19988;&#31561;&#24453;memtable compaction&#32467;&#26463;.
    while (imm_ != NULL &amp;&amp; bg_error_.ok()) {
      bg_cv_.Wait();
    }
    if (imm_ != NULL) {
      s = bg_error_;
    }
  }
  return s;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-3-18" class="outline-6">
<h6 id="sec-1-10-3-3-18"><span class="section-number-6">1.10.3.3.18</span> TEST_CompactRange</h6>
<div class="outline-text-6" id="text-1-10-3-3-18">

<p>针对某个Level来进行range compaction.
</p>


<pre class="src src-C++">void DBImpl::TEST_CompactRange(int level, const Slice* begin,const Slice* end) {
  assert(level &gt;= 0);
  assert(level + 1 &lt; config::kNumLevels);

  InternalKey begin_storage, end_storage;

  ManualCompaction manual;
  manual.level = level; // level
  manual.done = false; // &#26159;&#21542;&#24050;&#32463;&#23436;&#25104;.
  if (begin == NULL) { // &#36873;&#25321;manual compaction range.
    manual.begin = NULL;
  } else {
    begin_storage = InternalKey(*begin, kMaxSequenceNumber, kValueTypeForSeek);
    manual.begin = &amp;begin_storage;
  }
  if (end == NULL) {
    manual.end = NULL;
  } else {
    end_storage = InternalKey(*end, 0, static_cast&lt;ValueType&gt;(0));
    manual.end = &amp;end_storage;
  }

  MutexLock l(&amp;mutex_);
  while (!manual.done) { // &#22914;&#26524;&#27809;&#26377;&#23436;&#25104;&#30340;&#35805;
    // &#31561;&#24453;&#19978;&#19968;&#27425;&#23436;&#25104;
    while (manual_compaction_ != NULL) {
      bg_cv_.Wait();
    }
    // &#31561;&#24453;&#26412;&#27425;&#23436;&#25104;
    // &#36824;&#26159;&#35843;&#29992;maybe schedule compaction
    // &#25353;&#29031;&#20195;&#30721;&#26469;&#30475;&#30340;&#35805;&#36208;&#30340;&#20998;&#25903;&#20027;&#35201;&#26159;&#20851;&#27880;VersionSet::CompactRange&#36825;&#20010;&#37096;&#20998;.
    manual_compaction_ = &amp;manual;
    MaybeScheduleCompaction();
    while (manual_compaction_ == &amp;manual) {
      bg_cv_.Wait();
    }
  }
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-3-19" class="outline-6">
<h6 id="sec-1-10-3-3-19"><span class="section-number-6">1.10.3.3.19</span> DoCompactionWork</h6>
<div class="outline-text-6" id="text-1-10-3-3-19">

<p>完成的工作是实质性地Compaction.通过读取提交的CompactionState来完成.过程比较长可以逐段逐段地阅读代码.
</p>


<pre class="src src-C++">Status DBImpl::DoCompactionWork(CompactionState* compact) {
  const uint64_t start_micros = env_-&gt;NowMicros();
  int64_t imm_micros = 0;  // Micros spent doing imm_ compactions

  Log(options_.info_log,  <span style="color: #ffff00;">"Compacting %d@%d + %d@%d files"</span>,
      compact-&gt;compaction-&gt;num_input_files(0),
      compact-&gt;compaction-&gt;level(),
      compact-&gt;compaction-&gt;num_input_files(1),
      compact-&gt;compaction-&gt;level() + 1);

  assert(versions_-&gt;NumLevelFiles(compact-&gt;compaction-&gt;level()) &gt; 0);
  assert(compact-&gt;builder == NULL);
  assert(compact-&gt;outfile == NULL);
  // &#39318;&#20808;&#26681;&#25454;&#24403;&#21069;&#25152;&#26377;&#25552;&#20132;&#30340;snapshot&#30693;&#36947;&#24403;&#21069;&#26368;&#23567;&#30340;sequence number&#26159;&#22810;&#23569;.
  if (snapshots_.empty()) {
    compact-&gt;smallest_snapshot = versions_-&gt;LastSequence();
  } else {
    compact-&gt;smallest_snapshot = snapshots_.oldest()-&gt;number_;
  }

  // Release mutex while we're actually doing the compaction work
  mutex_.Unlock();

  // &#38024;&#23545;&#36825;&#20010;compaction&#21019;&#24314;&#20986;iterator.&#25105;&#20204;&#22312;&#21518;&#38754;&#30475;&#30475;&#36825;&#20010;iterator&#26159;&#22914;&#20309;&#24314;&#31435;&#30340;.
  Iterator* input = versions_-&gt;MakeInputIterator(compact-&gt;compaction);
  input-&gt;SeekToFirst();
  Status status;
  ParsedInternalKey ikey;
  std::string current_user_key;
  bool has_current_user_key = false;
  SequenceNumber last_sequence_for_key = kMaxSequenceNumber;
  for (; input-&gt;Valid() &amp;&amp; !shutting_down_.Acquire_Load(); ) {
    // Prioritize immutable compaction work
    // &#20570;compaction&#20043;&#21069;&#20808;&#23558;immutable table compaction.
    if (has_imm_.NoBarrier_Load() != NULL) {
      const uint64_t imm_start = env_-&gt;NowMicros();
      mutex_.Lock();
      if (imm_ != NULL) {
        CompactMemTable();
        bg_cv_.SignalAll();  // Wakeup MakeRoomForWrite() if necessary
      }
      mutex_.Unlock();
      imm_micros += (env_-&gt;NowMicros() - imm_start);
    }

    // &#21028;&#26029;&#22312;&#36825;&#20010;key&#26159;&#21542;&#24212;&#35813;&#29420;&#31435;&#20135;&#29983;&#19968;&#20010;&#25991;&#20214;.
    Slice key = input-&gt;key();
    if (compact-&gt;compaction-&gt;ShouldStopBefore(key) &amp;&amp;
        compact-&gt;builder != NULL) {
      status = FinishCompactionOutputFile(compact, input);
      if (!status.ok()) {
        break;
      }
    }

    // Handle key/value, add to state, etc.
    // drop&#34920;&#31034;&#36825;&#20010;key&#26159;&#21542;&#24212;&#35813;&#30452;&#25509;&#20002;&#24323;.
    // &#36825;&#20010;&#22320;&#26041;&#22987;&#32456;&#24863;&#35273;&#26377;&#28857;&#38382;&#39064;.&#20026;&#20160;&#20040;&#35745;&#31639;last seuqnce number&#21602;?.
    // &#19981;&#36807;&#22823;&#33268;&#24605;&#24819;&#26159;&#20102;&#35299;&#30340;.
    bool drop = false;
    if (!ParseInternalKey(key, &amp;ikey)) {
      // Do not hide error keys
      current_user_key.clear();
      has_current_user_key = false;
      last_sequence_for_key = kMaxSequenceNumber;
    } else {
      if (!has_current_user_key ||
          user_comparator()-&gt;Compare(ikey.user_key,
                                     Slice(current_user_key)) != 0) {
        // First occurrence of this user key
        current_user_key.assign(ikey.user_key.data(), ikey.user_key.size());
        has_current_user_key = true;
        last_sequence_for_key = kMaxSequenceNumber;
      }
      // &#36825;&#27573;&#36923;&#36753;&#21028;&#26029;&#26159;&#21542;&#38656;&#35201;&#20002;&#24323;.
      if (last_sequence_for_key &lt;= compact-&gt;smallest_snapshot) {
        // Hidden by an newer entry for same user key
        drop = true;    // (A)
      } else if (ikey.type == kTypeDeletion &amp;&amp; // &#22914;&#26524;&#26159;&#21024;&#38500;&#24182;&#19988;&#36825;&#20010;key &lt; snapshot.
                 ikey.sequence &lt;= compact-&gt;smallest_snapshot &amp;&amp;
                 compact-&gt;compaction-&gt;IsBaseLevelForKey(ikey.user_key)) {
        // For this user key:
        // (1) there is no data in higher levels
        // (2) data in lower levels will have larger sequence numbers
        // (3) data in layers that are being compacted here and have
        //     smaller sequence numbers will be dropped in the next
        //     few iterations of this loop (by rule (A) above).
        // Therefore this deletion marker is obsolete and can be dropped.
        drop = true;
      }

      last_sequence_for_key = ikey.sequence;
    }
#if 0
    Log(options_.info_log,
        <span style="color: #ffff00;">"  Compact: %s, seq %d, type: %d %d, drop: %d, is_base: %d, "</span>
        <span style="color: #ffff00;">"%d smallest_snapshot: %d"</span>,
        ikey.user_key.ToString().c_str(),
        (int)ikey.sequence, ikey.type, kTypeValue, drop,
        compact-&gt;compaction-&gt;IsBaseLevelForKey(ikey.user_key),
        (int)last_sequence_for_key, (int)compact-&gt;smallest_snapshot);
#endif

    // &#19981;&#31649;&#21069;&#38754;&#32454;&#33410;&#22914;&#20309;&#21040;&#36825;&#20010;&#27493;&#39588;&#34920;&#26126;&#36825;&#20010;kv&#27809;&#26377;&#34987;drop&#25481;.
    if (!drop) {
      // Open output file if necessary
      if (compact-&gt;builder == NULL) { // &#26681;&#25454;compaction&#29366;&#24577;&#20135;&#29983;&#26032;&#36755;&#20986;&#25991;&#20214;.
        status = OpenCompactionOutputFile(compact);
        if (!status.ok()) {
          break;
        }
      }
      // ==0&#30340;&#26102;&#20505;&#35760;&#24405;&#26368;&#23567;key.
      if (compact-&gt;builder-&gt;NumEntries() == 0) {
        compact-&gt;current_output()-&gt;smallest.DecodeFrom(key);
      }
      // &#20043;&#21518;&#27599;&#27425;&#26356;&#26032;&#26368;&#22823;key
      compact-&gt;current_output()-&gt;largest.DecodeFrom(key);
      // &#35760;&#24405;&#36825;&#20010;kv.
      compact-&gt;builder-&gt;Add(key, input-&gt;value());

      // Close output file if it is big enough
      // &#22914;&#26524;&#25991;&#20214;&#36229;&#36807;&#22823;&#23567;&#30340;&#35805;&#37027;&#20040;&#38656;&#35201;&#20999;&#25442;&#25991;&#20214;.
      if (compact-&gt;builder-&gt;FileSize() &gt;=
          compact-&gt;compaction-&gt;MaxOutputFileSize()) {
        status = FinishCompactionOutputFile(compact, input);
        if (!status.ok()) {
          break;
        }
      }
    }

    input-&gt;Next();
  }

  if (status.ok() &amp;&amp; shutting_down_.Acquire_Load()) {
    status = Status::IOError(<span style="color: #ffff00;">"Deleting DB during compaction"</span>);
  }
  // &#26368;&#21518;&#21487;&#33021;&#38656;&#35201;&#20851;&#38381;compaction&#30340;&#25991;&#20214;.
  if (status.ok() &amp;&amp; compact-&gt;builder != NULL) {
    status = FinishCompactionOutputFile(compact, input);
  }
  if (status.ok()) {
    status = input-&gt;status();
  }
  delete input; // &#21024;&#38500;&#36825;&#20010;iterator.
  input = NULL;

  CompactionStats stats;
  // compaction&#37096;&#20998;&#30340;&#26102;&#38388;&#36824;&#38656;&#35201;&#20986;&#21435;&#20869;&#23384;memtable compaction&#26159;&#26102;&#38388;.
  stats.micros = env_-&gt;NowMicros() - start_micros - imm_micros;
  // &#32479;&#35745;&#36825;&#27425;&#25805;&#20316;&#35835;&#21462;&#30340;&#22823;&#23567;.
  for (int which = 0; which &lt; 2; which++) {
    for (int i = 0; i &lt; compact-&gt;compaction-&gt;num_input_files(which); i++) {
      stats.bytes_read += compact-&gt;compaction-&gt;input(which, i)-&gt;file_size;
    }
  }
  // &#32479;&#35745;&#36825;&#27425;&#25805;&#20316;&#20889;&#30913;&#30424;&#22823;&#23567;.
  for (size_t i = 0; i &lt; compact-&gt;outputs.size(); i++) {
    stats.bytes_written += compact-&gt;outputs[i].file_size;
  }

  mutex_.Lock();
  // &#23558;&#36825;&#20010;&#29366;&#24577;&#21512;&#24182;&#19978;&#26469;.
  stats_[compact-&gt;compaction-&gt;level() + 1].Add(stats);

  if (status.ok()) {
    status = InstallCompactionResults(compact);
  }
  VersionSet::LevelSummaryStorage tmp;
  Log(options_.info_log,
      <span style="color: #ffff00;">"compacted to: %s"</span>, versions_-&gt;LevelSummary(&amp;tmp));
  return status;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-3-20" class="outline-6">
<h6 id="sec-1-10-3-3-20"><span class="section-number-6">1.10.3.3.20</span> CleanupCompaction</h6>
<div class="outline-text-6" id="text-1-10-3-3-20">

<p>完成compaction之后的工作.
</p>


<pre class="src src-C++">void DBImpl::CleanupCompaction(CompactionState* compact) {
  mutex_.AssertHeld();
  if (compact-&gt;builder != NULL) { // &#22914;&#26524;&#36825;&#20010;builder&#27809;&#26377;&#38144;&#27585;&#30340;&#35805;&#37027;&#20040;&#35748;&#20026;
    // &#20013;&#36884;&#26159;shutdown&#20102;.&#37027;&#20040;&#25105;&#20204;&#36825;&#37324;&#30452;&#25509;abandon&#25481;.
    // May happen if we get a shutdown call in the middle of compaction
    compact-&gt;builder-&gt;Abandon();
    delete compact-&gt;builder;
  } else {
    assert(compact-&gt;outfile == NULL);
  }
  delete compact-&gt;outfile;
  // compaction&#36807;&#31243;&#20013;&#30340;&#35805;&#26032;&#36755;&#20986;&#30340;output&#25991;&#20214;&#24212;&#35813;&#37117;&#21152;&#20837;&#20102;pengding_outputs
  // &#38450;&#27490;&#36825;&#20010;&#25991;&#20214;&#37096;&#20998;&#34987;&#21024;&#38500;.&#23436;&#25104;compaction&#20043;&#21518;&#30340;&#35805;&#21487;&#20197;&#31227;&#38500;&#20102;
  // &#32771;&#34385;&#36825;&#37324;&#22806;&#37096;&#24212;&#35813;&#26377;&#26631;&#35760;&#36890;&#30693;&#36825;&#20123;&#25991;&#20214;&#36824;&#26159;&#38656;&#35201;&#30340;.
  // &#25152;&#20197;&#38024;&#23545;&#36825;&#20123;&#25991;&#20214;&#21487;&#33021;&#24050;&#32463;&#21019;&#24314;&#20102;&#21478;&#22806;&#19968;&#20010;version&#23545;&#35937;&#23384;&#25918;&#22312;version_set&#20869;&#37096;.
  // &#20294;&#26159;&#21861;&#26102;&#20505;&#37322;&#25918;version&#36825;&#20010;&#23545;&#35937;&#21602;???.
  for (size_t i = 0; i &lt; compact-&gt;outputs.size(); i++) {
    const CompactionState::Output&amp; out = compact-&gt;outputs[i];
    pending_outputs_.erase(out.number);
  }
  delete compact;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-3-21" class="outline-6">
<h6 id="sec-1-10-3-3-21"><span class="section-number-6">1.10.3.3.21</span> InstallCompactionResults</h6>
<div class="outline-text-6" id="text-1-10-3-3-21">

<p>这个函数调用过程是在DoCompactionWork里面.大致工作就是将这次compaction工作内容作为日志保存起来.
</p>


<pre class="src src-C++">Status DBImpl::InstallCompactionResults(CompactionState* compact) {
  mutex_.AssertHeld();
  Log(options_.info_log,  <span style="color: #ffff00;">"Compacted %d@%d + %d@%d files =&gt; %lld bytes"</span>,
      compact-&gt;compaction-&gt;num_input_files(0),
      compact-&gt;compaction-&gt;level(),
      compact-&gt;compaction-&gt;num_input_files(1),
      compact-&gt;compaction-&gt;level() + 1,
      static_cast&lt;long long&gt;(compact-&gt;total_bytes));

  // Add compaction outputs
  compact-&gt;compaction-&gt;AddInputDeletions(compact-&gt;compaction-&gt;edit()); // &#23558;compaction&#36825;&#27425;&#25805;&#20316;&#21024;&#38500;&#21644;&#22686;&#21152;&#25991;&#20214;&#21152;&#20837;version_edit.
  const int level = compact-&gt;compaction-&gt;level();
  for (size_t i = 0; i &lt; compact-&gt;outputs.size(); i++) {
    const CompactionState::Output&amp; out = compact-&gt;outputs[i];
    // &#23558;&#26412;&#22320;&#25805;&#20316;&#25918;&#22312;version_edit&#37324;&#38754;.
    compact-&gt;compaction-&gt;edit()-&gt;AddFile(
        level + 1,
        out.number, out.file_size, out.smallest, out.largest);
    pending_outputs_.erase(out.number); // &#20174;pending output&#37324;&#38754;&#21024;&#38500;.
  }
  compact-&gt;outputs.clear();

  Status s = versions_-&gt;LogAndApply(compact-&gt;compaction-&gt;edit(), &amp;mutex_); // &#36890;&#30693;version set&#26412;&#27425;&#20462;&#25913;&#20869;&#23481;.
  // &#24182;&#19988;&#23558;&#36825;&#27425;compaction&#30340;&#20869;&#23481;&#20316;&#20026;version&#20889;&#20837;log&#37324;&#38754;&#21435;.
  if (s.ok()) {
    compact-&gt;compaction-&gt;ReleaseInputs();
    DeleteObsoleteFiles();
  } else {
    // Discard any files we may have created during this failed compaction
    for (size_t i = 0; i &lt; compact-&gt;outputs.size(); i++) {
      env_-&gt;DeleteFile(TableFileName(dbname_, compact-&gt;outputs[i].number));
    }
  }
  return s;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-3-22" class="outline-6">
<h6 id="sec-1-10-3-3-22"><span class="section-number-6">1.10.3.3.22</span> OpenCompactionOutputFile</h6>
<div class="outline-text-6" id="text-1-10-3-3-22">

<p>打开用于compaction输出的文件.倒不是非常麻烦.
</p>


<pre class="src src-C++">Status DBImpl::OpenCompactionOutputFile(CompactionState* compact) {
  assert(compact != NULL);
  assert(compact-&gt;builder == NULL);
  uint64_t file_number;
  {
    mutex_.Lock();
    file_number = versions_-&gt;NewFileNumber();
    pending_outputs_.insert(file_number); // &#25918;&#22312;pending output&#37324;&#38754;.
    CompactionState::Output out;
    out.number = file_number;
    out.smallest.Clear();
    out.largest.Clear();
    compact-&gt;outputs.push_back(out);
    mutex_.Unlock();
  }

  // Make the output file
  // &#21019;&#24314;&#36755;&#20986;&#25991;&#20214;&#20197;&#21450;&#23545;&#24212;&#30340;table builder.
  std::string fname = TableFileName(dbname_, file_number);
  Status s = env_-&gt;NewWritableFile(fname, &amp;compact-&gt;outfile);
  if (s.ok()) {
    compact-&gt;builder = new TableBuilder(options_, compact-&gt;outfile);
  }
  return s;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-3-23" class="outline-6">
<h6 id="sec-1-10-3-3-23"><span class="section-number-6">1.10.3.3.23</span> FinishCompactionOutputFile</h6>
<div class="outline-text-6" id="text-1-10-3-3-23">

<p>对于输出了文件之后我们需要finish的操作.倒不是非常麻烦.
</p>


<pre class="src src-C++">Status DBImpl::FinishCompactionOutputFile(CompactionState* compact,
                                          Iterator* input) {
  assert(compact != NULL);
  assert(compact-&gt;outfile != NULL);
  assert(compact-&gt;builder != NULL);

  const uint64_t output_number = compact-&gt;current_output()-&gt;number;
  assert(output_number != 0);

  // Check for iterator errors
  Status s = input-&gt;status();
  const uint64_t current_entries = compact-&gt;builder-&gt;NumEntries();
  if (s.ok()) {
    s = compact-&gt;builder-&gt;Finish(); // &#36890;&#30693;&#23545;&#24212;&#30340;builder&#23545;&#35937;finish.
  } else {
    compact-&gt;builder-&gt;Abandon();
  }
  const uint64_t current_bytes = compact-&gt;builder-&gt;FileSize();
  compact-&gt;current_output()-&gt;file_size = current_bytes;
  compact-&gt;total_bytes += current_bytes;
  delete compact-&gt;builder; // &#37322;&#25918;&#21407;&#26469;builder.
  compact-&gt;builder = NULL;

  // Finish and check for file errors
  if (s.ok()) {
    s = compact-&gt;outfile-&gt;Sync();
  }
  if (s.ok()) {
    s = compact-&gt;outfile-&gt;Close();
  }
  delete compact-&gt;outfile; // &#37322;&#25918;&#21407;&#26469;&#30340;file&#23545;&#35937;.
  compact-&gt;outfile = NULL;

  // &#39564;&#35777;&#36825;&#20010;&#25991;&#20214;&#26159;&#21542;OK.
  if (s.ok() &amp;&amp; current_entries &gt; 0) {
    // Verify that the table is usable
    Iterator* iter = table_cache_-&gt;NewIterator(ReadOptions(),
                                               output_number,
                                               current_bytes);
    s = iter-&gt;status();
    delete iter;
    if (s.ok()) {
      Log(options_.info_log,
          <span style="color: #ffff00;">"Generated table #%llu: %lld keys, %lld bytes"</span>,
          (unsigned long long) output_number,
          (unsigned long long) current_entries,
          (unsigned long long) current_bytes);
    }
  }
  return s;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-3-24" class="outline-6">
<h6 id="sec-1-10-3-3-24"><span class="section-number-6">1.10.3.3.24</span> Write</h6>
<div class="outline-text-6" id="text-1-10-3-3-24">

<p>这个是Put/Delete底层的最终实现.仔细看看吧
</p>


<pre class="src src-C++">Status DBImpl::Write(const WriteOptions&amp; options, WriteBatch* updates) {
  Status status;
  MutexLock l(&amp;mutex_);
  LoggerId self;
  AcquireLoggingResponsibility(&amp;self);
  status = MakeRoomForWrite(false);  // May temporarily release lock and wait
  uint64_t last_sequence = versions_-&gt;LastSequence(); // &#20998;&#37197;sequence.
  if (status.ok()) {
    WriteBatchInternal::SetSequence(updates, last_sequence + 1); // WriteBatch&#30340;sequence&#20174;+1&#24320;&#22987;.
    last_sequence += WriteBatchInternal::Count(updates); // &#26356;&#26032;&#19978;&#27425;sequence.

    // Add to log and apply to memtable.  We can release the lock during
    // this phase since the <span style="color: #ffff00;">"logger_"</span> flag protects against concurrent
    // loggers and concurrent writes into mem_.
    {
      assert(logger_ == &amp;self);
      mutex_.Unlock();
      // &#36825;&#20010;&#37096;&#20998;&#26159;&#32943;&#23450;&#38656;&#35201;&#20889;&#20837;log&#30340;.
      // &#27880;&#24847;&#36825;&#37324;&#37322;&#25918;&#38145;&#26159;&#27809;&#26377;&#38382;&#39064;&#65292;&#22240;&#20026;&#36825;&#20010;&#22320;&#26041;logger&#21487;&#20197;&#20316;&#20026;&#38145;&#23384;&#22312;.
      // &#36825;&#37324;&#35299;&#24320;mutex&#20284;&#20046;&#21487;&#20197;&#20351;&#24471;Get&#36827;&#34892;.
      // &#25105;&#35273;&#24471;&#31532;&#19968;&#36941;&#30475;leveldb&#20195;&#30721;&#30340;&#26102;&#20505;&#21487;&#20197;&#25735;&#24320;&#24182;&#21457;&#36825;&#20010;&#37096;&#20998;.
      status = log_-&gt;AddRecord(WriteBatchInternal::Contents(updates)); // &#23558;updates&#30340;&#20869;&#23481;&#20316;&#20026;contents&#24471;&#21040;&#20889;&#20837;log.
      if (status.ok() &amp;&amp; options.sync) {
        status = logfile_-&gt;Sync();
      }
      if (status.ok()) {
        // &#28982;&#21518;&#23558;updates&#20889;&#20837;memtable.
        status = WriteBatchInternal::InsertInto(updates, mem_);
      }
      mutex_.Lock();
      assert(logger_ == &amp;self);
    }

    // &#20889;&#20837;&#25104;&#21151;&#20043;&#21518;&#30340;&#35805;&#37027;&#20040;&#23558;&#36825;&#20010;sequence&#37325;&#26032;&#20889;&#22238;.
    versions_-&gt;SetLastSequence(last_sequence); // &#35774;&#32622;&#26032;&#30340;sequence.
  }
  ReleaseLoggingResponsibility(&amp;self);
  return status;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-3-25" class="outline-6">
<h6 id="sec-1-10-3-3-25"><span class="section-number-6">1.10.3.3.25</span> SanitizeOptions</h6>
<div class="outline-text-6" id="text-1-10-3-3-25">

<p>这个函数应该就是规范一下options这个结构.
</p>


<pre class="src src-C++">// Fix user-supplied options to be reasonable
template &lt;class T,class V&gt;
static void ClipToRange(T* ptr, V minvalue, V maxvalue) {
  if (static_cast&lt;V&gt;(*ptr) &gt; maxvalue) *ptr = maxvalue;
  if (static_cast&lt;V&gt;(*ptr) &lt; minvalue) *ptr = minvalue;
}
Options SanitizeOptions(const std::string&amp; dbname,
                        const InternalKeyComparator* icmp,
                        const Options&amp; src) {
  Options result = src;
  result.comparator = icmp;
  // &#35268;&#33539;&#21462;&#20540;&#33539;&#22260;.
  ClipToRange(&amp;result.max_open_files,           20,     50000); // 20 , 50000
  ClipToRange(&amp;result.write_buffer_size,        64&lt;&lt;10, 1&lt;&lt;30); // 64K , 1G
  ClipToRange(&amp;result.block_size,               1&lt;&lt;10,  4&lt;&lt;20); // 1K, 4M.
  // &#22914;&#26524;&#29992;&#25143;&#27809;&#26377;&#22635;&#20889;logger&#23545;&#35937;&#30340;&#35805;
  // &#37027;&#20040;&#20135;&#29983;&#19968;&#20010;logger&#23545;&#35937;.
  if (result.info_log == NULL) {
    // Open a log file in the same directory as the db
    src.env-&gt;CreateDir(dbname);  // In case it does not exist
    src.env-&gt;RenameFile(InfoLogFileName(dbname), OldInfoLogFileName(dbname));
    Status s = src.env-&gt;NewLogger(InfoLogFileName(dbname), &amp;result.info_log);
    if (!s.ok()) {
      // No place suitable for logging
      result.info_log = NULL;
    }
  }
  // &#23545;&#20110;block cache&#20063;&#26159;.&#24320;&#36767;&#30340;block cache&#22823;&#23567;8MB.
  if (result.block_cache == NULL) {
    result.block_cache = NewLRUCache(8 &lt;&lt; 20);
  }
  return result;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-3-26" class="outline-6">
<h6 id="sec-1-10-3-3-26"><span class="section-number-6">1.10.3.3.26</span> GetProperty</h6>
<div class="outline-text-6" id="text-1-10-3-3-26">

<p>关于db的属性信息.
</p>


<pre class="src src-C++">bool DBImpl::GetProperty(const Slice&amp; property, std::string* value) {
  value-&gt;clear();

  MutexLock l(&amp;mutex_);
  Slice in = property;
  // &#23646;&#24615;&#30340;key&#24517;&#39035;&#26159;&#20197;leveldb.&#24320;&#22836;&#30340;.
  Slice prefix(<span style="color: #ffff00;">"leveldb."</span>);
  if (!in.starts_with(prefix)) return false;
  in.remove_prefix(prefix.size());

  if (in.starts_with(<span style="color: #ffff00;">"num-files-at-level"</span>)) { // &#27599;&#20010;level&#30340;&#25991;&#20214;&#25968;&#30446;.
    in.remove_prefix(strlen(<span style="color: #ffff00;">"num-files-at-level"</span>));
    uint64_t level;
    bool ok = ConsumeDecimalNumber(&amp;in, &amp;level) &amp;&amp; in.empty();
    if (!ok || level &gt;= config::kNumLevels) {
      return false;
    } else {
      char buf[100];
      snprintf(buf, sizeof(buf), <span style="color: #ffff00;">"%d"</span>,
               versions_-&gt;NumLevelFiles(static_cast&lt;int&gt;(level)));
      *value = buf;
      return true;
    }
  } else if (in == <span style="color: #ffff00;">"stats"</span>) { // &#25972;&#20010;db&#30340;&#29366;&#24577;.
    char buf[200];
    snprintf(buf, sizeof(buf),
             <span style="color: #ffff00;">"                               Compactions\n"</span>
             <span style="color: #ffff00;">"Level  Files Size(MB) Time(sec) Read(MB) Write(MB)\n"</span>
             <span style="color: #ffff00;">"--------------------------------------------------\n"</span>
             );
    value-&gt;append(buf);
    for (int level = 0; level &lt; config::kNumLevels; level++) {
      int files = versions_-&gt;NumLevelFiles(level);
      if (stats_[level].micros &gt; 0 || files &gt; 0) {
        snprintf(
            buf, sizeof(buf),
            <span style="color: #ffff00;">"%3d %8d %8.0f %9.0f %8.0f %9.0f\n"</span>,
            level,
            files,
            versions_-&gt;NumLevelBytes(level) / 1048576.0,
            stats_[level].micros / 1e6, // &#22312;&#36825;&#20010;level&#19978;&#38754;&#25805;&#20316;&#30340;&#26102;&#38388;.
            stats_[level].bytes_read / 1048576.0, // &#22312;&#36825;&#20010;level&#19978;&#38754;&#35835;&#21462;&#30340;&#23383;&#33410;&#25968;&#30446;.
            stats_[level].bytes_written / 1048576.0); // &#22312;&#36825;&#20010;level&#19978;&#38754;&#20889;&#20837;&#30340;&#23383;&#33410;&#25968;&#30446;.
        value-&gt;append(buf);
      }
    }
    return true;
  } else if (in == <span style="color: #ffff00;">"sstables"</span>) { // &#24403;&#21069;sstables&#30340;&#29366;&#24577;.
    // &#36825;&#20010;&#26159;Version&#25171;&#21360;&#20986;&#30340;&#23383;&#31526;&#20018;.
    *value = versions_-&gt;current()-&gt;DebugString();
    return true;
  }

  return false;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-3-27" class="outline-6">
<h6 id="sec-1-10-3-3-27"><span class="section-number-6">1.10.3.3.27</span> GetApproximateSizes</h6>
<div class="outline-text-6" id="text-1-10-3-3-27">

<p>得到某个Range占用的大小.底层依赖于VersionSet
</p>


<pre class="src src-C++">void DBImpl::GetApproximateSizes(
    const Range* range, int n,
    uint64_t* sizes) {
  // TODO(opt): better implementation
  Version* v;
  {
    MutexLock l(&amp;mutex_); // &#27880;&#24847;&#36825;&#37324;&#26159;&#20840;&#23616;&#21152;&#38145;&#30340;.
    versions_-&gt;current()-&gt;Ref(); // &#23545;&#24403;&#21069;version&#21152;&#19978;&#24341;&#29992;&#35745;&#25968;.
    v = versions_-&gt;current();
  }

  for (int i = 0; i &lt; n; i++) {
    // Convert user_key into a corresponding internal key.
    // &#36825;&#37324;sequence number&#26159;&#21542;&#27491;&#30830;&#21602;?
    // &#19981;&#36807;&#22823;&#33268;&#19978;&#21344;&#29992;&#30340;&#31354;&#38388;&#24046;&#19981;&#22810;&#23601;&#26159;&#36825;&#20040;&#22823;.
    InternalKey k1(range[i].start, kMaxSequenceNumber, kValueTypeForSeek);
    InternalKey k2(range[i].limit, kMaxSequenceNumber, kValueTypeForSeek);
    // &#20855;&#20307;&#23454;&#29616;&#21487;&#20197;&#26597;&#30475;VersionSet&#26041;&#27861;.&#26681;&#25454;&#26576;&#20010;key&#21028;&#26029;&#36825;&#20010;key&#22312;&#25991;&#20214;&#20013;&#30340;&#20559;&#31227;.
    // &#21487;&#33021;&#20250;&#26377;&#19968;&#37096;&#20998;&#20559;&#24046;&#21543;&#20294;&#26159;&#22823;&#33268;&#27491;&#30830;.
    uint64_t start = versions_-&gt;ApproximateOffsetOf(v, k1);
    uint64_t limit = versions_-&gt;ApproximateOffsetOf(v, k2);
    sizes[i] = (limit &gt;= start ? limit - start : 0);
  }

  {
    MutexLock l(&amp;mutex_);
    v-&gt;Unref();
  }
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-3-28" class="outline-6">
<h6 id="sec-1-10-3-3-28"><span class="section-number-6">1.10.3.3.28</span> GetSnapshot</h6>
<div class="outline-text-6" id="text-1-10-3-3-28">




<pre class="src src-C++">const Snapshot* DBImpl::GetSnapshot() {
  MutexLock l(&amp;mutex_);
  // &#36820;&#22238;&#26368;&#26032;&#30340;sequence number&#21019;&#24314;&#19968;&#20010;Snapshot&#23454;&#20363;.
  // &#24182;&#19988;&#28155;&#21152;&#21040;snapshot list&#37324;&#38754;.
  return snapshots_.New(versions_-&gt;LastSequence());
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-3-29" class="outline-6">
<h6 id="sec-1-10-3-3-29"><span class="section-number-6">1.10.3.3.29</span> ReleaseSnapshot</h6>
<div class="outline-text-6" id="text-1-10-3-3-29">




<pre class="src src-C++">void DBImpl::ReleaseSnapshot(const Snapshot* s) {
  MutexLock l(&amp;mutex_);
  // &#20174;snapshot list&#37324;&#38754;&#21024;&#38500;.
  snapshots_.Delete(reinterpret_cast&lt;const SnapshotImpl*&gt;(s));
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-3-30" class="outline-6">
<h6 id="sec-1-10-3-3-30"><span class="section-number-6">1.10.3.3.30</span> DeleteObsoleteFiles</h6>
<div class="outline-text-6" id="text-1-10-3-3-30">

<p>根据当前所有version所持有的file来决定哪些文件是不再需要的.version里面会持有file meta信息.
</p>


<pre class="src src-C++">void DBImpl::DeleteObsoleteFiles() {
  // Make a set of all of the live files
  std::set&lt;uint64_t&gt; live = pending_outputs_;
  versions_-&gt;AddLiveFiles(&amp;live); // &#25345;&#26377;pending outputs&#37324;&#38754;&#27491;&#22312;&#36755;&#20986;&#30340;&#25991;&#20214;
  // &#24182;&#19988;&#23558;verisons&#37324;&#38754;&#25152;&#26377;version&#25345;&#26377;&#30340;&#25991;&#20214;&#24471;&#21040;.

  std::vector&lt;std::string&gt; filenames;
  // &#36941;&#21382;&#24403;&#21069;&#30446;&#24405;&#19979;&#38754;&#30340;&#25991;&#20214;.
  // &#27880;&#24847;&#36825;&#37324;&#25991;&#20214;&#25968;&#30446;&#19981;&#20250;&#36807;&#22810;.
  // &#22240;&#20026;&#36890;&#24120;&#26469;&#35828;&#27599;&#20010;level&#25991;&#20214;&#37117;&#20250;&#26377;&#19968;&#20010;&#19979;&#38480;&#22823;&#23567;&#25968;&#30446;
  // &#32780;&#27599;&#20010;level&#30340;bytes&#26377;&#19968;&#20010;&#38480;&#21046;.&#23545;&#20110;&#26368;&#39640;&#23618;&#30340;level&#30340;&#35805;&#37027;&#20040;&#25991;&#20214;&#24050;&#32463;&#38750;&#24120;&#22823;&#20102;:)
  env_-&gt;GetChildren(dbname_, &amp;filenames); // Ignoring errors on purpose
  uint64_t number;
  FileType type;
  for (size_t i = 0; i &lt; filenames.size(); i++) {
    if (ParseFileName(filenames[i], &amp;number, &amp;type)) {
      bool keep = true;
      switch (type) {
        case kLogFile:
          // &#23545;&#20110;log&#25991;&#20214;&#30340;number&#26159;&#25353;&#29031;&#39034;&#24207;&#20998;&#37197;&#30340;.
          keep = ((number &gt;= versions_-&gt;LogNumber()) || //
                  (number == versions_-&gt;PrevLogNumber())); // prev log number&#24050;&#32463;&#27809;&#26377;&#24517;&#35201;&#20102;.
          break;
        case kDescriptorFile:
          // Keep my manifest file, and any newer incarnations'
          // (in case there is a race that allows other incarnations)
          keep = (number &gt;= versions_-&gt;ManifestFileNumber());
          break;
        case kTableFile:
          keep = (live.find(number) != live.end()); // &#21028;&#26029;&#36825;&#20010;&#25991;&#20214;&#26159;&#21542;&#38656;&#35201;&#21024;&#38500;.
          break;
        case kTempFile:
          // Any temp files that are currently being written to must
          // be recorded in pending_outputs_, which is inserted into <span style="color: #ffff00;">"live"</span>
          keep = (live.find(number) != live.end()); // &#21028;&#26029;&#25991;&#20214;&#26159;&#21542;&#38656;&#35201;&#21024;&#38500;.
          break;
        case kCurrentFile:
        case kDBLockFile:
        case kInfoLogFile:
          keep = true; // &#23545;&#20110;&#20854;&#20182;&#25991;&#20214;&#30340;&#35805;&#30452;&#25509;keep&#20303;&#23601;&#22909;&#20102;.
          break;
      }

      if (!keep) {
        if (type == kTableFile) { // &#22914;&#26524;&#26159;table&#25991;&#20214;&#30340;&#35805;&#36824;&#38656;&#35201;&#20174;cache&#37324;&#38754;&#21435;&#25481;.
          table_cache_-&gt;Evict(number);
        }
        Log(options_.info_log, <span style="color: #ffff00;">"Delete type=%d #%lld\n"</span>,
            int(type),
            static_cast&lt;unsigned long long&gt;(number));
        env_-&gt;DeleteFile(dbname_ + <span style="color: #ffff00;">"/"</span> + filenames[i]); // &#28982;&#21518;&#21024;&#38500;&#25991;&#20214;.
      }
    }
  }
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-3-31" class="outline-6">
<h6 id="sec-1-10-3-3-31"><span class="section-number-6">1.10.3.3.31</span> Get</h6>
<div class="outline-text-6" id="text-1-10-3-3-31">

<p>Get的过程非常简单.因为实际Get的过程已经托管为Version::Get这个方法了.这里面我们只需要
构造出正确的seuqnce number,和user key拼接成为internal key即可.
</p>


<pre class="src src-C++">Status DBImpl::Get(const ReadOptions&amp; options,
                   const Slice&amp; key,
                   std::string* value) {
  Status s;
  MutexLock l(&amp;mutex_);
  SequenceNumber snapshot;
  if (options.snapshot != NULL) { // &#21028;&#26029;&#24403;&#21069;&#35835;&#21462;&#26159;&#21542;&#38656;&#35201;snapshot.
    snapshot = reinterpret_cast&lt;const SnapshotImpl*&gt;(options.snapshot)-&gt;number_;
  } else {
    snapshot = versions_-&gt;LastSequence();
  }

  MemTable* mem = mem_;
  MemTable* imm = imm_;
  Version* current = versions_-&gt;current();
  mem-&gt;Ref();
  if (imm != NULL) imm-&gt;Ref();
  current-&gt;Ref();

  // &#36825;&#20010;&#26597;&#35810;&#26159;&#21542;&#20250;&#36896;&#25104;compaction&#35302;&#21457;.
  bool have_stat_update = false;
  Version::GetStats stats;

  // Unlock while reading from files and memtables
  {
    mutex_.Unlock();
    // &#20197;&#36825;&#20010;key&#21435;&#36827;&#34892;&#26597;&#35810;.
    // 1.&#39318;&#20808;&#26597;&#35810;memtable 2.&#28982;&#21518;&#26597;&#35810;&#27491;&#22312;dump&#30340;memtable 3.&#26597;&#35810;&#30913;&#30424;.
    // First look in the memtable, then in the immutable memtable (if any).
    LookupKey lkey(key, snapshot);
    if (mem-&gt;Get(lkey, value, &amp;s)) {
      // Done
    } else if (imm != NULL &amp;&amp; imm-&gt;Get(lkey, value, &amp;s)) {
      // Done
    } else {
      s = current-&gt;Get(options, lkey, value, &amp;stats);
      have_stat_update = true; // &#26597;&#35810;&#30913;&#30424;&#30340;&#35805;&#20250;&#36827;&#34892;&#26631;&#35760;.
    }
    mutex_.Lock();
  }

  // &#24471;&#21040;&#30340;&#20869;&#23481;&#20250;&#21453;&#39304;&#21040;&#24403;&#21069;&#30340;version&#37324;&#38754;&#28982;&#21518;&#23581;&#35797;&#35302;&#21457;compaction.
  if (have_stat_update &amp;&amp; current-&gt;UpdateStats(stats)) {
    MaybeScheduleCompaction();
  }
  mem-&gt;Unref();
  if (imm != NULL) imm-&gt;Unref();
  current-&gt;Unref();
  return s;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-3-32" class="outline-6">
<h6 id="sec-1-10-3-3-32"><span class="section-number-6">1.10.3.3.32</span> NewInternalIterator</h6>
<div class="outline-text-6" id="text-1-10-3-3-32">

<p>开辟内部的迭代器.但是功能上来说基本上以及完成了db::iterator所需要完成的工作.但是需要
注意这里面merge iterator接口是针对internal key的，所以外部的话还是需要保证user key
并且配合sequence number的行为.另外还需要考虑存在deletion情况.
</p>


<pre class="src src-C++">struct IterState {
  port::Mutex* mu;
  Version* version;
  MemTable* mem;
  MemTable* imm;
};

static void CleanupIteratorState(void* arg1, void* arg2) {
  IterState* state = reinterpret_cast&lt;IterState*&gt;(arg1);
  state-&gt;mu-&gt;Lock();
  state-&gt;mem-&gt;Unref();
  if (state-&gt;imm != NULL) state-&gt;imm-&gt;Unref();
  state-&gt;version-&gt;Unref();
  state-&gt;mu-&gt;Unlock();
  delete state;
}

Iterator* DBImpl::NewInternalIterator(const ReadOptions&amp; options,
                                      SequenceNumber* latest_snapshot) {
  IterState* cleanup = new IterState;
  mutex_.Lock();
  *latest_snapshot = versions_-&gt;LastSequence();

  // &#23558;&#21487;&#33021;&#23384;&#22312;&#30340;iterator&#25918;&#22312;&#19968;&#20010;list&#37324;&#38754;&#20570;&#25104;&#19968;&#20010;merge list&#20869;&#23481;.
  // Collect together all needed child iterators
  std::vector&lt;Iterator*&gt; list;
  // &#39318;&#20808;memtable&#19979;&#38754;&#38656;&#35201;&#36941;&#21382;.
  list.push_back(mem_-&gt;NewIterator());
  mem_-&gt;Ref();
  // &#20854;&#27425;imm memtable&#38656;&#35201;&#36941;&#21382;
  if (imm_ != NULL) {
    list.push_back(imm_-&gt;NewIterator());
    imm_-&gt;Ref();
  }
  // &#23545;&#20110;version&#26469;&#35828;&#21487;&#33021;&#23384;&#22312;&#24456;&#22810;&#25991;&#20214;&#38656;&#35201;&#36941;&#21382;.
  versions_-&gt;current()-&gt;AddIterators(options, &amp;list);
  // &#23558;&#36825;&#20123;&#20869;&#23481;&#26500;&#36896;&#31216;&#20026;&#19968;&#20010;merge iterator.
  // &#27880;&#24847;&#36825;&#37324;&#30340;&#20869;&#23481;&#37117;&#21152;&#20102;&#24341;&#29992;&#35745;&#25968;.
  Iterator* internal_iter =
      NewMergingIterator(&amp;internal_comparator_, &amp;list[0], list.size());
  versions_-&gt;current()-&gt;Ref();

  // &#28982;&#21518;&#23558;&#36825;&#20123;&#37322;&#25918;&#20869;&#23481;&#23384;&#25918;&#22312;internal iter&#38144;&#27585;&#22238;&#35843;&#37324;&#38754;.
  cleanup-&gt;mu = &amp;mutex_;
  cleanup-&gt;mem = mem_;
  cleanup-&gt;imm = imm_;
  cleanup-&gt;version = versions_-&gt;current();
  internal_iter-&gt;RegisterCleanup(CleanupIteratorState, cleanup, NULL);

  mutex_.Unlock();
  return internal_iter;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-3-33" class="outline-6">
<h6 id="sec-1-10-3-3-33"><span class="section-number-6">1.10.3.3.33</span> NewInterator</h6>
<div class="outline-text-6" id="text-1-10-3-3-33">

<p>实现在DBIter里面.工厂方式进行创建.
</p>


<pre class="src src-C++">Iterator* DBImpl::NewIterator(const ReadOptions&amp; options) {
  // &#20102;&#35299;&#24403;&#21069;&#26368;&#36817;&#30340;snapshot sequence number.
  SequenceNumber latest_snapshot;
  Iterator* internal_iter = NewInternalIterator(options, &amp;latest_snapshot);
  // &#35843;&#29992;NewDBIterator&#26469;&#36827;&#34892;&#21019;&#24314;.&#20855;&#20307;&#21487;&#20197;&#26597;&#30475;DBIter&#23454;&#29616;.
  return NewDBIterator(
      &amp;dbname_, env_, user_comparator(), internal_iter,
      (options.snapshot != NULL
       ? reinterpret_cast&lt;const SnapshotImpl*&gt;(options.snapshot)-&gt;number_
       : latest_snapshot));
}
</pre>


</div>
</div>

</div>

<div id="outline-container-1-10-3-4" class="outline-5">
<h5 id="sec-1-10-3-4"><span class="section-number-5">1.10.3.4</span> DBIter</h5>
<div class="outline-text-5" id="text-1-10-3-4">

<p>db/db_iter.cc DBIter通过工厂方法创建.然后就DBIter结构以及里面的接口看看.
关于这个iterator的具体细节的话可以不用了解非常清楚，稍微了解工作原理即可。
实际上里面FindNextUserEntry和FindPrevUserEntry没有仔细阅读.:(.
</p>

</div>

<div id="outline-container-1-10-3-4-1" class="outline-6">
<h6 id="sec-1-10-3-4-1"><span class="section-number-6">1.10.3.4.1</span> NewDBIterator</h6>
<div class="outline-text-6" id="text-1-10-3-4-1">




<pre class="src src-C++">Iterator* NewDBIterator(
    const std::string* dbname,
    Env* env,
    const Comparator* user_key_comparator,
    Iterator* internal_iter,
    const SequenceNumber&amp; sequence) {
  return new DBIter(dbname, env, user_key_comparator, internal_iter, sequence);
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-4-2" class="outline-6">
<h6 id="sec-1-10-3-4-2"><span class="section-number-6">1.10.3.4.2</span> DBIter</h6>
<div class="outline-text-6" id="text-1-10-3-4-2">




<pre class="src src-C++">// Memtables and sstables that make the DB representation contain
// (userkey,seq,type) =&gt; uservalue entries.  DBIter
// combines multiple entries for the same userkey found in the DB
// representation into a single entry while accounting for sequence
// numbers, deletion markers, overwrites, etc.
class DBIter: public Iterator {
 public:
  // Which direction is the iterator currently moving?
  // (1) When moving forward, the internal iterator is positioned at
  //     the exact entry that yields this-&gt;key(), this-&gt;value()
  // (2) When moving backwards, the internal iterator is positioned
  //     just before all entries whose user key == this-&gt;key().
  enum Direction {
    kForward,
    kReverse
  };

  DBIter(const std::string* dbname, Env* env,
         const Comparator* cmp, Iterator* iter, SequenceNumber s)
      : dbname_(dbname),
        env_(env),
        user_comparator_(cmp),
        iter_(iter),
        sequence_(s),
        direction_(kForward), // &#40664;&#35748;&#26159;&#21521;&#21069;&#26597;&#25214;.
        valid_(false) { // &#24403;&#21069;&#27809;&#26377;&#20219;&#20309;kv.
  }
  virtual ~DBIter() {
    delete iter_;
  }
 private:
  const std::string* const dbname_;
  Env* const env_;
  const Comparator* const user_comparator_;
  Iterator* const iter_;
  SequenceNumber const sequence_;

  Status status_;
  // &#22914;&#26524;&#26159;kReverse&#26041;&#21521;&#30340;&#35805;,&#37027;&#20040;&#20174;&#36825;&#37324;&#36820;&#22238;
  // &#21542;&#21017;&#30452;&#25509;&#35843;&#29992;iter&#36820;&#22238;.
  std::string saved_key_;     // == current key when direction_==kReverse
  std::string saved_value_;   // == current raw value when direction_==kReverse
  Direction direction_;
  bool valid_;
};
</pre>


</div>

</div>

<div id="outline-container-1-10-3-4-3" class="outline-6">
<h6 id="sec-1-10-3-4-3"><span class="section-number-6">1.10.3.4.3</span> ClearSavedValue</h6>
<div class="outline-text-6" id="text-1-10-3-4-3">

<p>清除saved_value这个字段.好像有点技巧.可以看看代码啥的测试一下.
</p>


<pre class="src src-C++">inline void ClearSavedValue() {
  if (saved_value_.capacity() &gt; 1048576) { // &gt;1M&#30340;&#35805;&#37027;&#20040;&#30452;&#25509;swap.
    std::string empty;
    swap(empty, saved_value_);
  } else { // &#21542;&#21017;&#20351;&#29992;clear.
    saved_value_.clear();
  }
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-4-4" class="outline-6">
<h6 id="sec-1-10-3-4-4"><span class="section-number-6">1.10.3.4.4</span> ParseKey</h6>
<div class="outline-text-6" id="text-1-10-3-4-4">

<p>工作非常简单就是从iter得到对应的key.
</p>


<pre class="src src-C++">inline bool DBIter::ParseKey(ParsedInternalKey* ikey) {
  if (!ParseInternalKey(iter_-&gt;key(), ikey)) {
    status_ = Status::Corruption(<span style="color: #ffff00;">"corrupted internal key in DBIter"</span>);
    return false;
  } else {
    return true;
  }
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-4-5" class="outline-6">
<h6 id="sec-1-10-3-4-5"><span class="section-number-6">1.10.3.4.5</span> SaveKey</h6>
<div class="outline-text-6" id="text-1-10-3-4-5">




<pre class="src src-C++">inline void SaveKey(const Slice&amp; k, std::string* dst) {
  dst-&gt;assign(k.data(), k.size());
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-4-6" class="outline-6">
<h6 id="sec-1-10-3-4-6"><span class="section-number-6">1.10.3.4.6</span> Seek</h6>
<div class="outline-text-6" id="text-1-10-3-4-6">




<pre class="src src-C++">void DBIter::Seek(const Slice&amp; target) {
  direction_ = kForward;
  ClearSavedValue(); // &#23558;saved_value_&#28165;&#31354;.
  saved_key_.clear(); // &#23558;saved_key_&#28165;&#31354;.
  AppendInternalKey( // &#37325;&#26032;&#35774;&#32622;&#26597;&#35810;key.&#20445;&#23384;&#21040;saved_key_.
      &amp;saved_key_, ParsedInternalKey(target, sequence_, kValueTypeForSeek));
  iter_-&gt;Seek(saved_key_);
  if (iter_-&gt;Valid()) {
    FindNextUserEntry(false, &amp;saved_key_ /* temporary storage */);
  } else {
    valid_ = false;
  }
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-4-7" class="outline-6">
<h6 id="sec-1-10-3-4-7"><span class="section-number-6">1.10.3.4.7</span> Next</h6>
<div class="outline-text-6" id="text-1-10-3-4-7">




<pre class="src src-C++">void DBIter::Next() {
  assert(valid_);

  if (direction_ == kReverse) {  // Switch directions?
    direction_ = kForward;
    // iter_ is pointing just before the entries for this-&gt;key(),
    // so advance into the range of entries for this-&gt;key() and then
    // use the normal skipping code below.
    if (!iter_-&gt;Valid()) {
      iter_-&gt;SeekToFirst();
    } else {
      iter_-&gt;Next();
    }
    if (!iter_-&gt;Valid()) {
      valid_ = false;
      saved_key_.clear();
      return;
    }
  }

  // Temporarily use saved_key_ as storage for key to skip.
  std::string* skip = &amp;saved_key_;
  SaveKey(ExtractUserKey(iter_-&gt;key()), skip);
  FindNextUserEntry(true, skip);
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-4-8" class="outline-6">
<h6 id="sec-1-10-3-4-8"><span class="section-number-6">1.10.3.4.8</span> Prev</h6>
<div class="outline-text-6" id="text-1-10-3-4-8">




<pre class="src src-C++">void DBIter::Prev() {
  assert(valid_);

  if (direction_ == kForward) {  // Switch directions?
    // iter_ is pointing at the current entry.  Scan backwards until
    // the key changes so we can use the normal reverse scanning code.
    // &#39318;&#20808;&#21521;&#21069;&#19968;&#30452;&#25214;&#21040;&#30053;&#36807;&#24403;&#21069;saved_key&#30340;&#20869;&#23481;.
    assert(iter_-&gt;Valid());  // Otherwise valid_ would have been false
    SaveKey(ExtractUserKey(iter_-&gt;key()), &amp;saved_key_);
    while (true) {
      iter_-&gt;Prev();
      if (!iter_-&gt;Valid()) {
        valid_ = false;
        saved_key_.clear();
        ClearSavedValue();
        return;
      }
      if (user_comparator_-&gt;Compare(ExtractUserKey(iter_-&gt;key()),
                                    saved_key_) &lt; 0) {
        break;
      }
    }
    direction_ = kReverse;
  }

  FindPrevUserEntry();
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-4-9" class="outline-6">
<h6 id="sec-1-10-3-4-9"><span class="section-number-6">1.10.3.4.9</span> FindNextUserEntry</h6>
<div class="outline-text-6" id="text-1-10-3-4-9">

<p>我们需要考虑到在DBIter里面处理的是mergeiterator.多路的话可能会存在很多.
</p>
<p>
(dirlt):现在才发现原来在find的时候并没有将sequence number放在里面而仅仅是比较user key
的内容，然后将所有的user key内容放在一起然后来处理sequence.不过对于memtable等
在插入的时候还是按照user key+sequence来进行存放.按照这个理解的话很多事情就比较好懂了.
</p>
<p>
总感觉这个地方可能存在问题，没有考虑到delete k然后add k的情况.不过撇开这个问题就好理解多了，
我们这里得到skip之后的话就可以在next的时候需要越过skip这个key.因为上次已经得到这个key的内容了.
</p>


<pre class="src src-C++">void DBIter::FindNextUserEntry(bool skipping, std::string* skip) {
  // Loop until we hit an acceptable entry to yield
  assert(iter_-&gt;Valid());
  assert(direction_ == kForward);
  do {
    ParsedInternalKey ikey;
    if (ParseKey(&amp;ikey) &amp;&amp; ikey.sequence &lt;= sequence_) { // &#39318;&#20808;&#38656;&#35201;&#28385;&#36275;sequence.
      switch (ikey.type) {
        case kTypeDeletion: // &#22914;&#26524;&#26159;deletion&#30340;&#35805;,&#37027;&#20040;&#20445;&#23384;&#36825;&#20010;skip&#30340;&#20869;&#23481;.
          // Arrange to skip all upcoming entries for this key since
          // they are hidden by this deletion.
          SaveKey(ikey.user_key, skip);
          skipping = true;
          break;
        case kTypeValue:
          if (skipping &amp;&amp;
              user_comparator_-&gt;Compare(ikey.user_key, *skip) &lt;= 0) {
            // Entry hidden
          } else {
            valid_ = true;
            saved_key_.clear();
            return;
          }
          break;
      }
    }
    iter_-&gt;Next();
  } while (iter_-&gt;Valid());
  saved_key_.clear();
  valid_ = false;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-4-10" class="outline-6">
<h6 id="sec-1-10-3-4-10"><span class="section-number-6">1.10.3.4.10</span> FindPrevUserEntry</h6>
<div class="outline-text-6" id="text-1-10-3-4-10">




<pre class="src src-C++">void DBIter::FindPrevUserEntry() {
  assert(direction_ == kReverse);

  ValueType value_type = kTypeDeletion;
  if (iter_-&gt;Valid()) {
    do {
      ParsedInternalKey ikey;
      if (ParseKey(&amp;ikey) &amp;&amp; ikey.sequence &lt;= sequence_) {
        if ((value_type != kTypeDeletion) &amp;&amp;
            user_comparator_-&gt;Compare(ikey.user_key, saved_key_) &lt; 0) {
          // We encountered a non-deleted value in entries for previous keys,
          break;
        }
        value_type = ikey.type;
        if (value_type == kTypeDeletion) {
          saved_key_.clear();
          ClearSavedValue();
        } else {
          Slice raw_value = iter_-&gt;value();
          if (saved_value_.capacity() &gt; raw_value.size() + 1048576) {
            std::string empty;
            swap(empty, saved_value_);
          }
          SaveKey(ExtractUserKey(iter_-&gt;key()), &amp;saved_key_);
          saved_value_.assign(raw_value.data(), raw_value.size());
        }
      }
      iter_-&gt;Prev();
    } while (iter_-&gt;Valid());
  }

  if (value_type == kTypeDeletion) {
    // End
    valid_ = false;
    saved_key_.clear();
    ClearSavedValue();
    direction_ = kForward;
  } else {
    valid_ = true;
  }
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-4-11" class="outline-6">
<h6 id="sec-1-10-3-4-11"><span class="section-number-6">1.10.3.4.11</span> SeekToFirst</h6>
<div class="outline-text-6" id="text-1-10-3-4-11">




<pre class="src src-C++">void DBIter::SeekToFirst() {
  direction_ = kForward;
  ClearSavedValue();
  iter_-&gt;SeekToFirst();
  if (iter_-&gt;Valid()) {
    FindNextUserEntry(false, &amp;saved_key_ /* temporary storage */);
  } else {
    valid_ = false;
  }
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-4-12" class="outline-6">
<h6 id="sec-1-10-3-4-12"><span class="section-number-6">1.10.3.4.12</span> SeekToLast</h6>
<div class="outline-text-6" id="text-1-10-3-4-12">




<pre class="src src-C++">void DBIter::SeekToLast() {
  direction_ = kReverse;
  ClearSavedValue();
  iter_-&gt;SeekToLast();
  FindPrevUserEntry();
}
</pre>


</div>
</div>

</div>

<div id="outline-container-1-10-3-5" class="outline-5">
<h5 id="sec-1-10-3-5"><span class="section-number-5">1.10.3.5</span> LookupKey</h5>
<div class="outline-text-5" id="text-1-10-3-5">

<p>db/dbformat.h LookupKey是为了方便对不同的结构进行查询的key结构.抽象出来的话会使得操作更加方便.
我们只需要传入我们的user_key之后的话，那么就可以构造出对应查询结构的key.首先我们看看结构
</p>


<pre class="src src-C++">// A helper class useful for DBImpl::Get()
class LookupKey {
 public:
  // Initialize *this for looking up user_key at a snapshot with
  // the specified sequence number.
  LookupKey(const Slice&amp; user_key, SequenceNumber sequence);

  ~LookupKey();

  // Return a key suitable for lookup in a MemTable.
  // &#36820;&#22238;&#33021;&#22815;&#20026;memtable&#26597;&#35810;&#30340;key.
  Slice memtable_key() const { return Slice(start_, end_ - start_); }

  // Return an internal key (suitable for passing to an internal iterator)
  // &#36820;&#22238;internal key.&#36825;&#20010;&#24212;&#35813;&#26159;&#20316;&#20026;sstable&#26597;&#35810;&#30340;key.
  // &#21518;&#38754;&#25105;&#20204;&#30475;&#30475;InternalKey&#30340;&#32467;&#26500;.
  Slice internal_key() const { return Slice(kstart_, end_ - kstart_); }

  // &#36820;&#22238;user_key&#26412;&#36523;.
  // Return the user key
  Slice user_key() const { return Slice(kstart_, end_ - kstart_ - 8); }

 private:
  // &#36825;&#37324;&#38754;&#32473;&#20986;&#20102;&#20256;&#20837;user_key&#20043;&#21518;&#26500;&#36896;&#20986;key&#30340;&#26684;&#24335;.
  // We construct a char array of the form:
  //    klength  varint32               &lt;-- start_
  //    userkey  char[klength]          &lt;-- kstart_
  //    tag      uint64
  //                                    &lt;-- end_
  // The array is a suitable MemTable key.
  // The suffix starting with <span style="color: #ffff00;">"userkey"</span> can be used as an InternalKey.
  const char* start_;
  const char* kstart_;
  const char* end_;
  char space_[200];      // Avoid allocation for short keys
};
</pre>

<p>
结构非常好理解，在看看构造函数和析构函数即可
</p>


<pre class="src src-C++">inline LookupKey::~LookupKey() {
  // &#36825;&#37324;space_&#26159;&#20026;&#20102;&#23545;&#20110;short keys&#19981;&#36827;&#34892;&#20998;&#37197;.
  if (start_ != space_) delete[] start_;
}

LookupKey::LookupKey(const Slice&amp; user_key, SequenceNumber s) {
  size_t usize = user_key.size();
  // klength&#21344;&#29992;5&#20010;&#23383;&#33410;
  // tag&#21344;&#29992;8&#20010;&#23383;&#33410;.
  size_t needed = usize + 13;  // A conservative estimate
  char* dst;
  if (needed &lt;= sizeof(space_)) {
    dst = space_;
  } else {
    dst = new char[needed];
  }
  start_ = dst;
  dst = EncodeVarint32(dst, usize + 8);
  kstart_ = dst;
  memcpy(dst, user_key.data(), usize);
  dst += usize;
  EncodeFixed64(dst, PackSequenceAndType(s, kValueTypeForSeek));
  dst += 8;
  end_ = dst;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-6" class="outline-5">
<h5 id="sec-1-10-3-6"><span class="section-number-5">1.10.3.6</span> ValueType</h5>
<div class="outline-text-5" id="text-1-10-3-6">

<p>db/dbformat.h ValueType是存在于internal key内部的key类型.有普通类型和删除类型.
</p>


<pre class="src src-C++">// Value types encoded as the last component of internal keys.
// DO NOT CHANGE THESE ENUM VALUES: they are embedded in the on-disk
// data structures.
enum ValueType {
  kTypeDeletion = 0x0,
  kTypeValue = 0x1
};
// kValueTypeForSeek defines the ValueType that should be passed when
// constructing a ParsedInternalKey object for seeking to a particular
// sequence number (since we sort sequence numbers in decreasing order
// and the value type is embedded as the low 8 bits in the sequence
// number in internal keys, we need to use the highest-numbered
// ValueType, not the lowest).
static const ValueType kValueTypeForSeek = kTypeValue;
</pre>


</div>

</div>

<div id="outline-container-1-10-3-7" class="outline-5">
<h5 id="sec-1-10-3-7"><span class="section-number-5">1.10.3.7</span> SequenceNumber</h5>
<div class="outline-text-5" id="text-1-10-3-7">

<p>db/dbfotmat.h SequenceNumber也存在于internal key内部，表示这个key的序号。现在就我自己的理解，
能想到这个序号的用户就是用来完成snapshot.
</p>


<pre class="src src-C++">typedef uint64_t SequenceNumber;

// We leave eight bits empty at the bottom so a type and sequence#
// can be packed together into 64-bits.
static const SequenceNumber kMaxSequenceNumber =
    ((0x1ull &lt;&lt; 56) - 1);
</pre>


</div>

</div>

<div id="outline-container-1-10-3-8" class="outline-5">
<h5 id="sec-1-10-3-8"><span class="section-number-5">1.10.3.8</span> InternalKey</h5>
<div class="outline-text-5" id="text-1-10-3-8">

<p>db/dbformat.h InternalKey的实现一份还存在于MemTable里面.因为从WriteBatch是首先写入MemTable的.
这个部分MemTable并没有复用而是重新实现.InternalKey应该也存在于SSTable里面.内部非常简单就是std::string
存储打包之后的格式。里面的方法比较多但是都相对非常简单。
</p>


<pre class="src src-C++">// Modules in this directory should keep internal keys wrapped inside
// the following class instead of plain strings so that we do not
// incorrectly use string comparisons instead of an InternalKeyComparator.
class InternalKey {
 private:
  std::string rep_;
 public:
  InternalKey() { }   // Leave rep_ as empty to indicate it is invalid
  InternalKey(const Slice&amp; user_key, SequenceNumber s, ValueType t) {
    AppendInternalKey(&amp;rep_, ParsedInternalKey(user_key, s, t));
  }

  void DecodeFrom(const Slice&amp; s) { rep_.assign(s.data(), s.size()); }
  Slice Encode() const {
    assert(!rep_.empty());
    return rep_;
  }

  Slice user_key() const { return ExtractUserKey(rep_); }

  void SetFrom(const ParsedInternalKey&amp; p) {
    rep_.clear();
    AppendInternalKey(&amp;rep_, p);
  }

  void Clear() { rep_.clear(); }

  std::string DebugString() const;
};
</pre>



</div>

<div id="outline-container-1-10-3-8-1" class="outline-6">
<h6 id="sec-1-10-3-8-1"><span class="section-number-6">1.10.3.8.1</span> ExtracrUserKey</h6>
<div class="outline-text-6" id="text-1-10-3-8-1">

<p>之前我们知道user key是如何分布的了.后面8个字节有附加信息.
</p>


<pre class="src src-C++">inline Slice ExtractUserKey(const Slice&amp; internal_key) {
  assert(internal_key.size() &gt;= 8);
  return Slice(internal_key.data(), internal_key.size() - 8);
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-8-2" class="outline-6">
<h6 id="sec-1-10-3-8-2"><span class="section-number-6">1.10.3.8.2</span> ExtractValueType</h6>
<div class="outline-text-6" id="text-1-10-3-8-2">




<pre class="src src-C++">inline ValueType ExtractValueType(const Slice&amp; internal_key) {
  assert(internal_key.size() &gt;= 8);
  const size_t n = internal_key.size();
  uint64_t num = DecodeFixed64(internal_key.data() + n - 8);
  unsigned char c = num &amp; 0xff;
  return static_cast&lt;ValueType&gt;(c);
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-8-3" class="outline-6">
<h6 id="sec-1-10-3-8-3"><span class="section-number-6">1.10.3.8.3</span> ParsedInternalKey</h6>
<div class="outline-text-6" id="text-1-10-3-8-3">

<p>ParsedInternalKey是从InternalKey解析之后的表示.非常简单.
</p>


<pre class="src src-C++">struct ParsedInternalKey {
  Slice user_key;
  SequenceNumber sequence;
  ValueType type;

  ParsedInternalKey() { }  // Intentionally left uninitialized (for speed)
  ParsedInternalKey(const Slice&amp; u, const SequenceNumber&amp; seq, ValueType t)
      : user_key(u), sequence(seq), type(t) { }
  std::string DebugString() const;
};
</pre>


</div>

</div>

<div id="outline-container-1-10-3-8-4" class="outline-6">
<h6 id="sec-1-10-3-8-4"><span class="section-number-6">1.10.3.8.4</span> InternalKeyEncodingLength</h6>
<div class="outline-text-6" id="text-1-10-3-8-4">

<p>如果ParsedInternalKey打包称为InternalKey的长度.
</p>


<pre class="src src-C++">// Return the length of the encoding of <span style="color: #ffff00;">"key"</span>.
inline size_t InternalKeyEncodingLength(const ParsedInternalKey&amp; key) {
  return key.user_key.size() + 8;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-8-5" class="outline-6">
<h6 id="sec-1-10-3-8-5"><span class="section-number-6">1.10.3.8.5</span> AppendInternalKey</h6>
<div class="outline-text-6" id="text-1-10-3-8-5">

<p>将ParsedInternalKey直接序列化到二进制格式.
</p>


<pre class="src src-C++">void AppendInternalKey(std::string* result, const ParsedInternalKey&amp; key) {
  result-&gt;append(key.user_key.data(), key.user_key.size());
  PutFixed64(result, PackSequenceAndType(key.sequence, key.type));
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-8-6" class="outline-6">
<h6 id="sec-1-10-3-8-6"><span class="section-number-6">1.10.3.8.6</span> PackSequenceAndType</h6>
<div class="outline-text-6" id="text-1-10-3-8-6">

<p>sequence number占据高56bits,type占据低8bits
</p>


<pre class="src src-C++">static uint64_t PackSequenceAndType(uint64_t seq, ValueType t) {
  assert(seq &lt;= kMaxSequenceNumber);
  assert(t &lt;= kValueTypeForSeek);
  return (seq &lt;&lt; 8) | t;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-8-7" class="outline-6">
<h6 id="sec-1-10-3-8-7"><span class="section-number-6">1.10.3.8.7</span> ParseInternalKey</h6>
<div class="outline-text-6" id="text-1-10-3-8-7">

<p>根据InternalKey解析出ParsedInternalKey
</p>


<pre class="src src-C++">inline bool ParseInternalKey(const Slice&amp; internal_key,
                             ParsedInternalKey* result) {
  const size_t n = internal_key.size();
  if (n &lt; 8) return false;
  uint64_t num = DecodeFixed64(internal_key.data() + n - 8);
  unsigned char c = num &amp; 0xff;
  result-&gt;sequence = num &gt;&gt; 8;
  result-&gt;type = static_cast&lt;ValueType&gt;(c);
  result-&gt;user_key = Slice(internal_key.data(), n - 8);
  return (c &lt;= static_cast&lt;unsigned char&gt;(kTypeValue));
}
</pre>


</div>
</div>

</div>

<div id="outline-container-1-10-3-9" class="outline-5">
<h5 id="sec-1-10-3-9"><span class="section-number-5">1.10.3.9</span> InternalKeyComparator</h5>
<div class="outline-text-5" id="text-1-10-3-9">

<p>db/dbformat.cc 我们在MemTable::KeyComparator::operator()里面看到了调用InternalKeyComparator的Compare方法.
Compare接收两个Slice对象。对象是这样encode的,key_size + key_data + (seq &lt;&lt; 8) | type(8 bytes).
其中key_size包括了后面附加的8个字节.我们来看看InternalKeyComparator是怎么实现的.底层的Comparator是用来直接比较UserKey的，
没有考虑sequence number.
</p>


<pre class="src src-C++">// A comparator for internal keys that uses a specified comparator for
// the user key portion and breaks ties by decreasing sequence number.
class InternalKeyComparator : public Comparator {
 private:
  const Comparator* user_comparator_;
 public:
  explicit InternalKeyComparator(const Comparator* c) : user_comparator_(c) { }
  virtual const char* Name() const; // <span style="color: #ffff00;">"leveldb.InternalKeyComparator"</span>
  virtual int Compare(const Slice&amp; a, const Slice&amp; b) const;
  virtual void FindShortestSeparator(
      std::string* start,
      const Slice&amp; limit) const;
  virtual void FindShortSuccessor(std::string* key) const;

  const Comparator* user_comparator() const { return user_comparator_; }

  int Compare(const InternalKey&amp; a, const InternalKey&amp; b) const;
};
</pre>



</div>

<div id="outline-container-1-10-3-9-1" class="outline-6">
<h6 id="sec-1-10-3-9-1"><span class="section-number-6">1.10.3.9.1</span> Compare</h6>
<div class="outline-text-6" id="text-1-10-3-9-1">




<pre class="src src-C++">int InternalKeyComparator::Compare(const Slice&amp; akey, const Slice&amp; bkey) const {
  // Order by:
  //    increasing user key (according to user-supplied comparator)
  //    decreasing sequence number
  //    decreasing type (though sequence# should be enough to disambiguate)
  int r = user_comparator_-&gt;Compare(ExtractUserKey(akey), ExtractUserKey(bkey));
  if (r == 0) {
    const uint64_t anum = DecodeFixed64(akey.data() + akey.size() - 8);
    const uint64_t bnum = DecodeFixed64(bkey.data() + bkey.size() - 8);
    if (anum &gt; bnum) { // &#25353;&#29031;sequence number&#27604;&#36739;.
     // &#20043;&#21069;&#25105;&#20204;&#22312;MemTableInserter&#37324;&#38754;&#21487;&#20197;&#30475;&#21040;sequence number&#26159;&#19981;&#26029;&#22686;&#21152;&#30340;.
      r = -1;
    } else if (anum &lt; bnum) {
      r = +1;
    }
  }
  return r;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-9-2" class="outline-6">
<h6 id="sec-1-10-3-9-2"><span class="section-number-6">1.10.3.9.2</span> FindShortestSeparator</h6>
<div class="outline-text-6" id="text-1-10-3-9-2">




<pre class="src src-C++">void InternalKeyComparator::FindShortestSeparator(
      std::string* start,
      const Slice&amp; limit) const {
  // Attempt to shorten the user portion of the key
  Slice user_start = ExtractUserKey(*start);
  Slice user_limit = ExtractUserKey(limit);
  std::string tmp(user_start.data(), user_start.size());
  // &#39318;&#20808;&#20351;&#29992;user_comparator&#25214;&#21040;&#26356;&#30701;&#30340;
  user_comparator_-&gt;FindShortestSeparator(&amp;tmp, user_limit);
  if (tmp.size() &lt; user_start.size() &amp;&amp; // &#28982;&#21518;&#27604;&#36739;&#26159;&#21542;&#30495;&#30340;&#26356;&#30701;.
      user_comparator_-&gt;Compare(user_start, tmp) &lt; 0) {
    // &#22914;&#26524;&#26356;&#30701;&#30340;&#35805;&#65292;&#37027;&#20040;&#20250;&#23558;&#21518;&#38754;&#30340;8&#20010;&#23383;&#33410;&#34917;&#40784;
    // &#36825;&#37324;&#30340;8&#20010;&#23383;&#33410;&#20351;&#29992;kMaxSequenceNumber&#20197;&#21450;kValueTypeForSeek
    // &#20854;&#20013;kMaxSequenceNumber == (1 &lt;&lt; 56)-1
    // &#32780;kValueTypeForSeek == KValueType.(&#23601;&#26159;&#26222;&#36890;&#30340;kv&#31867;&#22411;)
    // User key has become shorter physically, but larger logically.
    // Tack on the earliest possible number to the shortened user key.
    PutFixed64(&amp;tmp, PackSequenceAndType(kMaxSequenceNumber,kValueTypeForSeek));
    assert(this-&gt;Compare(*start, tmp) &lt; 0);
    assert(this-&gt;Compare(tmp, limit) &lt; 0);
    start-&gt;swap(tmp);
  }
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-9-3" class="outline-6">
<h6 id="sec-1-10-3-9-3"><span class="section-number-6">1.10.3.9.3</span> FindShortSuccessor</h6>
<div class="outline-text-6" id="text-1-10-3-9-3">




<pre class="src src-C++">void InternalKeyComparator::FindShortSuccessor(std::string* key) const {
  Slice user_key = ExtractUserKey(*key);
  std::string tmp(user_key.data(), user_key.size());
  user_comparator_-&gt;FindShortSuccessor(&amp;tmp); // &#39318;&#20808;&#36890;&#36807;user_comparator_&#25214;&#21040;&#19979;&#19968;&#20010;
  if (tmp.size() &lt; user_key.size() &amp;&amp;
      user_comparator_-&gt;Compare(user_key, tmp) &lt; 0) {
    // &#22914;&#26524;&#30830;&#23454;&#26356;&#30701;&#30340;&#35805;&#37027;&#20040;&#20250;&#21152;&#19978;&#29305;&#23450;&#30340;8&#23383;&#33410;&#38468;&#21152;&#20449;&#24687;.
    // &#20851;&#20110;&#38468;&#21152;&#20449;&#24687;&#22312;&#19978;&#38754;&#37027;&#20010;&#20989;&#25968;&#24050;&#32463;&#35299;&#37322;&#36807;&#20102;.
    // User key has become shorter physically, but larger logically.
    // Tack on the earliest possible number to the shortened user key.
    PutFixed64(&amp;tmp, PackSequenceAndType(kMaxSequenceNumber,kValueTypeForSeek));
    assert(this-&gt;Compare(*key, tmp) &lt; 0);
    key-&gt;swap(tmp);
  }
}
</pre>


</div>
</div>

</div>

<div id="outline-container-1-10-3-10" class="outline-5">
<h5 id="sec-1-10-3-10"><span class="section-number-5">1.10.3.10</span> FileMetaData</h5>
<div class="outline-text-5" id="text-1-10-3-10">

<p>db/version_edit.h 对于一个sstable的元信息表示.
</p>


<pre class="src src-C++">struct FileMetaData {
  int refs;
  // &#39318;&#20808;&#20250;&#35774;&#32622;&#19968;&#20010;&#21021;&#20540;
  int allowed_seeks;          // Seeks allowed until compaction
  uint64_t number; // file_number.&#27604;&#22914;1.sst.&#36825;&#20010;&#32467;&#21512;BuildTable&#21644;TableCache&#21487;&#20197;&#29702;&#35299;&#24847;&#24605;.
  uint64_t file_size;         // File size in bytes
  InternalKey smallest;       // Smallest internal key served by table
  InternalKey largest;        // Largest internal key served by table

  FileMetaData() : refs(0), allowed_seeks(1 &lt;&lt; 30), file_size(0) { }
};
</pre>


</div>

</div>

<div id="outline-container-1-10-3-11" class="outline-5">
<h5 id="sec-1-10-3-11"><span class="section-number-5">1.10.3.11</span> Version</h5>
<div class="outline-text-5" id="text-1-10-3-11">

<p>db/version_set.h 对于Version可以理解为每个Snapshot对应的内容。因为每个snapshot可能需要持有不同的文件，
这样Version里面可以带上所需要管理的文件。如果释放Snapshot的话并且也可以释放Version的话，那么就可以认为这些文件
没有被任何Snapshot所引用就可以被回收。首先看看Version结构题里面的字段。
</p>


<pre class="src src-C++">class Version {
 public:
  // private:
 public:
  friend class Compaction;
  friend class VersionSet;

  class LevelFileNumIterator;
  Iterator* NewConcatenatingIterator(const ReadOptions&amp;, int level) const;

  VersionSet* vset_;            // VersionSet to which this Version belongs
  Version* next_;               // Next version in linked list
  Version* prev_;               // Previous version in linked list
  int refs_;                    // Number of live refs to this version

  // List of files per level
  // &#27599;&#20010;level&#30340;files_&#37117;&#26159;&#32463;&#36807;&#25490;&#24207;&#30340;&#12290;
  // &#23545;&#20110;level0&#21487;&#33021;&#23384;&#22312;overlap,&#23545;&#20110;level-x&#19981;&#23384;&#22312;overlap.
  std::vector&lt;FileMetaData*&gt; files_[config::kNumLevels]; // &#36825;&#20010;version&#22312;&#21508;&#20010;level&#20445;&#25345;&#30340;&#25991;&#20214;.

  // Next file to compact based on seek stats.
  // &#26681;&#25454;seek&#30340;&#32479;&#35745;&#19979;&#27425;&#38656;&#35201;&#36827;&#34892;compact&#30340;&#25991;&#20214;.
  FileMetaData* file_to_compact_;  // &#19979;&#27425;&#36827;&#34892;compact&#25991;&#20214;
  int file_to_compact_level_; // &#36825;&#20010;&#25991;&#20214;&#25152;&#22312;&#30340;level.

  // Level that should be compacted next and its compaction score.
  // Score &lt; 1 means compaction is not strictly needed.  These fields
  // are initialized by Finalize().
  double compaction_score_;
  int compaction_level_;

  // &#26500;&#36896;&#20989;&#25968;&#38750;&#24120;&#31616;&#21333;.
  explicit Version(VersionSet* vset)
      : vset_(vset), next_(this), prev_(this), refs_(0),
        file_to_compact_(NULL),
        file_to_compact_level_(-1),
        compaction_score_(-1),
        compaction_level_(-1) {
  }

  ~Version();
};
</pre>



</div>

<div id="outline-container-1-10-3-11-1" class="outline-6">
<h6 id="sec-1-10-3-11-1"><span class="section-number-6">1.10.3.11.1</span> AddIterators</h6>
<div class="outline-text-6" id="text-1-10-3-11-1">

<p>将所持有的所有的level文件打开并且返回iterator.从注释上来看的话得到这些iterators的话是为了进行merge.
</p>


<pre class="src src-C++">void Version::AddIterators(const ReadOptions&amp; options,
                           std::vector&lt;Iterator*&gt;* iters) {
  // Merge all level zero files together since they may overlap
  // &#25171;&#24320;&#25152;&#26377;&#30340;level0&#25991;&#20214;.
  for (size_t i = 0; i &lt; files_[0].size(); i++) {
    iters-&gt;push_back(
        vset_-&gt;table_cache_-&gt;NewIterator(
            options, files_[0][i]-&gt;number, files_[0][i]-&gt;file_size));
  }

  // &#25171;&#24320;&#20854;&#20182;level&#30340;&#25991;&#20214;.&#20851;&#20110;&#36825;&#20010;concatenating&#21518;&#38754;&#20250;&#20180;&#32454;&#20998;&#26512;.
  // For levels &gt; 0, we can use a concatenating iterator that sequentially
  // walks through the non-overlapping files in the level, opening them
  // lazily.
  for (int level = 1; level &lt; config::kNumLevels; level++) {
    if (!files_[level].empty()) {
      iters-&gt;push_back(NewConcatenatingIterator(options, level));
    }
  }
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-11-2" class="outline-6">
<h6 id="sec-1-10-3-11-2"><span class="section-number-6">1.10.3.11.2</span> NewConcatenatingIterator</h6>
<div class="outline-text-6" id="text-1-10-3-11-2">




<pre class="src src-C++">Iterator* Version::NewConcatenatingIterator(const ReadOptions&amp; options,
                                            int level) const {
  return NewTwoLevelIterator(
      // &#27880;&#24847;&#36825;&#37324;&#30340;level&gt;1.&#27599;&#20010;&#25991;&#20214;&#20043;&#38388;&#26159;&#27809;&#26377;overlap&#30340;.
      // &#24182;&#19988;&#36825;&#37324;&#25105;&#20204;&#20063;&#21487;&#20197;&#30693;&#36947;files_&#23545;&#20110;meta&#20043;&#38388;&#37117;&#26159;&#36827;&#34892;&#20102;&#25490;&#24207;&#30340;&#12290;
      new LevelFileNumIterator(vset_-&gt;icmp_, &amp;files_[level]), // &#19968;&#32423;&#36941;&#21382;&#22120;&#37319;&#29992;LevelFileNumberIterator.
      // &#26144;&#23556;&#21040;&#20108;&#32423;&#36941;&#21382;&#22120;&#30340;&#35805;&#20351;&#29992;GetFileIterator&#26469;&#33719;&#24471;.
      &amp;GetFileIterator, vset_-&gt;table_cache_, options);
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-11-3" class="outline-6">
<h6 id="sec-1-10-3-11-3"><span class="section-number-6">1.10.3.11.3</span> LevelFileNumIterator</h6>
<div class="outline-text-6" id="text-1-10-3-11-3">

<p>结构应该非常简单，我们大致看看即可。主要是关心一下二级映射函数GetFileIterator.对于
key的话采用这个filemetadata里面的最大的key,而value采用filenumber+filesize表示.
</p>


<pre class="src src-C++">class Version::LevelFileNumIterator : public Iterator {
 public:
  LevelFileNumIterator(const InternalKeyComparator&amp; icmp,
                       const std::vector&lt;FileMetaData*&gt;* flist)
      : icmp_(icmp),
        flist_(flist),
        index_(flist-&gt;size()) {        // Marks as invalid
  }
  virtual bool Valid() const {
    return index_ &lt; flist_-&gt;size();
  }
  virtual void Seek(const Slice&amp; target) {
    index_ = FindFile(icmp_, *flist_, target); // &#25214;&#21040;&#36825;&#20010;target&#25152;&#23384;&#22312;&#30340;&#26368;&#23567;&#30340;index.
    // &#36825;&#20010;&#21518;&#38754;&#20250;&#20855;&#20307;&#20998;&#26512;.&#20043;&#21069;&#30475;&#21040;&#20102;&#36825;&#23618;level&#37117;&#26159;disjoint&#30340;
    // &#25152;&#20197;&#22312;FindFile&#37324;&#38754;&#21487;&#20197;&#26681;&#25454;smallest&#20063;&#21487;&#20197;&#26681;&#25454;largest&#26469;&#36827;&#34892;&#26597;&#25214;.
  }
  virtual void SeekToFirst() { index_ = 0; }
  virtual void SeekToLast() {
    index_ = flist_-&gt;empty() ? 0 : flist_-&gt;size() - 1;
  }
  virtual void Next() {
    assert(Valid());
    index_++;
  }
  virtual void Prev() {
    assert(Valid());
    if (index_ == 0) {
      index_ = flist_-&gt;size();  // Marks as invalid
    } else {
      index_--;
    }
  }
  Slice key() const {
    assert(Valid());
    return (*flist_)[index_]-&gt;largest.Encode();
  }
  Slice value() const {
    assert(Valid()); // file_number + file_size.
    // &#20851;&#20110;&#22914;&#20309;&#20351;&#29992;&#36825;&#20010;value.&#24212;&#35813;&#26159;&#26681;&#25454;&#36825;&#20010;value&#23545;&#24212;&#21040;&#36825;&#20010;&#20855;&#20307;&#25991;&#20214;&#30340;iterator.
    EncodeFixed64(value_buf_, (*flist_)[index_]-&gt;number);
    EncodeFixed64(value_buf_+8, (*flist_)[index_]-&gt;file_size);
    return Slice(value_buf_, sizeof(value_buf_));
  }
  virtual Status status() const { return Status::OK(); }
 private:
  const InternalKeyComparator icmp_;
  const std::vector&lt;FileMetaData*&gt;* const flist_;
  uint32_t index_;

  // Backing store for value().  Holds the file number and size.
  mutable char value_buf_[16];
};
</pre>


</div>

</div>

<div id="outline-container-1-10-3-11-4" class="outline-6">
<h6 id="sec-1-10-3-11-4"><span class="section-number-6">1.10.3.11.4</span> GetFileIterator</h6>
<div class="outline-text-6" id="text-1-10-3-11-4">

<p>根据上面的分析file_value就是file_number + file_size.这里我们可以知道file_number应该是全局唯一的，
而不是在level上面唯一的。关于TableCache后面会分析。
</p>


<pre class="src src-C++">static Iterator* GetFileIterator(void* arg,
                                 const ReadOptions&amp; options,
                                 const Slice&amp; file_value) {
  TableCache* cache = reinterpret_cast&lt;TableCache*&gt;(arg);
  if (file_value.size() != 16) {
    return NewErrorIterator(
        Status::Corruption(<span style="color: #ffff00;">"FileReader invoked with unexpected value"</span>));
  } else {
    return cache-&gt;NewIterator(options,
                              DecodeFixed64(file_value.data()),
                              DecodeFixed64(file_value.data() + 8));
  }
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-11-5" class="outline-6">
<h6 id="sec-1-10-3-11-5"><span class="section-number-6">1.10.3.11.5</span> FindFile</h6>
<div class="outline-text-6" id="text-1-10-3-11-5">

<p>db/version_set.h 语义直接阅读注释即可.注意这里files都是排好序并且是不重叠的。按照二分法搜索largest key即可.
</p>


<pre class="src src-C++">// Return the smallest index i such that files[i]-&gt;largest &gt;= key.
// Return files.size() if there is no such file.
// REQUIRES: <span style="color: #ffff00;">"files"</span> contains a sorted list of non-overlapping files.
int FindFile(const InternalKeyComparator&amp; icmp,
             const std::vector&lt;FileMetaData*&gt;&amp; files,
             const Slice&amp; key) {
  uint32_t left = 0;
  uint32_t right = files.size();
  while (left &lt; right) {
    uint32_t mid = (left + right) / 2;
    const FileMetaData* f = files[mid];
    if (icmp.InternalKeyComparator::Compare(f-&gt;largest.Encode(), key) &lt; 0) {
      // Key at <span style="color: #ffff00;">"mid.largest"</span> is &lt; <span style="color: #ffff00;">"target"</span>.  Therefore all
      // files at or before <span style="color: #ffff00;">"mid"</span> are uninteresting.
      left = mid + 1;
    } else {
      // Key at <span style="color: #ffff00;">"mid.largest"</span> is &gt;= <span style="color: #ffff00;">"target"</span>.  Therefore all files
      // after <span style="color: #ffff00;">"mid"</span> are uninteresting.
      right = mid;
    }
  }
  return right;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-11-6" class="outline-6">
<h6 id="sec-1-10-3-11-6"><span class="section-number-6">1.10.3.11.6</span> SomeFileOverlapsRange</h6>
<div class="outline-text-6" id="text-1-10-3-11-6">

<p>db/version_set.h 判断是否有文件和某个范围[smallest,largest]相交.注意这里这里files也是按照key排序的.
</p>


<pre class="src src-C++">// Returns true iff some file in <span style="color: #ffff00;">"files"</span> overlaps the user key range
// [*smallest,*largest].
// smallest==NULL represents a key smaller than all keys in the DB.
// largest==NULL represents a key largest than all keys in the DB.
// REQUIRES: If disjoint_sorted_files, files[] contains disjoint ranges
//           in sorted order.
bool SomeFileOverlapsRange(
    const InternalKeyComparator&amp; icmp,
    bool disjoint_sorted_files, // &#34920;&#31034;files
    const std::vector&lt;FileMetaData*&gt;&amp; files,
    const Slice* smallest_user_key,
    const Slice* largest_user_key) {
  const Comparator* ucmp = icmp.user_comparator();
  if (!disjoint_sorted_files) {
    // &#22914;&#26524;&#25991;&#20214;&#20043;&#38388;&#21487;&#33021;&#23384;&#22312;overlap&#30340;&#35805;.&#37027;&#20040;&#24517;&#39035;&#39034;&#24207;.
    // &#37027;&#20040;&#38656;&#35201;&#36941;&#21382;&#27599;&#20010;&#25991;&#20214;.&#21028;&#26029;&#36825;&#20010;&#25991;&#20214;&#26159;&#21542;&#21644;[small,large]&#30456;&#20132;.
    // &#22914;&#26524;&#26377;&#30456;&#20132;&#65292;&#37027;&#20040;&#30452;&#25509;&#36820;&#22238;.:).
    // Need to check against all files
    for (int i = 0; i &lt; files.size(); i++) {
      const FileMetaData* f = files[i];
      // AfterFile&#21644;BeforeFile&#31245;&#21518;&#20998;&#26512;.
      if (AfterFile(ucmp, smallest_user_key, f) ||
          BeforeFile(ucmp, largest_user_key, f)) {
        // No overlap
      } else {
        return true;  // Overlap
      }
    }
    return false;
  }

  // &#22914;&#26524;&#25991;&#20214;&#26412;&#36523;&#20043;&#38388;&#27809;&#26377;overlap&#30340;&#35805;.
  // &#37027;&#20040;&#25105;&#20204;&#21482;&#38656;&#35201;&#39318;&#20808;&#25353;&#29031;&#20108;&#20998;&#26041;&#27861;&#25214;&#21040;&#30456;&#20132;&#25991;&#20214;index.
  // &#28982;&#21518;&#38024;&#23545;&#36825;&#20010;index&#20998;&#26512;&#21363;&#21487;.
  // Binary search over file list
  uint32_t index = 0;
  if (smallest_user_key != NULL) {
    // Find the earliest possible internal key for smallest_user_key
    InternalKey small(*smallest_user_key, kMaxSequenceNumber,kValueTypeForSeek);
    index = FindFile(icmp, files, small.Encode());
  }

  if (index &gt;= files.size()) {
    // beginning of range is after all files, so no overlap.
    return false;
  }

  return !BeforeFile(ucmp, largest_user_key, files[index]);
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-11-7" class="outline-6">
<h6 id="sec-1-10-3-11-7"><span class="section-number-6">1.10.3.11.7</span> AfterFile</h6>
<div class="outline-text-6" id="text-1-10-3-11-7">

<p>判断user_key是否在这个file之后.
</p>


<pre class="src src-C++">static bool AfterFile(const Comparator* ucmp,
                      const Slice* user_key, const FileMetaData* f) {
  // NULL user_key occurs before all keys and is therefore never after *f
  return (user_key != NULL &amp;&amp;
          ucmp-&gt;Compare(*user_key, f-&gt;largest.user_key()) &gt; 0);
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-11-8" class="outline-6">
<h6 id="sec-1-10-3-11-8"><span class="section-number-6">1.10.3.11.8</span> BeforeFile</h6>
<div class="outline-text-6" id="text-1-10-3-11-8">

<p>判断user_key是否在这个file之前.
</p>


<pre class="src src-C++">static bool BeforeFile(const Comparator* ucmp,
                       const Slice* user_key, const FileMetaData* f) {
  // NULL user_key occurs after all keys and is therefore never before *f
  return (user_key != NULL &amp;&amp;
          ucmp-&gt;Compare(*user_key, f-&gt;smallest.user_key()) &lt; 0);
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-11-9" class="outline-6">
<h6 id="sec-1-10-3-11-9"><span class="section-number-6">1.10.3.11.9</span> GetStats</h6>
<div class="outline-text-6" id="text-1-10-3-11-9">

<p>这个结构反应的是查询到的一些附加结果可以用来指导compaction.
</p>


<pre class="src src-C++">struct GetStats {
  FileMetaData* seek_file; // &#34987;seek&#21040;&#30340;&#25991;&#20214;
  int seek_file_level; // &#20197;&#21450;&#36825;&#20010;&#25991;&#20214;&#25152;&#22788;level.
};
</pre>


</div>

</div>

<div id="outline-container-1-10-3-11-10" class="outline-6">
<h6 id="sec-1-10-3-11-10"><span class="section-number-6">1.10.3.11.10</span> NewestFirst</h6>
<div class="outline-text-6" id="text-1-10-3-11-10">

<p>按照file_number进行排序.逆序.越迟生成的file那么是最新的。
</p>


<pre class="src src-C++">static bool NewestFirst(FileMetaData* a, FileMetaData* b) {
  return a-&gt;number &gt; b-&gt;number;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-11-11" class="outline-6">
<h6 id="sec-1-10-3-11-11"><span class="section-number-6">1.10.3.11.11</span> Get</h6>
<div class="outline-text-6" id="text-1-10-3-11-11">




<pre class="src src-C++">Status Version::Get(const ReadOptions&amp; options,
                    const LookupKey&amp; k,
                    std::string* value,
                    GetStats* stats) {
  Slice ikey = k.internal_key();
  Slice user_key = k.user_key();
  const Comparator* ucmp = vset_-&gt;icmp_.user_comparator();
  Status s;

  stats-&gt;seek_file = NULL;
  stats-&gt;seek_file_level = -1;
  FileMetaData* last_file_read = NULL;
  int last_file_read_level = -1;

  // We can search level-by-level since entries never hop across
  // levels.  Therefore we are guaranteed that if we find data
  // in an smaller level, later levels are irrelevant.
  std::vector&lt;FileMetaData*&gt; tmp;
  FileMetaData* tmp2;
  for (int level = 0; level &lt; config::kNumLevels; level++) {
    size_t num_files = files_[level].size();
    if (num_files == 0) continue;

    // Get the list of files to search in this level
    FileMetaData* const* files = &amp;files_[level][0];
    if (level == 0) {
      // Level-0 files may overlap each other.  Find all files that
      // overlap user_key and process them in order from newest to oldest.
      // &#22240;&#20026;level0&#23384;&#22312;&#37325;&#21472;&#65292;&#25152;&#20197;&#38656;&#35201;&#37117;&#36827;&#34892;&#25628;&#32034;.
      tmp.reserve(num_files);
      for (uint32_t i = 0; i &lt; num_files; i++) {
        FileMetaData* f = files[i];
        if (ucmp-&gt;Compare(user_key, f-&gt;smallest.user_key()) &gt;= 0 &amp;&amp;
            ucmp-&gt;Compare(user_key, f-&gt;largest.user_key()) &lt;= 0) {
          tmp.push_back(f);
        }
      }
      if (tmp.empty()) continue;
      // &#28982;&#21518;&#25353;&#29031;&#36827;&#34892;&#25490;&#24207;.&#26368;&#26032;&#29983;&#25104;&#30340;file&#25918;&#22312;&#26368;&#21069;&#38754;.
      std::sort(tmp.begin(), tmp.end(), NewestFirst);
      files = &amp;tmp[0];
      num_files = tmp.size();
    } else {
      // &#23545;&#20110;&#20854;&#20182;level&#30340;&#35805;&#36234;&#20302;level&#36234;&#26032;.&#24182;&#19988;level&#20869;&#37096;&#27809;&#26377;overlap
      // &#37027;&#20040;&#21487;&#20197;&#36890;&#36807;&#31616;&#21333;&#30340;&#20108;&#20998;&#27861;&#26469;&#21028;&#26029;&#21738;&#20010;&#25991;&#20214;.&#21482;&#20250;&#23384;&#22312;&#19968;&#20010;&#25991;&#20214;.
      // Binary search to find earliest index whose largest key &gt;= ikey.
      uint32_t index = FindFile(vset_-&gt;icmp_, files_[level], ikey);
      if (index &gt;= num_files) {
        files = NULL;
        num_files = 0;
      } else {
        tmp2 = files[index];
        if (ucmp-&gt;Compare(user_key, tmp2-&gt;smallest.user_key()) &lt; 0) {
          // All of <span style="color: #ffff00;">"tmp2"</span> is past any data for user_key
          files = NULL;
          num_files = 0;
        } else {
          files = &amp;tmp2;
          num_files = 1;
        }
      }
    }

    for (uint32_t i = 0; i &lt; num_files; ++i) {
      if (last_file_read != NULL &amp;&amp; stats-&gt;seek_file == NULL) {
        // We have had more than one seek for this read.  Charge the 1st file.
        // stats&#36825;&#37324;&#21482;&#20445;&#30041;&#31532;&#19968;&#27425;&#35835;&#21462;&#30340;&#25991;&#20214;.
        stats-&gt;seek_file = last_file_read;
        stats-&gt;seek_file_level = last_file_read_level;
      }

      FileMetaData* f = files[i];
      last_file_read = f;
      last_file_read_level = level;

      // &#36890;&#36807;iterator&#30340;seek&#26041;&#24335;&#26469;&#36827;&#34892;&#26597;&#25214;.
      Iterator* iter = vset_-&gt;table_cache_-&gt;NewIterator(
          options,
          f-&gt;number,
          f-&gt;file_size);
      iter-&gt;Seek(ikey);
      // seek&#21482;&#26159;&#19968;&#20010;&#22823;&#27010;&#20301;&#32622;&#36825;&#37324;&#38656;&#35201;&#31934;&#30830;&#27604;&#36739;&#36820;&#22238;&#20540;.&#21518;&#38754;&#25105;&#20204;&#20180;&#32454;&#20998;&#26512;GetValue.
      const bool done = GetValue(ucmp, iter, user_key, value, &amp;s);
      if (!iter-&gt;status().ok()) {
        s = iter-&gt;status();
        delete iter;
        return s;
      } else {
        delete iter;
        if (done) {
          return s;
        }
      }
    }
  }

  return Status::NotFound(Slice());  // Use an empty error message for speed
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-11-12" class="outline-6">
<h6 id="sec-1-10-3-11-12"><span class="section-number-6">1.10.3.11.12</span> GetValue</h6>
<div class="outline-text-6" id="text-1-10-3-11-12">

<p>GetValue根据某个iter和key判断这个key是否为想查询的key.
</p>


<pre class="src src-C++">// If <span style="color: #ffff00;">"*iter"</span> points at a value or deletion for user_key, store
// either the value, or a NotFound error and return true.
// Else return false.
static bool GetValue(const Comparator* cmp,
                     Iterator* iter, const Slice&amp; user_key,
                     std::string* value,
                     Status* s) {
  if (!iter-&gt;Valid()) {
    return false;
  }
  ParsedInternalKey parsed_key;
  // &#23545;&#20110;iterator&#37324;&#38754;&#26159;internal key.&#35299;&#26512;&#20986;parsed internal key&#20986;&#26469;.
  if (!ParseInternalKey(iter-&gt;key(), &amp;parsed_key)) {
    *s = Status::Corruption(<span style="color: #ffff00;">"corrupted key for "</span>, user_key);
    return true;
  }
  // &#27604;&#36739;user key&#20869;&#23481;&#26159;&#21542;&#19968;&#33268;.&#36825;&#37324;&#27809;&#26377;&#32771;&#34385;sequence number.
  if (cmp-&gt;Compare(parsed_key.user_key, user_key) != 0) {
    return false;
  }
  // &#28982;&#21518;&#21028;&#26029;&#36825;&#20010;key&#26159;&#21542;&#26631;&#35760;&#21024;&#38500;.
  switch (parsed_key.type) {
    case kTypeDeletion:
      *s = Status::NotFound(Slice());  // Use an empty error message for speed
      break;
    case kTypeValue: {
      Slice v = iter-&gt;value();
      value-&gt;assign(v.data(), v.size());
      break;
    }
  }
  return true;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-11-13" class="outline-6">
<h6 id="sec-1-10-3-11-13"><span class="section-number-6">1.10.3.11.13</span> UpdateStats</h6>
<div class="outline-text-6" id="text-1-10-3-11-13">

<p>根据stats来更新version内部状态.设置将要compaction文件以及对应的level是什么.
</p>


<pre class="src src-C++">bool Version::UpdateStats(const GetStats&amp; stats) {
  FileMetaData* f = stats.seek_file; // &#22914;&#26524;stats&#37324;&#38754;&#26631;&#35760;&#20102;&#25968;&#25454;&#30340;&#35805;.
  if (f != NULL) {
    f-&gt;allowed_seeks--; //
    if (f-&gt;allowed_seeks &lt;= 0 &amp;&amp; file_to_compact_ == NULL) {
      file_to_compact_ = f;
      file_to_compact_level_ = stats.seek_file_level;
      return true;
    }
  }
  return false;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-11-14" class="outline-6">
<h6 id="sec-1-10-3-11-14"><span class="section-number-6">1.10.3.11.14</span> GetOverlappingInputs</h6>
<div class="outline-text-6" id="text-1-10-3-11-14">

<p>得到某个level下面所有和[begin,end]有overlap的文件.语义不知道是否理解正确.因为代码里面有个地方没有太看懂.
</p>


<pre class="src src-C++">// Store in <span style="color: #ffff00;">"*inputs"</span> all files in <span style="color: #ffff00;">"level"</span> that overlap [begin,end]
void Version::GetOverlappingInputs(
    int level,
    const InternalKey* begin,
    const InternalKey* end,
    std::vector&lt;FileMetaData*&gt;* inputs) {
  inputs-&gt;clear();
  Slice user_begin, user_end;
  if (begin != NULL) {
    user_begin = begin-&gt;user_key();
  }
  if (end != NULL) {
    user_end = end-&gt;user_key();
  }
  const Comparator* user_cmp = vset_-&gt;icmp_.user_comparator();
  for (size_t i = 0; i &lt; files_[level].size(); ) {
    FileMetaData* f = files_[level][i++];
    const Slice file_start = f-&gt;smallest.user_key();
    const Slice file_limit = f-&gt;largest.user_key();
    if (begin != NULL &amp;&amp; user_cmp-&gt;Compare(file_limit, user_begin) &lt; 0) {
      // <span style="color: #ffff00;">"f"</span> is completely before specified range; skip it
    } else if (end != NULL &amp;&amp; user_cmp-&gt;Compare(file_start, user_end) &gt; 0) {
      // <span style="color: #ffff00;">"f"</span> is completely after specified range; skip it
    } else {
      inputs-&gt;push_back(f);
      if (level == 0) {
        // TODO(dirlt):&#23454;&#29616;&#19978;&#21487;&#33021;&#23384;&#22312;&#38382;&#39064;&#21543;.&#30475;&#19978;&#21435;&#23545;&#20110;level0&#30340;&#35805;&#20284;&#20046;&#22312;&#19981;&#26029;&#22320;&#36807;&#22823;&#33539;&#22260;.
        // Level-0 files may overlap each other.  So check if the newly
        // added file has expanded the range.  If so, restart search.
        if (begin != NULL &amp;&amp; user_cmp-&gt;Compare(file_start, user_begin) &lt; 0) {
          user_begin = file_start;
          inputs-&gt;clear();
          i = 0;
        } else if (end != NULL &amp;&amp; user_cmp-&gt;Compare(file_limit, user_end) &gt; 0) {
          user_end = file_limit;
          inputs-&gt;clear();
          i = 0;
        }
      }
    }
  }
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-11-15" class="outline-6">
<h6 id="sec-1-10-3-11-15"><span class="section-number-6">1.10.3.11.15</span> OverlapInLevel</h6>
<div class="outline-text-6" id="text-1-10-3-11-15">

<p>判断某个level里面是否有文件和[small,large]这个范围内容的key重叠
</p>


<pre class="src src-C++">bool Version::OverlapInLevel(int level,
                             const Slice* smallest_user_key,
                             const Slice* largest_user_key) {
  // (level&gt;0)&#30340;&#35805;&#34920;&#31034;&#27599;&#20010;&#25991;&#20214;&#27809;&#26377;&#37325;&#21472;&#30340;&#37096;&#20998;.
  return SomeFileOverlapsRange(vset_-&gt;icmp_, (level &gt; 0), files_[level],
                               smallest_user_key, largest_user_key);
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-11-16" class="outline-6">
<h6 id="sec-1-10-3-11-16"><span class="section-number-6">1.10.3.11.16</span> PickLevelForMemTableOutput</h6>
<div class="outline-text-6" id="text-1-10-3-11-16">

<p>根据[small,large]这个范畴选择某个level来作为memtable的output.这个range应该就是memtable的range.
这个策略比较精巧。这个策略在常数部分定义注释里面给出来了。
</p>


<pre class="src src-C++">// db/dbformat.h

// &#22914;&#26524;level0&#36807;&#20302;&#30340;&#35805;&#37027;&#20040;&#20250;&#36896;&#25104;&#36807;&#22810;compaction
// &#20294;&#26159;level0&#22810;&#39640;&#30340;&#35805;&#37027;&#20040;&#20250;&#28010;&#36153;&#30913;&#30424;&#31354;&#38388;&#22240;&#20026;key&#30340;&#37325;&#22797;.
// Maximum level to which a new compacted memtable is pushed if it
// does not create overlap.  We try to push to level 2 to avoid the
// relatively expensive level 0=&gt;1 compactions and to avoid some
// expensive manifest file operations.  We do not push all the way to
// the largest level since that can generate a lot of wasted disk
// space if the same key space is being repeatedly overwritten.
static const int kMaxMemCompactLevel = 2;

// db/version_set.cc
static const int kTargetFileSize = 2 * 1048576;

// Maximum bytes of overlaps in grandparent (i.e., level+2) before we
// stop building a single file in a level-&gt;level+1 compaction.
static const int64_t kMaxGrandParentOverlapBytes = 10 * kTargetFileSize;
</pre>


<p>
int Version::PickLevelForMemTableOutput(
    const Slice&amp; smallest_user_key,
    const Slice&amp; largest_user_key) {
  int level = 0;
  // 首先判断和level0是否有overlap.如果有overlapd的话那么选择level0.
  if (!OverlapInLevel(0, &amp;smallest_user_key, &amp;largest_user_key)) {
    // Push to next level if there is no overlap in next level,
    // and the #bytes overlapping in the level after that are limited.
    InternalKey start(smallest_user_key, kMaxSequenceNumber, kValueTypeForSeek);
    InternalKey limit(largest_user_key, 0, static_cast&lt;ValueType&gt;(0));
    std::vector&lt;FileMetaData*&gt; overlaps;
    while (level &lt; config::kMaxMemCompactLevel) {
      // 判断和其他level是否有overlap.如果存在overlap的那么也选择.
      // &gt;0的level是不允许overlap的.
      if (OverlapInLevel(level + 1, &amp;smallest_user_key, &amp;largest_user_key)) {
        break;
      }
      // 如果没有overlap的话那么判断和grandparent level重叠文件.判断重叠文件大小.
      // 这个策略没有太明白.
      // 关于这个策略估计可以从Compaction::IsTrivialMove的注释里面看到.这里应该是担心grand parent本身就存在很多overlap
      // 如果放在level+1做compaction的话，会造成grand parent这个部分合并时间过长.
      // 从值上来看意思应该是存在overlap的文件数目不应该超过10个(假设每个overlap文件都是MaxSizeForLevel的).
  // Avoid a move if there is lots of overlapping grandparent data.
   // Otherwise, the move could create a parent file that will require
  // a very expensive merge later on.
      GetOverlappingInputs(level + 2, &amp;start, &amp;limit, &amp;overlaps);
      const int64_t sum = TotalFileSize(overlaps);
      if (sum &gt; kMaxGrandParentOverlapBytes) {
        break;
      }
      level++;
    }
  }
  return level;
}
</p>
</div>

</div>

<div id="outline-container-1-10-3-11-17" class="outline-6">
<h6 id="sec-1-10-3-11-17"><span class="section-number-6">1.10.3.11.17</span> DebugString</h6>
<div class="outline-text-6" id="text-1-10-3-11-17">

<p>DebugString作为Version的调试信息打印出来.我们可以稍微得到一点启发吧.尤其如果是自己调试的话.
</p>


<pre class="src src-C++">std::string Version::DebugString() const {
  std::string r;
  for (int level = 0; level &lt; config::kNumLevels; level++) {
    // E.g.,
    //   --- level 1 ---
    //   17:123['a' .. 'd']
    //   20:43['e' .. 'g']
    r.append(<span style="color: #ffff00;">"--- level "</span>);
    AppendNumberTo(&amp;r, level);
    r.append(<span style="color: #ffff00;">" ---\n"</span>);
    const std::vector&lt;FileMetaData*&gt;&amp; files = files_[level];
    for (size_t i = 0; i &lt; files.size(); i++) {
      r.push_back(' ');
      AppendNumberTo(&amp;r, files[i]-&gt;number); // file_number
      r.push_back(':');
      AppendNumberTo(&amp;r, files[i]-&gt;file_size); // file&#22823;&#23567;.
      r.append(<span style="color: #ffff00;">"["</span>);
      r.append(files[i]-&gt;smallest.DebugString()); // &#26368;&#23567;&#21644;&#26368;&#22823;&#30340;key&#30340;&#25171;&#21360;.
      r.append(<span style="color: #ffff00;">" .. "</span>);
      r.append(files[i]-&gt;largest.DebugString());
      r.append(<span style="color: #ffff00;">"]\n"</span>);
    }
  }
  return r;
}
</pre>


</div>
</div>

</div>

<div id="outline-container-1-10-3-12" class="outline-5">
<h5 id="sec-1-10-3-12"><span class="section-number-5">1.10.3.12</span> VersionSet</h5>
<div class="outline-text-5" id="text-1-10-3-12">

<p>db/version_set.h VersionSet用来管理不同的Version并且应该维护了一些全局信息.还是首先看看结构
</p>


<pre class="src src-C++">class VersionSet {
 public:
  VersionSet(const std::string&amp; dbname,
             const Options* options,
             TableCache* table_cache,
             const InternalKeyComparator*);
  ~VersionSet();
 private:
  Env* const env_;
  const std::string dbname_;
  const Options* const options_;
  TableCache* const table_cache_;
  const InternalKeyComparator icmp_;
  uint64_t next_file_number_; // &#19979;&#19968;&#20010;&#20998;&#37197;&#30340;file number
  uint64_t manifest_file_number_; // manifest file number.
  uint64_t last_sequence_; // &#19979;&#27425;&#25805;&#20316;&#30340;sequence.
  // &#20174;LogNumber&#21644;PrevLogNumber&#27880;&#37322;&#21487;&#20197;&#30475;&#20986;&#26469;
  // &#20998;&#21035;&#34920;&#31034;&#24403;&#21069;&#20351;&#29992;&#30340;log number&#20197;&#21450;&#20043;&#21069;&#20351;&#29992;&#30340;log number(&#24403;&#21069;&#27491;&#22312;&#34987;&#21387;&#32553;).
  uint64_t log_number_; //
  uint64_t prev_log_number_;  // 0 or backing store for memtable being compacted

  // Opened lazily
  WritableFile* descriptor_file_; // manifest&#25991;&#20214;
  log::Writer* descriptor_log_; // manifest&#20197;log&#24418;&#24335;&#25171;&#24320;.
  Version dummy_versions_;  // Head of circular doubly-linked list of versions. // &#20026;&#20102;&#32452;&#32455;&#31216;&#20026;&#38142;&#34920;.
  Version* current_;        // == dummy_versions_.prev_ // &#24403;&#21069;version

  // Per-level key at which the next compaction at that level should start.
  // Either an empty string, or a valid InternalKey.
  // &#23545;&#20110;&#27599;&#23618;&#30340;&#35805;&#37117;&#20250;&#35774;&#32622;&#19968;&#20010;key.&#21482;&#26377;&gt;&#36825;&#23618;&#35774;&#32622;&#30340;key&#25165;&#20801;&#35768;&#36827;&#34892;compaction.
  std::string compact_pointer_[config::kNumLevels]; // &#27599;&#20010;level&#36827;&#34892;compaction&#20351;&#29992;&#30340;internal key
  // TODO(dirlt):&#20284;&#20046;&#27599;&#20010;level&#36827;&#34892;compaction&#37117;&#37197;&#19978;&#20102;&#19968;&#20010;internal key
  // DONE(dirlt):&#35760;&#24405;&#27599;&#23618;&#30340;&#26368;&#22823;key.
};
</pre>



</div>

<div id="outline-container-1-10-3-12-1" class="outline-6">
<h6 id="sec-1-10-3-12-1"><span class="section-number-6">1.10.3.12.1</span> VersionSet</h6>
<div class="outline-text-6" id="text-1-10-3-12-1">

<p>首先看看构造函数和析构函数.
</p>


<pre class="src src-C++">VersionSet::VersionSet(const std::string&amp; dbname,
                       const Options* options,
                       TableCache* table_cache,
                       const InternalKeyComparator* cmp)
    : env_(options-&gt;env),
      dbname_(dbname),
      options_(options),
      table_cache_(table_cache),
      icmp_(*cmp),
      next_file_number_(2),
      // &#19979;&#38754;&#36825;&#20123;&#23383;&#27573;&#37117;&#26159;&#36890;&#36807;Recover&#24674;&#22797;&#30340;.
      manifest_file_number_(0),  // Filled by Recover()
      last_sequence_(0),
      log_number_(0),
      prev_log_number_(0),
      descriptor_file_(NULL),
      descriptor_log_(NULL),
      dummy_versions_(this),
      current_(NULL) {
  AppendVersion(new Version(this)); // &#28155;&#21152;&#19968;&#20010;&#24403;&#21069;version.
}
VersionSet::~VersionSet() {
  current_-&gt;Unref();
  // &#26512;&#26500;&#26102;&#20505;&#24517;&#39035;&#30830;&#20445;&#37324;&#38754;&#27809;&#26377;&#20219;&#20309;&#29256;&#26412;.
  assert(dummy_versions_.next_ == &amp;dummy_versions_);  // List must be empty
  delete descriptor_log_;
  delete descriptor_file_;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-12-2" class="outline-6">
<h6 id="sec-1-10-3-12-2"><span class="section-number-6">1.10.3.12.2</span> NeedsCompaction</h6>
<div class="outline-text-6" id="text-1-10-3-12-2">

<p>当前versionset是否需要触发compaction操作.
</p>


<pre class="src src-C++">// Returns true iff some level needs a compaction.
bool NeedsCompaction() const {
  Version* v = current_;
  return (v-&gt;compaction_score_ &gt;= 1) || (v-&gt;file_to_compact_ != NULL);
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-12-3" class="outline-6">
<h6 id="sec-1-10-3-12-3"><span class="section-number-6">1.10.3.12.3</span> AppendVersion</h6>
<div class="outline-text-6" id="text-1-10-3-12-3">

<p>添加version.非常简单修改引用计数挂载链表上.将version挂在version_set下面的话可以使得
version_set了解到哪些文件依然是被正在使用的.
</p>


<pre class="src src-C++">void VersionSet::AppendVersion(Version* v) {
  // Make <span style="color: #ffff00;">"v"</span> current
  assert(v-&gt;refs_ == 0);
  assert(v != current_);
  if (current_ != NULL) {
    current_-&gt;Unref();
  }
  current_ = v;
  v-&gt;Ref();

  // Append to linked list
  v-&gt;prev_ = dummy_versions_.prev_;
  v-&gt;next_ = &amp;dummy_versions_;
  v-&gt;prev_-&gt;next_ = v;
  v-&gt;next_-&gt;prev_ = v;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-12-4" class="outline-6">
<h6 id="sec-1-10-3-12-4"><span class="section-number-6">1.10.3.12.4</span> NumLevelFiles</h6>
<div class="outline-text-6" id="text-1-10-3-12-4">

<p>得到某个level的文件数目.以current这个Version来计算的
</p>


<pre class="src src-C++">int VersionSet::NumLevelFiles(int level) const {
  assert(level &gt;= 0);
  assert(level &lt; config::kNumLevels);
  return current_-&gt;files_[level].size();
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-12-5" class="outline-6">
<h6 id="sec-1-10-3-12-5"><span class="section-number-6">1.10.3.12.5</span> NumLevelBytes</h6>
<div class="outline-text-6" id="text-1-10-3-12-5">

<p>某个level的文件大小.以current这个Version来计算的.
</p>


<pre class="src src-C++">int64_t VersionSet::NumLevelBytes(int level) const {
  assert(level &gt;= 0);
  assert(level &lt; config::kNumLevels);
  return TotalFileSize(current_-&gt;files_[level]);
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-12-6" class="outline-6">
<h6 id="sec-1-10-3-12-6"><span class="section-number-6">1.10.3.12.6</span> TotalFileSize</h6>
<div class="outline-text-6" id="text-1-10-3-12-6">

<p>根据file meta data得到所有文件大小.非常简单因为里面有file_size.
</p>


<pre class="src src-C++">static int64_t TotalFileSize(const std::vector&lt;FileMetaData*&gt;&amp; files) {
  int64_t sum = 0;
  for (size_t i = 0; i &lt; files.size(); i++) {
    sum += files[i]-&gt;file_size;
  }
  return sum;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-12-7" class="outline-6">
<h6 id="sec-1-10-3-12-7"><span class="section-number-6">1.10.3.12.7</span> MarkFileNumberUsed</h6>
<div class="outline-text-6" id="text-1-10-3-12-7">

<p>标记当前使用了file_number进度.number表示已经使用的进度,所以下次分配必须+1.
</p>


<pre class="src src-C++">void VersionSet::MarkFileNumberUsed(uint64_t number) {
  if (next_file_number_ &lt;= number) {
    next_file_number_ = number + 1;
  }
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-12-8" class="outline-6">
<h6 id="sec-1-10-3-12-8"><span class="section-number-6">1.10.3.12.8</span> ApproximateOffsetOf</h6>
<div class="outline-text-6" id="text-1-10-3-12-8">

<p>判断这个key在数据库内部大致偏移是多少.从这个实现里面我们可以看到.对于level-0的文件并不是排序的
对于level&gt;0的文件都是按照range进行排序的。并且这个排序是按照smallest来进行排序的。
</p>


<pre class="src src-C++">uint64_t VersionSet::ApproximateOffsetOf(Version* v, const InternalKey&amp; ikey) {
  uint64_t result = 0;
  for (int level = 0; level &lt; config::kNumLevels; level++) {
    const std::vector&lt;FileMetaData*&gt;&amp; files = v-&gt;files_[level];
    for (size_t i = 0; i &lt; files.size(); i++) {
      if (icmp_.Compare(files[i]-&gt;largest, ikey) &lt;= 0) { // &#22914;&#26524;&#27604;largest key&#22823;&#30340;&#35805;&#37027;&#20040;&#36825;&#20010;
        // &#37027;&#20040;&#20559;&#31227;&#38656;&#35201;&#31639;&#19978;&#25972;&#20010;&#25991;&#20214;.&#20294;&#26159;&#36825;&#37324;&#36824;&#21253;&#25324;&#20102;index block,meta block&#20197;&#21450;footer&#22823;&#23567;.
        // &#25152;&#20197;&#21482;&#33021;&#22815;&#35828;&#26159;&#22823;&#33268;&#22823;&#23567;.
        // Entire file is before <span style="color: #ffff00;">"ikey"</span>, so just add the file size
        result += files[i]-&gt;file_size;
      } else if (icmp_.Compare(files[i]-&gt;smallest, ikey) &gt; 0) { // &#22914;&#26524;smallest&#27604;&#24403;&#21069;key&#22823;&#30340;&#35805;&#37027;&#20040;&#21462;&#28040;.
        // Entire file is after <span style="color: #ffff00;">"ikey"</span>, so ignore
        if (level &gt; 0) { // &#22914;&#26524;&#26159;&gt;0&#30340;level&#37027;&#20040;&#21487;&#20197;&#30452;&#25509;&#21462;&#28040;.&#22240;&#20026;&#36825;&#20010;&#37096;&#20998;&#30340;file&#37117;&#26159;&#25353;&#29031;smallest&#25490;&#24207;&#30340;.
          // Files other than level 0 are sorted by meta-&gt;smallest, so
          // no further files in this level will contain data for
          // <span style="color: #ffff00;">"ikey"</span>.
          break;
        }
      } else { // &#22914;&#26524;&#23384;&#22312;&#20132;&#38598;&#30340;&#35805;&#37027;&#20040;&#37027;&#20040;&#21487;&#20197;&#26500;&#36896;&#20986;Table&#23545;&#35937;&#25214;&#21040;&#36825;&#20010;key&#22823;&#33268;&#20559;&#31227;.
        // <span style="color: #ffff00;">"ikey"</span> falls in the range for this table.  Add the
        // approximate offset of <span style="color: #ffff00;">"ikey"</span> within the table.
        Table* tableptr;
        Iterator* iter = table_cache_-&gt;NewIterator(
            ReadOptions(), files[i]-&gt;number, files[i]-&gt;file_size, &amp;tableptr);
        if (tableptr != NULL) {
          result += tableptr-&gt;ApproximateOffsetOf(ikey.Encode());
        }
        delete iter;
      }
    }
  }
  return result;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-12-9" class="outline-6">
<h6 id="sec-1-10-3-12-9"><span class="section-number-6">1.10.3.12.9</span> AddLiveFiles</h6>
<div class="outline-text-6" id="text-1-10-3-12-9">

<p>将version set里面所有version所持有的文件收集起来.非常简单:).
</p>


<pre class="src src-C++">void VersionSet::AddLiveFiles(std::set&lt;uint64_t&gt;* live) {
  for (Version* v = dummy_versions_.next_;
       v != &amp;dummy_versions_;
       v = v-&gt;next_) {
    for (int level = 0; level &lt; config::kNumLevels; level++) {
      const std::vector&lt;FileMetaData*&gt;&amp; files = v-&gt;files_[level];
      for (size_t i = 0; i &lt; files.size(); i++) {
        live-&gt;insert(files[i]-&gt;number);
      }
    }
  }
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-12-10" class="outline-6">
<h6 id="sec-1-10-3-12-10"><span class="section-number-6">1.10.3.12.10</span> LevelSummary</h6>
<div class="outline-text-6" id="text-1-10-3-12-10">

<p>每层level的文件个数分别是多少.
</p>


<pre class="src src-C++">const char* VersionSet::LevelSummary(LevelSummaryStorage* scratch) const {
  // Update code if kNumLevels changes
  assert(config::kNumLevels == 7);
  snprintf(scratch-&gt;buffer, sizeof(scratch-&gt;buffer),
           <span style="color: #ffff00;">"files[ %d %d %d %d %d %d %d ]"</span>,
           int(current_-&gt;files_[0].size()),
           int(current_-&gt;files_[1].size()),
           int(current_-&gt;files_[2].size()),
           int(current_-&gt;files_[3].size()),
           int(current_-&gt;files_[4].size()),
           int(current_-&gt;files_[5].size()),
           int(current_-&gt;files_[6].size()));
  return scratch-&gt;buffer;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-12-11" class="outline-6">
<h6 id="sec-1-10-3-12-11"><span class="section-number-6">1.10.3.12.11</span> WriteSnapshot</h6>
<div class="outline-text-6" id="text-1-10-3-12-11">

<p>将当前current version写入到磁盘记为log.方式是将内容copy到version edit对象里面去然后持久化.
过程还是非常简单吧:).
</p>


<pre class="src src-C++">Status VersionSet::WriteSnapshot(log::Writer* log) {
  // TODO: Break up into multiple records to reduce memory usage on recovery?

  // Save metadata
  VersionEdit edit;
  edit.SetComparatorName(icmp_.user_comparator()-&gt;Name());

  // Save compaction pointers
  for (int level = 0; level &lt; config::kNumLevels; level++) {
    if (!compact_pointer_[level].empty()) {
      InternalKey key;
      key.DecodeFrom(compact_pointer_[level]);
      edit.SetCompactPointer(level, key);
    }
  }

  // Save files
  for (int level = 0; level &lt; config::kNumLevels; level++) {
    const std::vector&lt;FileMetaData*&gt;&amp; files = current_-&gt;files_[level];
    for (size_t i = 0; i &lt; files.size(); i++) {
      const FileMetaData* f = files[i];
      edit.AddFile(level, f-&gt;number, f-&gt;file_size, f-&gt;smallest, f-&gt;largest);
    }
  }

  std::string record;
  edit.EncodeTo(&amp;record);
  return log-&gt;AddRecord(record);
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-12-12" class="outline-6">
<h6 id="sec-1-10-3-12-12"><span class="section-number-6">1.10.3.12.12</span> Finalize</h6>
<div class="outline-text-6" id="text-1-10-3-12-12">

<p>所谓的Finalize的含义应该是，如果我们不希望修改version这个结构之后我们应该做的事情。可能叫做Finish会更好。
相当于针对这个version而言的话，最高一级的compaction level是什么，分数是多少.
</p>


<pre class="src src-C++">void VersionSet::Finalize(Version* v) {
  // Precomputed best level for next compaction
  int best_level = -1;
  double best_score = -1;

  for (int level = 0; level &lt; config::kNumLevels-1; level++) {
    double score;
    if (level == 0) {
      // We treat level-0 specially by bounding the number of files
      // instead of number of bytes for two reasons:
      //
      // (1) With larger write-buffer sizes, it is nice not to do too
      // many level-0 compactions.
      //
      // (2) The files in level-0 are merged on every read and
      // therefore we wish to avoid too many files when the individual
      // file size is small (perhaps because of a small write-buffer
      // setting, or very high compression ratios, or lots of
      // overwrites/deletions).
      score = v-&gt;files_[level].size() /
          static_cast&lt;double&gt;(config::kL0_CompactionTrigger);
    } else {
      // Compute the ratio of current size to size limit.
      const uint64_t level_bytes = TotalFileSize(v-&gt;files_[level]);
      score = static_cast&lt;double&gt;(level_bytes) / MaxBytesForLevel(level);
    }

    if (score &gt; best_score) {
      best_level = level;
      best_score = score;
    }
  }

  v-&gt;compaction_level_ = best_level;
  v-&gt;compaction_score_ = best_score;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-12-13" class="outline-6">
<h6 id="sec-1-10-3-12-13"><span class="section-number-6">1.10.3.12.13</span> Recover</h6>
<div class="outline-text-6" id="text-1-10-3-12-13">

<p>从db_impl.cc里面的DB::Open可以看到,这里的Recover并没有将剩余的version_edit回放完成.
回放这个部分在LogAndApply里面完成.所以Recover可能只是恢复到以前某个状态.将当前的
CURRENT里面的manifest文件回放之后就得到最新的内容.然后根据里面的log信息回放后面的内容.
</p>


<pre class="src src-C++">Status VersionSet::Recover() {
  struct LogReporter : public log::Reader::Reporter {
    Status* status;
    virtual void Corruption(size_t bytes, const Status&amp; s) {
      if (this-&gt;status-&gt;ok()) *this-&gt;status = s;
    }
  };

  // &#35835;&#21462;&#24403;&#21069;current&#36825;&#20010;&#20869;&#23481;,&#24471;&#21040;&#26368;&#26032;&#30340;manifest&#25991;&#20214;.
  // Read <span style="color: #ffff00;">"CURRENT"</span> file, which contains a pointer to the current manifest file
  std::string current;
  Status s = ReadFileToString(env_, CurrentFileName(dbname_), &amp;current);
  if (!s.ok()) {
    return s;
  }
  if (current.empty() || current[current.size()-1] != '\n') {
    return Status::Corruption(<span style="color: #ffff00;">"CURRENT file does not end with newline"</span>);
  }
  current.resize(current.size() - 1);

  std::string dscname = dbname_ + <span style="color: #ffff00;">"/"</span> + current;
  SequentialFile* file;
  s = env_-&gt;NewSequentialFile(dscname, &amp;file);
  if (!s.ok()) {
    return s;
  }

  bool have_log_number = false;
  bool have_prev_log_number = false;
  bool have_next_file = false;
  bool have_last_sequence = false;
  uint64_t next_file = 0;
  uint64_t last_sequence = 0;
  uint64_t log_number = 0;
  uint64_t prev_log_number = 0;
  // &#30456;&#24403;&#20110;&#20174;empty status&#26469;&#26500;&#24314;current version.
  Builder builder(this, current_);

  {
    LogReporter reporter;
    reporter.status = &amp;s;
    log::Reader reader(file, &amp;reporter, true/*checksum*/, 0/*initial_offset*/);
    Slice record;
    std::string scratch;
    // &#25353;&#29031;&#27599;&#26465;log&#20869;&#23481;&#35835;&#21462;.&#37324;&#38754;&#30340;&#20869;&#23481;&#37117;&#26159;version edit.
    while (reader.ReadRecord(&amp;record, &amp;scratch) &amp;&amp; s.ok()) {
      VersionEdit edit;
      s = edit.DecodeFrom(record);
      if (s.ok()) {
        if (edit.has_comparator_ &amp;&amp;
            edit.comparator_ != icmp_.user_comparator()-&gt;Name()) {
          s = Status::InvalidArgument(
              edit.comparator_ + <span style="color: #ffff00;">"does not match existing comparator "</span>,
              icmp_.user_comparator()-&gt;Name());
        }
      }

      // &#30452;&#25509;apply&#19978;&#21435;.
      if (s.ok()) {
        builder.Apply(&amp;edit);
      }

      if (edit.has_log_number_) {
        log_number = edit.log_number_;
        have_log_number = true;
      }

      if (edit.has_prev_log_number_) {
        prev_log_number = edit.prev_log_number_;
        have_prev_log_number = true;
      }

      if (edit.has_next_file_number_) {
        next_file = edit.next_file_number_;
        have_next_file = true;
      }

      if (edit.has_last_sequence_) {
        last_sequence = edit.last_sequence_;
        have_last_sequence = true;
      }
    }
  }
  delete file;
  file = NULL;

  if (s.ok()) {
    if (!have_next_file) {
      s = Status::Corruption(<span style="color: #ffff00;">"no meta-nextfile entry in descriptor"</span>);
    } else if (!have_log_number) {
      s = Status::Corruption(<span style="color: #ffff00;">"no meta-lognumber entry in descriptor"</span>);
    } else if (!have_last_sequence) {
      s = Status::Corruption(<span style="color: #ffff00;">"no last-sequence-number entry in descriptor"</span>);
    }

    if (!have_prev_log_number) {
      prev_log_number = 0;
    }

    MarkFileNumberUsed(prev_log_number);
    MarkFileNumberUsed(log_number);
  }

  if (s.ok()) {
    Version* v = new Version(this);
    builder.SaveTo(v);
    // Install recovered version
    Finalize(v);
    // &#22686;&#21152;&#36825;&#20040;&#19968;&#20010;version&#20316;&#20026;&#24403;&#21069;current version.
    AppendVersion(v);
    manifest_file_number_ = next_file;
    next_file_number_ = next_file + 1;
    last_sequence_ = last_sequence;
    log_number_ = log_number;
    prev_log_number_ = prev_log_number;
  }

  return s;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-12-14" class="outline-6">
<h6 id="sec-1-10-3-12-14"><span class="section-number-6">1.10.3.12.14</span> LogAndApply</h6>
<div class="outline-text-6" id="text-1-10-3-12-14">




<pre class="src src-C++">Status VersionSet::LogAndApply(VersionEdit* edit, port::Mutex* mu) {
  if (edit-&gt;has_log_number_) {
    assert(edit-&gt;log_number_ &gt;= log_number_);
    assert(edit-&gt;log_number_ &lt; next_file_number_);
  } else {
    edit-&gt;SetLogNumber(log_number_);
  }

  if (!edit-&gt;has_prev_log_number_) {
    edit-&gt;SetPrevLogNumber(prev_log_number_);
  }

  edit-&gt;SetNextFile(next_file_number_);
  edit-&gt;SetLastSequence(last_sequence_);

  // &#36825;&#20010;&#36807;&#31243;&#24212;&#35813;&#26159;&#23558;edit&#30340;&#20462;&#25913;&#25918;&#22312;current_&#37324;&#38754;
  // &#28982;&#21518;&#23558;edit&#20316;&#29992;&#22312;current&#19978;&#38754;&#65292;&#23558;current_&#20445;&#23384;&#21040;v&#37324;&#38754;
  // &#28982;&#21518;&#23545;v&#36827;&#34892;finish.
  Version* v = new Version(this);
  {
    Builder builder(this, current_);
    builder.Apply(edit);
    builder.SaveTo(v);
  }
  Finalize(v);

  // Initialize new descriptor log file if necessary by creating
  // a temporary file that contains a snapshot of the current version.
  std::string new_manifest_file;
  Status s;
  if (descriptor_log_ == NULL) {
    // No reason to unlock *mu here since we only hit this path in the
    // first call to LogAndApply (when opening the database).
    assert(descriptor_file_ == NULL);
    new_manifest_file = DescriptorFileName(dbname_, manifest_file_number_);
    edit-&gt;SetNextFile(next_file_number_);
    s = env_-&gt;NewWritableFile(new_manifest_file, &amp;descriptor_file_);
    if (s.ok()) {
      descriptor_log_ = new log::Writer(descriptor_file_);
      // &#23558;current&#20570;snapshot&#20445;&#23384;&#22312;descriptor log&#37324;&#38754;.
      s = WriteSnapshot(descriptor_log_);
    }
  }

  // Unlock during expensive MANIFEST log write
  {
    mu-&gt;Unlock();

    // Write new record to MANIFEST log
    // &#23558;&#36825;&#20010;&#20462;&#25913;&#20063;&#20445;&#23384;&#22312;log&#37324;&#38754;.
    // &#29616;&#22312;&#27604;&#36739;&#25285;&#24515;&#26368;&#21518;&#30340;&#32467;&#26500;.&#20284;&#20046;&#29616;&#22312;snapshot&#20197;&#21450;log&#20869;&#23481;&#37117;&#28151;&#22312;&#19968;&#36215;&#20102;.
    // &#20043;&#21069;&#22312;descriptor_log&#37324;&#38754;&#22635;&#20889;&#20102;current version&#20869;&#23481;
    // &#32780;&#36825;&#37324;&#36824;&#28155;&#21152;&#20102;edit&#22686;&#37327;&#20869;&#23481;
    // &#36825;&#20010;&#26684;&#24335;&#29616;&#22312;&#30475;&#19978;&#21435;&#36824;&#22909;.&#21040;&#26102;&#20505;&#21487;&#33021;&#38656;&#35201;&#20027;&#35201;&#30475;&#30475;Recover&#20869;&#23481;.
    if (s.ok()) {
      std::string record;
      edit-&gt;EncodeTo(&amp;record);
      s = descriptor_log_-&gt;AddRecord(record);
      if (s.ok()) {
        s = descriptor_file_-&gt;Sync(); // &#27880;&#24847;&#36825;&#37324;&#25105;&#20204;&#38656;&#35201;&#20570;sync.
      }
    }

    // If we just created a new descriptor file, install it by writing a
    // new CURRENT file that points to it.
    if (s.ok() &amp;&amp; !new_manifest_file.empty()) {
      s = SetCurrentFile(env_, dbname_, manifest_file_number_);
    }

    mu-&gt;Lock();
  }

  // Install the new version
  // &#20316;&#20026;&#24403;&#21069;current version&#23384;&#22312;.
  if (s.ok()) {
    AppendVersion(v);
    log_number_ = edit-&gt;log_number_;
    prev_log_number_ = edit-&gt;prev_log_number_;
  } else {
    delete v;
    if (!new_manifest_file.empty()) {
      delete descriptor_log_;
      delete descriptor_file_;
      descriptor_log_ = NULL;
      descriptor_file_ = NULL;
      env_-&gt;DeleteFile(new_manifest_file);
    }
  }

  return s;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-12-15" class="outline-6">
<h6 id="sec-1-10-3-12-15"><span class="section-number-6">1.10.3.12.15</span> GetRange</h6>
<div class="outline-text-6" id="text-1-10-3-12-15">

<p>得到input files里面的最大和最小key.
</p>


<pre class="src src-C++">// Stores the minimal range that covers all entries in inputs in
// *smallest, *largest.
// REQUIRES: inputs is not empty
void VersionSet::GetRange(const std::vector&lt;FileMetaData*&gt;&amp; inputs,
                          InternalKey* smallest,
                          InternalKey* largest) {
  assert(!inputs.empty());
  smallest-&gt;Clear();
  largest-&gt;Clear();
  for (size_t i = 0; i &lt; inputs.size(); i++) {
    FileMetaData* f = inputs[i];
    if (i == 0) {
      *smallest = f-&gt;smallest;
      *largest = f-&gt;largest;
    } else {
      if (icmp_.Compare(f-&gt;smallest, *smallest) &lt; 0) {
        *smallest = f-&gt;smallest;
      }
      if (icmp_.Compare(f-&gt;largest, *largest) &gt; 0) {
        *largest = f-&gt;largest;
      }
    }
  }
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-12-16" class="outline-6">
<h6 id="sec-1-10-3-12-16"><span class="section-number-6">1.10.3.12.16</span> PickCompaction</h6>
<div class="outline-text-6" id="text-1-10-3-12-16">

<p>选择一个Compaction来进行操作.对于选择Compaction应该比较具有策略性的。然后丢给DB去执行这个Compaction操作.
PickCompaction和CompactRange都是compaction行为.不过PickCompaction是自动触发的，而CompactRange
是用户自己手动触发的.
</p>


<pre class="src src-C++">Compaction* VersionSet::PickCompaction() {
  Compaction* c;
  int level;

  // We prefer compactions triggered by too much data in a level over  // the compactions triggered by seeks.
  // &#26681;&#25454;&#24403;&#21069;version&#30340;&#32479;&#35745;&#32467;&#26524;&#21028;&#26029;&#26159;&#21542;&#38656;&#35201;compaction.
  const bool size_compaction = (current_-&gt;compaction_score_ &gt;= 1);
  const bool seek_compaction = (current_-&gt;file_to_compact_ != NULL);
  if (size_compaction) {
    level = current_-&gt;compaction_level_;
    assert(level &gt;= 0);
    assert(level+1 &lt; config::kNumLevels);
    c = new Compaction(level);

    // Pick the first file that comes after compact_pointer_[level]
    for (size_t i = 0; i &lt; current_-&gt;files_[level].size(); i++) {
      FileMetaData* f = current_-&gt;files_[level][i];
      if (compact_pointer_[level].empty() ||
          icmp_.Compare(f-&gt;largest.Encode(), compact_pointer_[level]) &gt; 0) {
        c-&gt;inputs_[0].push_back(f);
        break;
      }
    }
    if (c-&gt;inputs_[0].empty()) {
      // Wrap-around to the beginning of the key space
      c-&gt;inputs_[0].push_back(current_-&gt;files_[level][0]);
    }
  } else if (seek_compaction) {
    level = current_-&gt;file_to_compact_level_;
    c = new Compaction(level);
    c-&gt;inputs_[0].push_back(current_-&gt;file_to_compact_);
  } else {
    return NULL;
  }

  // &#29616;&#22312;&#24050;&#32463;&#36873;&#25321;&#22909;&#20102;&#19968;&#20010;&#25991;&#20214;&#26469;&#36827;&#34892;compaction.
  // &#23545;&#24403;&#21069;&#30340;version +ref count.
  c-&gt;input_version_ = current_;
  c-&gt;input_version_-&gt;Ref();

  // Files in level 0 may overlap each other, so pick up all overlapping ones
  if (level == 0) {
    InternalKey smallest, largest;
    // &#27880;&#37322;&#20889;&#30340;&#38750;&#24120;&#28165;&#26970;&#20102;.
    GetRange(c-&gt;inputs_[0], &amp;smallest, &amp;largest);
    // Note that the next call will discard the file we placed in
    // c-&gt;inputs_[0] earlier and replace it with an overlapping set
    // which will include the picked file.
    current_-&gt;GetOverlappingInputs(0, &amp;smallest, &amp;largest, &amp;c-&gt;inputs_[0]);
    assert(!c-&gt;inputs_[0].empty());
  }

  // &#36873;&#25321;&#20102;level&#30340;&#25991;&#20214;&#20043;&#21518;&#38656;&#35201;&#36873;&#25321;level+1&#30340;&#25991;&#20214;
  // &#25226;&#20854;&#20182;&#30340;input files&#23383;&#27573;&#22635;&#19978;.
  SetupOtherInputs(c);

  return c;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-12-17" class="outline-6">
<h6 id="sec-1-10-3-12-17"><span class="section-number-6">1.10.3.12.17</span> CompactRange</h6>
<div class="outline-text-6" id="text-1-10-3-12-17">

<p>DBImpl里面提供CompactRange打包成为一个Manual Compaction的请求提交到后端.然后判断
如果为Manual Compaction的话那么实际调用的还是VersionSet::CompactRange这个方法产生一个
Compaction对象真正进行执行.
</p>


<pre class="src src-C++">Compaction* VersionSet::CompactRange(
    int level,
    const InternalKey* begin,
    const InternalKey* end) {
  std::vector&lt;FileMetaData*&gt; inputs;
  current_-&gt;GetOverlappingInputs(level, begin, end, &amp;inputs);
  if (inputs.empty()) {
    return NULL;
  }

  // Avoid compacting too much in one shot in case the range is large.
  // &#21387;&#32553;&#33539;&#22260;&#30340;&#35805;&#21487;&#20197;&#25552;&#20132;&#22810;&#20010;input files&#20316;&#20026;&#24213;&#23618;level&#36755;&#20837;.
  // &#20294;&#26159;&#36890;&#36807;&#25511;&#21046;&#22823;&#23567;&#26469;&#38480;&#21046;&#36755;&#20837;&#25991;&#20214;&#22810;&#23569;.
  const uint64_t limit = MaxFileSizeForLevel(level);
  uint64_t total = 0;
  for (int i = 0; i &lt; inputs.size(); i++) {
    uint64_t s = inputs[i]-&gt;file_size;
    total += s;
    if (total &gt;= limit) {
      inputs.resize(i + 1);
      break;
    }
  }

  Compaction* c = new Compaction(level);
  c-&gt;input_version_ = current_;
  c-&gt;input_version_-&gt;Ref();
  c-&gt;inputs_[0] = inputs;
  SetupOtherInputs(c);
  return c;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-12-18" class="outline-6">
<h6 id="sec-1-10-3-12-18"><span class="section-number-6">1.10.3.12.18</span> GetRange2</h6>
<div class="outline-text-6" id="text-1-10-3-12-18">

<p>得到input1和input2两个文件compaction之后的最小和最大key.
</p>


<pre class="src src-C++">// Stores the minimal range that covers all entries in inputs1 and inputs2
// in *smallest, *largest.
// REQUIRES: inputs is not empty
void VersionSet::GetRange2(const std::vector&lt;FileMetaData*&gt;&amp; inputs1,
                           const std::vector&lt;FileMetaData*&gt;&amp; inputs2,
                           InternalKey* smallest,
                           InternalKey* largest) {
  std::vector&lt;FileMetaData*&gt; all = inputs1;
  all.insert(all.end(), inputs2.begin(), inputs2.end());
  GetRange(all, smallest, largest);
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-12-19" class="outline-6">
<h6 id="sec-1-10-3-12-19"><span class="section-number-6">1.10.3.12.19</span> SetupOtherInputs</h6>
<div class="outline-text-6" id="text-1-10-3-12-19">

<p>将compaction的另外一层内容(input files)补齐.
</p>


<pre class="src src-C++">void VersionSet::SetupOtherInputs(Compaction* c) {
  const int level = c-&gt;level();
  InternalKey smallest, largest;
  GetRange(c-&gt;inputs_[0], &amp;smallest, &amp;largest);

  // &#21028;&#26029;level+1&#37324;&#38754;&#26377;&#21738;&#20123;&#25991;&#20214;&#26159;&#23384;&#22312;&#37325;&#21472;&#30340;.
  current_-&gt;GetOverlappingInputs(level+1, &amp;smallest, &amp;largest, &amp;c-&gt;inputs_[1]);

  // Get entire range covered by compaction
  // &#24471;&#21040;&#25972;&#20010;compaction&#25152;&#35206;&#30422;&#30340;&#33539;&#22260;
  InternalKey all_start, all_limit;
  GetRange2(c-&gt;inputs_[0], c-&gt;inputs_[1], &amp;all_start, &amp;all_limit);

  // See if we can grow the number of inputs in <span style="color: #ffff00;">"level"</span> without
  // changing the number of <span style="color: #ffff00;">"level+1"</span> files we pick up.
  // &#35266;&#23519;&#26159;&#21542;&#21487;&#20197;&#25193;&#22823;level input files&#25968;&#37327;&#20294;&#26159;&#19981;&#36896;&#25104;level+1 input files&#25968;&#37327;&#21464;&#21270;.
  if (!c-&gt;inputs_[1].empty()) {
    std::vector&lt;FileMetaData*&gt; expanded0;
    current_-&gt;GetOverlappingInputs(level, &amp;all_start, &amp;all_limit, &amp;expanded0);
    if (expanded0.size() &gt; c-&gt;inputs_[0].size()) {
      InternalKey new_start, new_limit;
      GetRange(expanded0, &amp;new_start, &amp;new_limit);
      std::vector&lt;FileMetaData*&gt; expanded1;
      current_-&gt;GetOverlappingInputs(level+1, &amp;new_start, &amp;new_limit,
                                     &amp;expanded1);
      if (expanded1.size() == c-&gt;inputs_[1].size()) {
        Log(options_-&gt;info_log,
            <span style="color: #ffff00;">"Expanding@%d %d+%d to %d+%d\n"</span>,
            level,
            int(c-&gt;inputs_[0].size()),
            int(c-&gt;inputs_[1].size()),
            int(expanded0.size()),
            int(expanded1.size()));
        smallest = new_start;
        largest = new_limit;
        c-&gt;inputs_[0] = expanded0;
        c-&gt;inputs_[1] = expanded1;
        GetRange2(c-&gt;inputs_[0], c-&gt;inputs_[1], &amp;all_start, &amp;all_limit);
      }
    }
  }

  // Compute the set of grandparent files that overlap this compaction
  // (parent == level+1; grandparent == level+2)
  if (level + 2 &lt; config::kNumLevels) {
    // &#20551;&#35774;&#36825;&#20004;&#20010;&#21512;&#24182;&#20043;&#21518;,&#21644;level+2&#20250;&#26377;&#21738;&#20123;&#25991;&#20214;&#20986;&#29616;&#37325;&#21472;.
    // &#20445;&#23384;&#22312;grandparents&#37324;&#38754;.
    current_-&gt;GetOverlappingInputs(level + 2, &amp;all_start, &amp;all_limit,
                                   &amp;c-&gt;grandparents_);
  }

  if (false) {
    Log(options_-&gt;info_log, <span style="color: #ffff00;">"Compacting %d '%s' .. '%s'"</span>,
        level,
        smallest.DebugString().c_str(),
        largest.DebugString().c_str());
  }

  // Update the place where we will do the next compaction for this level.
  // We update this immediately instead of waiting for the VersionEdit
  // to be applied so that if the compaction fails, we will try a different
  // key range next time.
  // &#20445;&#23384;&#21040;&#26412;&#23618;&#26368;&#22823;key.
  compact_pointer_[level] = largest.Encode().ToString();
  // &#23558;level&#30340;largest&#20445;&#23384;&#21040;edit&#37324;&#38754;.&#36825;&#20010;&#21487;&#33021;&#23545;&#20110;&#24674;&#22797;&#36215;&#26469;&#20043;&#21518;&#21487;&#33021;&#26377;&#29992;.
  c-&gt;edit_.SetCompactPointer(level, largest);
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-12-20" class="outline-6">
<h6 id="sec-1-10-3-12-20"><span class="section-number-6">1.10.3.12.20</span> MakeInputIterator</h6>
<div class="outline-text-6" id="text-1-10-3-12-20">

<p>针对Compaction而言我们可能需要读取多个文件设计的遍历器.底层应该是MergeIterator实现.
</p>


<pre class="src src-C++">Iterator* VersionSet::MakeInputIterator(Compaction* c) {
  ReadOptions options;
  options.verify_checksums = options_-&gt;paranoid_checks;
  options.fill_cache = false;

  // Level-0 files have to be merged together.  For other levels,
  // we will make a concatenating iterator per level.
  // TODO(opt): use concatenating iterator for level-0 if there is no overlap
  // &#23545;&#20110;&gt;0&#30340;level&#26469;&#35828;&#30340;&#35805;&#21487;&#20197;&#20351;&#29992;LevelFileNumIterator&#26469;&#24403;&#20570;&#36825;&#19968;&#23618;&#30340;iterator.
  // &#32780;&#23545;==0&#30340;level&#26469;&#35828;&#30340;&#35805;&#27599;&#19968;&#20010;&#25991;&#20214;&#20316;&#20026;&#19968;&#20010;iterator&#23384;&#22312;.
  const int space = (c-&gt;level() == 0 ? c-&gt;inputs_[0].size() + 1 : 2);
  Iterator** list = new Iterator*[space];
  int num = 0;
  for (int which = 0; which &lt; 2; which++) {
    if (!c-&gt;inputs_[which].empty()) {
      if (c-&gt;level() + which == 0) {
        const std::vector&lt;FileMetaData*&gt;&amp; files = c-&gt;inputs_[which];
        for (size_t i = 0; i &lt; files.size(); i++) {
          list[num++] = table_cache_-&gt;NewIterator(
              options, files[i]-&gt;number, files[i]-&gt;file_size);
        }
      } else {
        // Create concatenating iterator for the files from this level
        list[num++] = NewTwoLevelIterator(
            new Version::LevelFileNumIterator(icmp_, &amp;c-&gt;inputs_[which]),
            &amp;GetFileIterator, table_cache_, options);
      }
    }
  }
  assert(num &lt;= space);
  // &#28982;&#21518;&#20316;&#20026;&#19968;&#20010;merge iterator&#23384;&#22312;.
  Iterator* result = NewMergingIterator(&amp;icmp_, list, num);
  delete[] list;
  return result;
}
</pre>


</div>
</div>

</div>

<div id="outline-container-1-10-3-13" class="outline-5">
<h5 id="sec-1-10-3-13"><span class="section-number-5">1.10.3.13</span> VersionSetBuilder</h5>
<div class="outline-text-5" id="text-1-10-3-13">

<p>db/version_set.cc VersoionSetBuilder存在作用就是为了能够高效地做version edit对象的回放.
沃恩首先看看里面可能涉及到的结构.注意这里面我们没有修改base对应的version对象,只是在SaveTo
的时候可以将这些log全部作用到base这个对象,写到新的对象上面.
</p>


<pre class="src src-C++">// A helper class so we can efficiently apply a whole sequence
// of edits to a particular state without creating intermediate
// Versions that contain full copies of the intermediate state.
class VersionSet::Builder {
 private:
  // Helper to sort by v-&gt;files_[file_number].smallest
  struct BySmallestKey {
    const InternalKeyComparator* internal_comparator;

    bool operator()(FileMetaData* f1, FileMetaData* f2) const {
      int r = internal_comparator-&gt;Compare(f1-&gt;smallest, f2-&gt;smallest);
      if (r != 0) {
        return (r &lt; 0);
      } else {
        // Break ties by file number
        return (f1-&gt;number &lt; f2-&gt;number);
      }
    }
  };

  typedef std::set&lt;FileMetaData*, BySmallestKey&gt; FileSet;
  struct LevelState { // &#27599;&#20010;level&#38656;&#35201;&#22686;&#21152;&#21644;&#21024;&#38500;&#30340;&#25991;&#20214;.
    std::set&lt;uint64_t&gt; deleted_files;
    FileSet* added_files;
  };

  VersionSet* vset_;
  Version* base_; // &#38024;&#23545;&#26576;&#19968;&#20010;version&#36827;&#34892;&#30340;edit&#25805;&#20316;.
  LevelState levels_[config::kNumLevels];
};
</pre>



</div>

<div id="outline-container-1-10-3-13-1" class="outline-6">
<h6 id="sec-1-10-3-13-1"><span class="section-number-6">1.10.3.13.1</span> VersionSetBuilder</h6>
<div class="outline-text-6" id="text-1-10-3-13-1">

<p>首先看看构造和析构函数.不是非常麻烦.对于析构函数的话将所有的add files refs&ndash;.
</p>


<pre class="src src-C++">// Initialize a builder with the files from *base and other info from *vset
Builder(VersionSet* vset, Version* base)
    : vset_(vset),
      base_(base) {
  base_-&gt;Ref();
  BySmallestKey cmp;
  cmp.internal_comparator = &amp;vset_-&gt;icmp_;
  for (int level = 0; level &lt; config::kNumLevels; level++) {
    levels_[level].added_files = new FileSet(cmp);
  }
}

~Builder() {
  // &#23558;&#25152;&#26377;&#30340;add files&#20840;&#37096;refs--.
  // &#27880;&#24847;&#22312;SaveTo&#30340;&#26102;&#20505;&#20250;&#23558;FileMetaData&#36825;&#37096;&#20998;&#30340;ref&#36716;&#20041;&#21040;SaveTo&#30340;Version&#19978;&#38754;.
  for (int level = 0; level &lt; config::kNumLevels; level++) {
    const FileSet* added = levels_[level].added_files;
    std::vector&lt;FileMetaData*&gt; to_unref;
    to_unref.reserve(added-&gt;size());
    for (FileSet::const_iterator it = added-&gt;begin();
        it != added-&gt;end(); ++it) {
      to_unref.push_back(*it);
    }
    delete added;
    for (uint32_t i = 0; i &lt; to_unref.size(); i++) {
      FileMetaData* f = to_unref[i];
      f-&gt;refs--;
      if (f-&gt;refs &lt;= 0) {
        delete f;
      }
    }
  }
  base_-&gt;Unref();
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-13-2" class="outline-6">
<h6 id="sec-1-10-3-13-2"><span class="section-number-6">1.10.3.13.2</span> Apply</h6>
<div class="outline-text-6" id="text-1-10-3-13-2">

<p>将edit这个log记录起来.可能会被调用多次.
</p>


<pre class="src src-C++">// Apply all of the edits in *edit to the current state.
void Apply(VersionEdit* edit) {
  // Update compaction pointers
  for (size_t i = 0; i &lt; edit-&gt;compact_pointers_.size(); i++) {
    const int level = edit-&gt;compact_pointers_[i].first;
    vset_-&gt;compact_pointer_[level] =
        edit-&gt;compact_pointers_[i].second.Encode().ToString();
  }

  // Delete files
  const VersionEdit::DeletedFileSet&amp; del = edit-&gt;deleted_files_;
  for (VersionEdit::DeletedFileSet::const_iterator iter = del.begin();
       iter != del.end();
       ++iter) {
    const int level = iter-&gt;first;
    const uint64_t number = iter-&gt;second;
    levels_[level].deleted_files.insert(number);
  }

  // Add new files
  for (size_t i = 0; i &lt; edit-&gt;new_files_.size(); i++) {
    const int level = edit-&gt;new_files_[i].first;
    FileMetaData* f = new FileMetaData(edit-&gt;new_files_[i].second);
    f-&gt;refs = 1;

    // We arrange to automatically compact this file after
    // a certain number of seeks.  Let's assume:
    //   (1) One seek costs 10ms
    //   (2) Writing or reading 1MB costs 10ms (100MB/s)
    //   (3) A compaction of 1MB does 25MB of IO:
    //         1MB read from this level
    //         10-12MB read from next level (boundaries may be misaligned)
    //         10-12MB written to next level
    // This implies that 25 seeks cost the same as the compaction
    // of 1MB of data.  I.e., one seek costs approximately the
    // same as the compaction of 40KB of data.  We are a little
    // conservative and allow approximately one seek for every 16KB
    // of data before triggering a compaction.
    // &#35774;&#32622;allow seek&#30340;&#38480;&#21046;,&#36229;&#36807;&#36825;&#20040;&#22810;&#30340;&#38480;&#21046;&#20043;&#21518;&#30340;&#35805;&#37027;&#20040;&#20316;&#20026;&#28508;&#22312;&#30340;compaction&#25991;&#20214;.
    f-&gt;allowed_seeks = (f-&gt;file_size / 16384);
    if (f-&gt;allowed_seeks &lt; 100) f-&gt;allowed_seeks = 100;

    levels_[level].deleted_files.erase(f-&gt;number);
    levels_[level].added_files-&gt;insert(f);
  }
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-13-3" class="outline-6">
<h6 id="sec-1-10-3-13-3"><span class="section-number-6">1.10.3.13.3</span> MaybeAddFile</h6>
<div class="outline-text-6" id="text-1-10-3-13-3">

<p>将f添加到新增加到对应level的文件列表尾部.需要确保没有overlap并且没有存在于标记删除文件集合中.
</p>


<pre class="src src-C++">void MaybeAddFile(Version* v, int level, FileMetaData* f) {
  if (levels_[level].deleted_files.count(f-&gt;number) &gt; 0) {
    // File is deleted: do nothing
  } else {
    std::vector&lt;FileMetaData*&gt;* files = &amp;v-&gt;files_[level];
    if (level &gt; 0 &amp;&amp; !files-&gt;empty()) {
      // Must not overlap
      assert(vset_-&gt;icmp_.Compare((*files)[files-&gt;size()-1]-&gt;largest,
                                  f-&gt;smallest) &lt; 0);
    }
    f-&gt;refs++;
    files-&gt;push_back(f);
  }
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-13-4" class="outline-6">
<h6 id="sec-1-10-3-13-4"><span class="section-number-6">1.10.3.13.4</span> SaveTo</h6>
<div class="outline-text-6" id="text-1-10-3-13-4">

<p>当前通过edit修改后的状态保存到新的version里面.我们来仔细看看这个过程.将之前edit回放的内容
保存在v这个version里面来.典型使用方法非常简单.
</p><ul>
<li>首先构造builder对象
</li>
<li>Apply使用某个edit.
</li>
<li>SaveTo生成某个version.
</li>
</ul>




<pre class="src src-C++">// Save the current state in *v.
void SaveTo(Version* v) {
  BySmallestKey cmp;
  cmp.internal_comparator = &amp;vset_-&gt;icmp_;
  for (int level = 0; level &lt; config::kNumLevels; level++) {
    // Merge the set of added files with the set of pre-existing files.
    // Drop any deleted files.  Store the result in *v.
    const std::vector&lt;FileMetaData*&gt;&amp; base_files = base_-&gt;files_[level];
    std::vector&lt;FileMetaData*&gt;::const_iterator base_iter = base_files.begin();
    std::vector&lt;FileMetaData*&gt;::const_iterator base_end = base_files.end();
    const FileSet* added = levels_[level].added_files;
    v-&gt;files_[level].reserve(base_files.size() + added-&gt;size());
    // &#36825;&#37324;&#24517;&#39035;&#25353;&#29031;&#26368;&#23567;&#30340;key&#26469;&#36827;&#34892;&#25490;&#24207;.&#36825;&#37324;&#26159;&#23384;&#22312;&#39034;&#24207;&#38382;&#39064;&#30340;.
    // &#20294;&#26159;&#23545;&#20110;level&gt;0&#30340;&#23618;&#26469;&#35828;&#37324;&#38754;&#30340;&#25991;&#20214;&#37117;&#26159;&#19981;&#37325;&#22797;&#30340;.
    for (FileSet::const_iterator added_iter = added-&gt;begin();
         added_iter != added-&gt;end();
         ++added_iter) {
      // Add all smaller files listed in base_
      for (std::vector&lt;FileMetaData*&gt;::const_iterator bpos
               = std::upper_bound(base_iter, base_end, *added_iter, cmp);
           base_iter != bpos;
           ++base_iter) {
        MaybeAddFile(v, level, *base_iter);
      }

      MaybeAddFile(v, level, *added_iter);
    }

    // Add remaining base files
    for (; base_iter != base_end; ++base_iter) {
      MaybeAddFile(v, level, *base_iter);
    }
  }
}
</pre>


</div>
</div>

</div>

<div id="outline-container-1-10-3-14" class="outline-5">
<h5 id="sec-1-10-3-14"><span class="section-number-5">1.10.3.14</span> Compaction</h5>
<div class="outline-text-5" id="text-1-10-3-14">

<p>db/version_set.h Compaction包含的是进行compaction操作的信息.针对compaction对象通常是current version
所对应的文件。我们首先来看看Compaction结构.
</p>


<pre class="src src-C++">// A Compaction encapsulates information about a compaction.
class Compaction {
 public:

  int level_; // &#38024;&#23545;&#21738;&#20010;level&#36827;&#34892;
  uint64_t max_output_file_size_; // compaction&#20043;&#21518;&#21333;&#20010;&#25991;&#20214;&#30340;&#26368;&#22823;&#22823;&#23567;.
  Version* input_version_; // &#38024;&#23545;&#21738;&#20010;version&#36827;&#34892;&#25805;&#20316;.
  VersionEdit edit_; // &#24212;&#35813;&#26159;&#38024;&#23545;version&#25805;&#20316;&#20043;&#21518;&#30340;log&#20449;&#24687;.&#27604;&#22914;&#21024;&#38500;&#21738;&#20123;&#25991;&#20214;&#28155;&#21152;&#20102;&#21738;&#20123;&#25991;&#20214;&#31561;.

  // Each compaction reads inputs from <span style="color: #ffff00;">"level_"</span> and <span style="color: #ffff00;">"level_+1"</span>
  std::vector&lt;FileMetaData*&gt; inputs_[2];      // The two sets of inputs. &#35201;&#36827;&#34892;compaction&#30340;&#25991;&#20214;&#26377;&#21738;&#20123;.
  //1 &#24212;&#35813;&#23601;&#26159;parent level.

  // State used to check for number of of overlapping grandparent files
  // (parent == level_ + 1, grandparent == level_ + 2)
  std::vector&lt;FileMetaData*&gt; grandparents_;
  size_t grandparent_index_;  // Index in grandparent_starts_
  bool seen_key_;             // Some output key has been seen
  int64_t overlapped_bytes_;  // Bytes of overlap between current output
                              // and grandparent files

  // State for implementing IsBaseLevelForKey

  // level_ptrs_ holds indices into input_version_-&gt;levels_: our state
  // is that we are positioned at one of the file ranges for each
  // higher level than the ones involved in this compaction (i.e. for
  // all L &gt;= level_ + 2).
  size_t level_ptrs_[config::kNumLevels];
};
</pre>



</div>

<div id="outline-container-1-10-3-14-1" class="outline-6">
<h6 id="sec-1-10-3-14-1"><span class="section-number-6">1.10.3.14.1</span> Compaction</h6>
<div class="outline-text-6" id="text-1-10-3-14-1">

<p>构造函数过程非常简单.析构函数的话也只是将input_version_修改引用计数。
</p>


<pre class="src src-C++">Compaction::Compaction(int level)
    : level_(level),
      max_output_file_size_(MaxFileSizeForLevel(level)), // &#36825;&#20010;&#20989;&#25968;&#21518;&#38754;&#20998;&#26512;.
      input_version_(NULL),
      grandparent_index_(0),
      seen_key_(false),
      overlapped_bytes_(0) {
  for (int i = 0; i &lt; config::kNumLevels; i++) {
    level_ptrs_[i] = 0;
  }
}
Compaction::~Compaction() {
  if (input_version_ != NULL) {
    input_version_-&gt;Unref(); // NOTICE(zhangyan04):&#36825;&#20010;&#38750;&#24120;&#37325;&#35201;
    // &#22914;&#26524;&#36825;&#20010;compaction&#23436;&#25104;&#30340;&#35805;,&#37027;&#20040;version&#23601;&#20250;&#38144;&#27585;.
  }
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-14-2" class="outline-6">
<h6 id="sec-1-10-3-14-2"><span class="section-number-6">1.10.3.14.2</span> MaxFileSizeForLevel</h6>
<div class="outline-text-6" id="text-1-10-3-14-2">

<p>每一层单个文件大小最大是多少.现在实现非常简单是一个固定值.
</p>


<pre class="src src-C++">static const int kTargetFileSize = 2 * 1048576; // 2MB.
static uint64_t MaxFileSizeForLevel(int level) {
  return kTargetFileSize;  // We could vary per level to reduce number of files?
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-14-3" class="outline-6">
<h6 id="sec-1-10-3-14-3"><span class="section-number-6">1.10.3.14.3</span> MaxBytesForLevel</h6>
<div class="outline-text-6" id="text-1-10-3-14-3">

<p>每一层文件所占用的字节数上限是多少.level0,1是10MB.以后每上一层*10.
</p>


<pre class="src src-C++">static double MaxBytesForLevel(int level) {
  // Note: the result for level zero is not really used since we set
  // the level-0 compaction threshold based on number of files.
  double result = 10 * 1048576.0;  // Result for both level-0 and level-1
  while (level &gt; 1) {
    result *= 10;
    level--;
  }
  return result;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-14-4" class="outline-6">
<h6 id="sec-1-10-3-14-4"><span class="section-number-6">1.10.3.14.4</span> IsTrivialMove</h6>
<div class="outline-text-6" id="text-1-10-3-14-4">

<p>这个compaction是否为简单的移动.需要满足3个条件
</p>


<pre class="src src-C++">bool Compaction::IsTrivialMove() const {
  // Avoid a move if there is lots of overlapping grandparent data.
  // Otherwise, the move could create a parent file that will require
  // a very expensive merge later on.
  return (num_input_files(0) == 1 &amp;&amp; // level 1&#20010;&#25991;&#20214;
          num_input_files(1) == 0 &amp;&amp; // level+1 &#27809;&#26377;&#25991;&#20214;
          // grandparent level&#23384;&#22312;overlap&#30340;&#25991;&#20214;&#22823;&#23567;&#27809;&#26377;&#36807;&#22823;.
          TotalFileSize(grandparents_) &lt;= kMaxGrandParentOverlapBytes);
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-14-5" class="outline-6">
<h6 id="sec-1-10-3-14-5"><span class="section-number-6">1.10.3.14.5</span> AddInputDeletions</h6>
<div class="outline-text-6" id="text-1-10-3-14-5">

<p>通知这次操作做了文件的删除.将这些可以删除的文件填写到edit里面.做好compaction之后的话，
那么inputs_里面的文件基本上就没有用途就可以被删除了。
</p>


<pre class="src src-C++">void Compaction::AddInputDeletions(VersionEdit* edit) {
  for (int which = 0; which &lt; 2; which++) {
    for (size_t i = 0; i &lt; inputs_[which].size(); i++) {
      edit-&gt;DeleteFile(level_ + which, inputs_[which][i]-&gt;number);
    }
  }
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-14-6" class="outline-6">
<h6 id="sec-1-10-3-14-6"><span class="section-number-6">1.10.3.14.6</span> IsBaseLevelForKey</h6>
<div class="outline-text-6" id="text-1-10-3-14-6">

<p>在db_impl.cc里面的DoCompactionWork里面调用了.具体策略实现没有太仔细分析.判断某个key在高层是否还存在.
</p>


<pre class="src src-C++">bool Compaction::IsBaseLevelForKey(const Slice&amp; user_key) {
  // Maybe use binary search to find right entry instead of linear search?
  const Comparator* user_cmp = input_version_-&gt;vset_-&gt;icmp_.user_comparator();
  for (int lvl = level_ + 2; lvl &lt; config::kNumLevels; lvl++) {
    const std::vector&lt;FileMetaData*&gt;&amp; files = input_version_-&gt;files_[lvl];
    for (; level_ptrs_[lvl] &lt; files.size(); ) {
      FileMetaData* f = files[level_ptrs_[lvl]];
      if (user_cmp-&gt;Compare(user_key, f-&gt;largest.user_key()) &lt;= 0) {
        // We've advanced far enough
        if (user_cmp-&gt;Compare(user_key, f-&gt;smallest.user_key()) &gt;= 0) {
          // Key falls in this file's range, so definitely not base level
          return false;
        }
        break;
      }
      level_ptrs_[lvl]++;
    }
  }
  return true;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-14-7" class="outline-6">
<h6 id="sec-1-10-3-14-7"><span class="section-number-6">1.10.3.14.7</span> ShouldStopBefore</h6>
<div class="outline-text-6" id="text-1-10-3-14-7">

<p>在db_impl.cc里面的DoCompactionWork里面调用了.作用是判断这个key的话是否应该停止然后
重新开辟一个新的文件用于compaction的输出.这是一个策略,大致应该是希望这个key如果
和grandparent level重合不要过多.更具体的策略方面不太清楚.
</p>


<pre class="src src-C++">bool Compaction::ShouldStopBefore(const Slice&amp; internal_key) {
  // Scan to find earliest grandparent file that contains key.
  const InternalKeyComparator* icmp = &amp;input_version_-&gt;vset_-&gt;icmp_;
  while (grandparent_index_ &lt; grandparents_.size() &amp;&amp;
      icmp-&gt;Compare(internal_key,
                    grandparents_[grandparent_index_]-&gt;largest.Encode()) &gt; 0) {
    if (seen_key_) {
      overlapped_bytes_ += grandparents_[grandparent_index_]-&gt;file_size;
    }
    grandparent_index_++;
  }
  seen_key_ = true;

  if (overlapped_bytes_ &gt; kMaxGrandParentOverlapBytes) {
    // Too much overlap for current output; start new output
    overlapped_bytes_ = 0;
    return true;
  } else {
    return false;
  }
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-14-8" class="outline-6">
<h6 id="sec-1-10-3-14-8"><span class="section-number-6">1.10.3.14.8</span> ReleaseInputs</h6>
<div class="outline-text-6" id="text-1-10-3-14-8">




<pre class="src src-C++">void Compaction::ReleaseInputs() {
  if (input_version_ != NULL) {
    input_version_-&gt;Unref();
    input_version_ = NULL;
  }
}
</pre>


</div>
</div>

</div>

<div id="outline-container-1-10-3-15" class="outline-5">
<h5 id="sec-1-10-3-15"><span class="section-number-5">1.10.3.15</span> CompactionState</h5>
<div class="outline-text-5" id="text-1-10-3-15">

<p>db/db_impl.cc CompactionState里面记录的是在这次Compaction时候保存的状态.Compaction只是
保存了本次compaction操作所需要的信息，但是没有保存过程状态.
</p>


<pre class="src src-C++">struct DBImpl::CompactionState {
  Compaction* const compaction; // &#26412;&#27425;compaction&#25152;&#38656;&#35201;&#36827;&#34892;&#30340;&#25805;&#20316;.

  // Sequence numbers &lt; smallest_snapshot are not significant since we
  // will never have to service a snapshot below smallest_snapshot.
  // Therefore if we have seen a sequence number S &lt;= smallest_snapshot,
  // we can drop all entries for the same key with sequence numbers &lt; S.
  SequenceNumber smallest_snapshot; // &#24403;&#21069;&#26377;&#25928;&#30340;sequence number&#26159;&#22810;&#23569;.

  // Files produced by compaction
  struct Output {
    uint64_t number; // &#36755;&#20986;&#25991;&#20214;number.
    uint64_t file_size; // &#36755;&#20986;&#25991;&#20214;&#22823;&#23567;
    InternalKey smallest, largest; // &#36755;&#20986;&#25991;&#20214;size.
  };
  std::vector&lt;Output&gt; outputs;

  // State kept for output being generated
  WritableFile* outfile; // &#24403;&#21069;&#36755;&#20986;&#25991;&#20214;&#20197;&#21450;table_builder.
  TableBuilder* builder;

  uint64_t total_bytes;

  Output* current_output() { return &amp;outputs[outputs.size()-1]; }

  explicit CompactionState(Compaction* c)
      : compaction(c),
        outfile(NULL),
        builder(NULL),
        total_bytes(0) {
  }
};
</pre>


</div>

</div>

<div id="outline-container-1-10-3-16" class="outline-5">
<h5 id="sec-1-10-3-16"><span class="section-number-5">1.10.3.16</span> VersionEdit</h5>
<div class="outline-text-5" id="text-1-10-3-16">

<p>db/version_edit.h 阅读完DBImpl::NewDB的话就会发现VersionEdit里面存储的是整个数据库的元信息.
元信息序列化之后作为log写入到Manifest文件里面去。CURRENT文件里面存放的就是当前Manifest文件.
我们首先看看VersionEdit的结构以及里面的字段。个人觉得VersionEdit本身是非常简单的，但是需要了解各个字段含义。
</p>
<p>
(dirlt):阅读完Compaction之后，觉得这个结构更多的含义应该是针对Version进行Compaction这个过程，对于
Version造成了哪些变动，比如增加或者是删除啦哪些文件，下一个file number以及sequence是什么。将这些
内容记录到log(manifest)里面这样启动的时候就可以进行恢复。
</p>


<pre class="src src-C++">class VersionEdit {
  // private:
 public:
  friend class VersionSet;

  typedef std::set&lt; std::pair&lt;int, uint64_t&gt; &gt; DeletedFileSet;

  std::string comparator_; // &#27604;&#36739;&#22120;&#30340;&#21517;&#23383;.&#36825;&#26679;&#21487;&#20197;&#38450;&#27490;&#25105;comparator&#30340;&#21464;&#21160;&#36896;&#25104;db&#30340;&#36923;&#36753;&#25439;&#22351;.
  uint64_t log_number_; //
  uint64_t prev_log_number_;
  uint64_t next_file_number_;
  SequenceNumber last_sequence_; // &#19978;&#27425;&#25805;&#20316;&#23436;&#25104;&#20043;&#21518;&#30340;&#24207;&#21015;&#21495;.
  bool has_comparator_;
  bool has_log_number_;
  bool has_prev_log_number_;
  bool has_next_file_number_;
  bool has_last_sequence_;

  std::vector&lt; std::pair&lt;int, InternalKey&gt; &gt; compact_pointers_;
  DeletedFileSet deleted_files_;
  std::vector&lt; std::pair&lt;int, FileMetaData&gt; &gt; new_files_;
};
</pre>



</div>

<div id="outline-container-1-10-3-16-1" class="outline-6">
<h6 id="sec-1-10-3-16-1"><span class="section-number-6">1.10.3.16.1</span> SetCompactPoint</h6>
<div class="outline-text-6" id="text-1-10-3-16-1">




<pre class="src src-C++">void SetCompactPointer(int level, const InternalKey&amp; key) {
  compact_pointers_.push_back(std::make_pair(level, key));
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-16-2" class="outline-6">
<h6 id="sec-1-10-3-16-2"><span class="section-number-6">1.10.3.16.2</span> AddFile</h6>
<div class="outline-text-6" id="text-1-10-3-16-2">

<p>相当于告诉db系统新增加了这么一个文件以及这个文件里面的信息是什么.这样可以方便db操作.
</p>


<pre class="src src-C++">void AddFile(int level, uint64_t file,
             uint64_t file_size,
             const InternalKey&amp; smallest,
             const InternalKey&amp; largest) {
  FileMetaData f;
  f.number = file;
  f.file_size = file_size;
  f.smallest = smallest;
  f.largest = largest;
  new_files_.push_back(std::make_pair(level, f));
}
</pre>


</div>

</div>

<div id="outline-container-1-10-3-16-3" class="outline-6">
<h6 id="sec-1-10-3-16-3"><span class="section-number-6">1.10.3.16.3</span> DeleteFile</h6>
<div class="outline-text-6" id="text-1-10-3-16-3">

<p>告诉db系统删除了这个文件.删除并没有操作new_files数组.而是放进了一个set.
</p>


<pre class="src src-C++">// Delete the specified <span style="color: #ffff00;">"file"</span> from the specified <span style="color: #ffff00;">"level"</span>.
void DeleteFile(int level, uint64_t file) {
  deleted_files_.insert(std::make_pair(level, file));
}
</pre>


</div>
</div>

</div>

<div id="outline-container-1-10-3-17" class="outline-5">
<h5 id="sec-1-10-3-17"><span class="section-number-5">1.10.3.17</span> ByteWiseComparatorImpl</h5>
<div class="outline-text-5" id="text-1-10-3-17">

<p>util/comparator.cc 对于Compare实现使用slice对象的compare实现。我们着重看看上面两个接口实现
</p>


<pre class="src src-C++">virtual void FindShortestSeparator(
    std::string* start,
    const Slice&amp; limit) const {
  // Find length of common prefix
  size_t min_length = std::min(start-&gt;size(), limit.size());
  size_t diff_index = 0;
  while ((diff_index &lt; min_length) &amp;&amp;
         ((*start)[diff_index] == limit[diff_index])) {
    diff_index++;
  }

  // &#23454;&#29616;&#19978;&#20165;&#20165;&#26159;&#23545;&#20110;&#31532;&#19968;&#20010;&#19981;&#21516;&#30340;&#23383;&#31526;&#23581;&#35797;+1
  if (diff_index &gt;= min_length) {
    // Do not shorten if one string is a prefix of the other
  } else {
    uint8_t diff_byte = static_cast&lt;uint8_t&gt;((*start)[diff_index]);
    if (diff_byte &lt; static_cast&lt;uint8_t&gt;(0xff) &amp;&amp;
        diff_byte + 1 &lt; static_cast&lt;uint8_t&gt;(limit[diff_index])) {
      (*start)[diff_index]++;  // +1
      start-&gt;resize(diff_index + 1); // &#24182;&#19988;&#20462;&#25913;&#38271;&#24230;
      assert(Compare(*start, limit) &lt; 0);
    }
  }
}

virtual void FindShortSuccessor(std::string* key) const {
  // Find first character that can be incremented
  size_t n = key-&gt;size();
  for (size_t i = 0; i &lt; n; i++) {
    const uint8_t byte = (*key)[i];
    if (byte != static_cast&lt;uint8_t&gt;(0xff)) {
      (*key)[i] = byte + 1; // +1
      key-&gt;resize(i+1); // &#20462;&#25913;&#38271;&#24230;
      return;
    }
  }
  // *key is a run of 0xffs.  Leave it alone.
}
</pre>

<p>
还算是比较直白吧.
</p>
</div>

</div>

<div id="outline-container-1-10-3-18" class="outline-5">
<h5 id="sec-1-10-3-18"><span class="section-number-5">1.10.3.18</span> SnapshotImpl</h5>
<div class="outline-text-5" id="text-1-10-3-18">

<p>db/snapshot.h Snapshot实现非常简单，就是一个双向链表的节点，然后挂在一个双向链表上面。
每一个Snapshot实现都附带一个seq number.对于Snapshot最重要的应该是在上面的操作吧.
我们可以猜想对于每次插入的key都会带上一个seq number.这样如果对snapshot操作的话读取的话，
那么只需要读取seq number以下的内容即可了。
</p>


<pre class="src src-C++">// Snapshots are kept in a doubly-linked list in the DB.
// Each SnapshotImpl corresponds to a particular sequence number.
class SnapshotImpl : public Snapshot {
 public:
  SequenceNumber number_;  // const after creation

 private:
  friend class SnapshotList;

  // SnapshotImpl is kept in a doubly-linked circular list
  SnapshotImpl* prev_;
  SnapshotImpl* next_;

  SnapshotList* list_;                 // just for sanity checks
};

class SnapshotList {
 public:
  SnapshotList() {
    list_.prev_ = &amp;list_;
    list_.next_ = &amp;list_;
  }

  bool empty() const { return list_.next_ == &amp;list_; }
  SnapshotImpl* oldest() const { assert(!empty()); return list_.next_; }
  SnapshotImpl* newest() const { assert(!empty()); return list_.prev_; }

  const SnapshotImpl* New(SequenceNumber seq) { // &#20998;&#37197;&#19968;&#20010;snapshot&#23454;&#20363;
    SnapshotImpl* s = new SnapshotImpl;
    s-&gt;number_ = seq;
    s-&gt;list_ = this;
    s-&gt;next_ = &amp;list_;
    s-&gt;prev_ = list_.prev_;
    s-&gt;prev_-&gt;next_ = s;
    s-&gt;next_-&gt;prev_ = s;
    return s;
  }

  void Delete(const SnapshotImpl* s) { // &#23558;&#36825;&#20010;snapshot&#20174;&#38142;&#20013;&#21024;&#38500;
    assert(s-&gt;list_ == this);
    s-&gt;prev_-&gt;next_ = s-&gt;next_;
    s-&gt;next_-&gt;prev_ = s-&gt;prev_;
    delete s;
  }

 private:
  // Dummy head of doubly-linked list of snapshots
  SnapshotImpl list_;
};
</pre>


<p>
这里SequenceNumber的实现是一个在db/dbformat.h里面定义了
</p>


<pre class="src src-C++">typedef uint64_t SequenceNumber;
</pre>


</div>
</div>

</div>

<div id="outline-container-1-10-4" class="outline-4">
<h4 id="sec-1-10-4"><span class="section-number-4">1.10.4</span> Posix</h4>
<div class="outline-text-4" id="text-1-10-4">


</div>

<div id="outline-container-1-10-4-1" class="outline-5">
<h5 id="sec-1-10-4-1"><span class="section-number-5">1.10.4.1</span> PosixEnv</h5>
<div class="outline-text-5" id="text-1-10-4-1">

<p>util/env_posix.cc PosixEnv是Env接口的实现。PosixEnv的大部分实现都相当直接.不过这里还是把代码贴上了，主要是方便在一些细小的地方进行注记。
</p>


<pre class="src src-C++">class PosixEnv : public Env {
 public:
  PosixEnv();
  virtual ~PosixEnv() {
    fprintf(stderr, <span style="color: #ffff00;">"Destroying Env::Default()\n"</span>);
    exit(1);
  }

  virtual Status NewSequentialFile(const std::string&amp; fname,
                                   SequentialFile** result) {
    FILE* f = fopen(fname.c_str(), <span style="color: #ffff00;">"r"</span>);
    if (f == NULL) {
      *result = NULL;
      return IOError(fname, errno);
    } else {
      *result = new PosixSequentialFile(fname, f);
      return Status::OK();
    }
  }

  virtual Status NewRandomAccessFile(const std::string&amp; fname,
                                     RandomAccessFile** result) {
    int fd = open(fname.c_str(), O_RDONLY);
    if (fd &lt; 0) {
      *result = NULL;
      return IOError(fname, errno);
    }
    *result = new PosixRandomAccessFile(fname, fd);
    return Status::OK();
  }

  virtual Status NewWritableFile(const std::string&amp; fname,
                                 WritableFile** result) {
    Status s;
    const int fd = open(fname.c_str(), O_CREAT | O_RDWR | O_TRUNC, 0644);
    if (fd &lt; 0) {
      *result = NULL;
      s = IOError(fname, errno);
    } else {
      *result = new PosixMmapFile(fname, fd, page_size_);
    }
    return s;
  }

  virtual bool FileExists(const std::string&amp; fname) {
    return access(fname.c_str(), F_OK) == 0;
  }

  virtual Status GetChildren(const std::string&amp; dir,
                             std::vector&lt;std::string&gt;* result) {
    result-&gt;clear();
    DIR* d = opendir(dir.c_str());
    if (d == NULL) {
      return IOError(dir, errno);
    }
    struct dirent* entry;
    while ((entry = readdir(d)) != NULL) {
      result-&gt;push_back(entry-&gt;d_name);
    }
    closedir(d);
    return Status::OK();
  }

  virtual Status DeleteFile(const std::string&amp; fname) {
    Status result;
    if (unlink(fname.c_str()) != 0) {
      result = IOError(fname, errno);
    }
    return result;
  };

  virtual Status CreateDir(const std::string&amp; name) {
    Status result;
    if (mkdir(name.c_str(), 0755) != 0) {
      result = IOError(name, errno);
    }
    return result;
  };

  virtual Status DeleteDir(const std::string&amp; name) {
    Status result;
    if (rmdir(name.c_str()) != 0) {
      result = IOError(name, errno);
    }
    return result;
  };

  virtual Status GetFileSize(const std::string&amp; fname, uint64_t* size) {
    Status s;
    struct stat sbuf;
    if (stat(fname.c_str(), &amp;sbuf) != 0) {
      *size = 0;
      s = IOError(fname, errno);
    } else {
      *size = sbuf.st_size;
    }
    return s;
  }

  virtual Status RenameFile(const std::string&amp; src, const std::string&amp; target) {
    Status result;
    if (rename(src.c_str(), target.c_str()) != 0) {
      result = IOError(src, errno);
    }
    return result;
  }

  virtual Status LockFile(const std::string&amp; fname, FileLock** lock) {
    *lock = NULL;
    Status result;
    int fd = open(fname.c_str(), O_RDWR | O_CREAT, 0644); // &#21019;&#24314;&#19968;&#20010;&#25991;&#20214;&#34920;&#31034;&#38145;&#20303;.
    if (fd &lt; 0) {
      result = IOError(fname, errno);
    } else if (LockOrUnlock(fd, true) == -1) { // &#36825;&#20010;&#20250;&#22312;&#21518;&#38754;&#20180;&#32454;&#30475;&#30475;.true&#34920;&#31034;lock.
      result = IOError(<span style="color: #ffff00;">"lock "</span> + fname, errno);
      close(fd);
    } else {
      PosixFileLock* my_lock = new PosixFileLock; // &#21019;&#24314;&#19968;&#20010;PosixFileLock&#23545;&#35937;
      my_lock-&gt;fd_ = fd; // &#26631;&#35760;fd.
      *lock = my_lock;
    }
    return result;
  }

  virtual Status UnlockFile(FileLock* lock) {
    PosixFileLock* my_lock = reinterpret_cast&lt;PosixFileLock*&gt;(lock);
    Status result;
    if (LockOrUnlock(my_lock-&gt;fd_, false) == -1) { // false&#34920;&#31034;unlock
      result = IOError(<span style="color: #ffff00;">"unlock"</span>, errno);
    }
    close(my_lock-&gt;fd_); // &#20851;&#38381;&#23545;&#24212;&#30340;&#25991;&#20214;&#25551;&#36848;&#31526;.
    delete my_lock;
    return result;
  }

  virtual void Schedule(void (*function)(void*), void* arg);

  virtual void StartThread(void (*function)(void* arg), void* arg);

  virtual Status GetTestDirectory(std::string* result) {
    const char* env = getenv(<span style="color: #ffff00;">"TEST_TMPDIR"</span>);
    if (env &amp;&amp; env[0] != '\0') {
      *result = env;
    } else {
      char buf[100];
      snprintf(buf, sizeof(buf), <span style="color: #ffff00;">"/tmp/leveldbtest-%d"</span>, int(geteuid()));
      *result = buf;
    }
    // Directory may already exist
    CreateDir(*result);
    return Status::OK();
  }

  static uint64_t gettid() {
    pthread_t tid = pthread_self();
    uint64_t thread_id = 0;
    memcpy(&amp;thread_id, &amp;tid, std::min(sizeof(thread_id), sizeof(tid)));
    return thread_id;
  }

  virtual Status NewLogger(const std::string&amp; fname, Logger** result) {
    FILE* f = fopen(fname.c_str(), <span style="color: #ffff00;">"w"</span>);
    if (f == NULL) {
      *result = NULL;
      return IOError(fname, errno);
    } else {
      *result = new PosixLogger(f, &amp;PosixEnv::gettid); // Logger.&#21518;&#38754;&#20250;&#20180;&#32454;&#20998;&#26512;.
      return Status::OK();
    }
  }

  virtual uint64_t NowMicros() {
    struct timeval tv;
    gettimeofday(&amp;tv, NULL);
    return static_cast&lt;uint64_t&gt;(tv.tv_sec) * 1000000 + tv.tv_usec;
  }

  virtual void SleepForMicroseconds(int micros) {
    usleep(micros);
  }

 private:
  void PthreadCall(const char* label, int result) {
    if (result != 0) {
      fprintf(stderr, <span style="color: #ffff00;">"pthread %s: %s\n"</span>, label, strerror(result));
      exit(1);
    }
  }

  // &#29468;&#24819;DB&#21518;&#38754;&#26377;&#19968;&#20010;&#32447;&#31243;&#23436;&#25104;&#19968;&#20123;&#20107;&#24773;&#36890;&#36807;queue&#26469;&#36827;&#34892;&#36890;&#30693;.
  // BGThread() is the body of the background thread
  void BGThread();
  static void* BGThreadWrapper(void* arg) {
    reinterpret_cast&lt;PosixEnv*&gt;(arg)-&gt;BGThread();
    return NULL;
  }

  size_t page_size_;
  pthread_mutex_t mu_; // queue&#30340;&#38145;&#21644;&#26465;&#20214;&#21464;&#37327;
  pthread_cond_t bgsignal_;
  pthread_t bgthread_; // background thread identity.
  bool started_bgthread_; // bg thread&#26159;&#21542;&#21551;&#21160;

  // Entry per Schedule() call
  // background item&#36824;&#26159;&#27604;&#36739;&#36890;&#29992;&#30340;,function+arg.
  struct BGItem { void* arg; void (*function)(void*); };
  typedef std::deque&lt;BGItem&gt; BGQueue; // Background queue&#38431;&#21015;.
  BGQueue queue_;
};
</pre>



</div>

<div id="outline-container-1-10-4-1-1" class="outline-6">
<h6 id="sec-1-10-4-1-1"><span class="section-number-6">1.10.4.1.1</span> LockOrUnlock</h6>
<div class="outline-text-6" id="text-1-10-4-1-1">

<p>将fd设置成写锁.lock表示是加锁还是解锁.这里flock不需要保留空间只是传引用即可,对于内部调用仅仅是修改了fd的一个标记吧.
</p>


<pre class="src src-C++">static int LockOrUnlock(int fd, bool lock) {
  errno = 0;
  struct flock f;
  memset(&amp;f, 0, sizeof(f));
  f.l_type = (lock ? F_WRLCK : F_UNLCK);
  f.l_whence = SEEK_SET;
  f.l_start = 0;
  f.l_len = 0;        // Lock/unlock entire file
  return fcntl(fd, F_SETLK, &amp;f);
}
</pre>


</div>

</div>

<div id="outline-container-1-10-4-1-2" class="outline-6">
<h6 id="sec-1-10-4-1-2"><span class="section-number-6">1.10.4.1.2</span> Schedule</h6>
<div class="outline-text-6" id="text-1-10-4-1-2">

<p>Schedule语义就是将一个function+arg丢到background里面运行.background线程是惰性初始化的.
注意background只有一个执行线程，需要考虑工作是否会阻塞住。
</p>



<pre class="src src-C++">void PosixEnv::Schedule(void (*function)(void*), void* arg) {
  PthreadCall(<span style="color: #ffff00;">"lock"</span>, pthread_mutex_lock(&amp;mu_));

  // Start background thread if necessary
  if (!started_bgthread_) {
    started_bgthread_ = true;
    PthreadCall( // &#21019;&#24314;&#32447;&#31243;.
        <span style="color: #ffff00;">"create thread"</span>,
        pthread_create(&amp;bgthread_, NULL,  &amp;PosixEnv::BGThreadWrapper, this));
  }

  // If the queue is currently empty, the background thread may currently be
  // waiting.
  if (queue_.empty()) {
    PthreadCall(<span style="color: #ffff00;">"signal"</span>, pthread_cond_signal(&amp;bgsignal_)); // &#38431;&#21015;&#36890;&#30693;
  }

  // Add to priority queue
  queue_.push_back(BGItem()); // &#22312;&#38431;&#21015;&#20869;&#37096;&#21152;&#20837;&#23545;&#35937;.
  queue_.back().function = function;
  queue_.back().arg = arg;

  PthreadCall(<span style="color: #ffff00;">"unlock"</span>, pthread_mutex_unlock(&amp;mu_));
}
</pre>


<p>
其中BGThreadWrapper非常简单调用BGThread函数执行
</p>


<pre class="src src-C++">  static void* BGThreadWrapper(void* arg) {
    reinterpret_cast&lt;PosixEnv*&gt;(arg)-&gt;BGThread();
    return NULL;
  }
void PosixEnv::BGThread() {
  while (true) {
    // Wait until there is an item that is ready to run
    PthreadCall(<span style="color: #ffff00;">"lock"</span>, pthread_mutex_lock(&amp;mu_));
    while (queue_.empty()) {
      PthreadCall(<span style="color: #ffff00;">"wait"</span>, pthread_cond_wait(&amp;bgsignal_, &amp;mu_));
    }

    void (*function)(void*) = queue_.front().function; // &#22312;&#32447;&#31243;&#20869;&#37096;&#25191;&#34892;&#20989;&#25968;.
    void* arg = queue_.front().arg;
    queue_.pop_front();

    PthreadCall(<span style="color: #ffff00;">"unlock"</span>, pthread_mutex_unlock(&amp;mu_));
    (*function)(arg);
  }
}
</pre>


</div>

</div>

<div id="outline-container-1-10-4-1-3" class="outline-6">
<h6 id="sec-1-10-4-1-3"><span class="section-number-6">1.10.4.1.3</span> StartThread</h6>
<div class="outline-text-6" id="text-1-10-4-1-3">

<p>启动一个线程.但是似乎有限制没有能力进行join.
</p>


<pre class="src src-C++">void PosixEnv::StartThread(void (*function)(void* arg), void* arg) {
  pthread_t t;
  StartThreadState* state = new StartThreadState;
  state-&gt;user_function = function;
  state-&gt;arg = arg;
  PthreadCall(<span style="color: #ffff00;">"start thread"</span>,
              pthread_create(&amp;t, NULL,  &amp;StartThreadWrapper, state));
}
</pre>


</div>

</div>

<div id="outline-container-1-10-4-1-4" class="outline-6">
<h6 id="sec-1-10-4-1-4"><span class="section-number-6">1.10.4.1.4</span> Default</h6>
<div class="outline-text-6" id="text-1-10-4-1-4">

<p>Default是为了获得Env的一个实例.为了防止多个线程产生多个Env实例.使用pthread_once来产生.
</p>


<pre class="src src-C++">static pthread_once_t once = PTHREAD_ONCE_INIT;
static Env* default_env;
static void InitDefaultEnv() { default_env = new PosixEnv; }

Env* Env::Default() {
  pthread_once(&amp;once, InitDefaultEnv);
  return default_env;
}
</pre>


</div>
</div>

</div>

<div id="outline-container-1-10-4-2" class="outline-5">
<h5 id="sec-1-10-4-2"><span class="section-number-5">1.10.4.2</span> PosixFileLock</h5>
<div class="outline-text-5" id="text-1-10-4-2">

<p>util/env_posix.cc PosixFilLock是FileLock的实现。基本上PosixFileLock没有任何内容，里面只需要维护fd即可。然后在LockOrUnlock里面操作fd即可以加锁解锁
</p>


<pre class="src src-C++">class PosixFileLock : public FileLock {
 public:
  int fd_;
};
</pre>


</div>

</div>

<div id="outline-container-1-10-4-3" class="outline-5">
<h5 id="sec-1-10-4-3"><span class="section-number-5">1.10.4.3</span> PosixLogger</h5>
<div class="outline-text-5" id="text-1-10-4-3">

<p>util/posix_logger.h PosixLogger是Logger的实现。我们主要看看logger打印了哪些信息，并且稍微看看如果我们写logger的话大致应该需要考虑什么问题
PosixLogger持有了FILE*对象以及gettid的函数指针.只有一个方法Logv
</p>


<pre class="src src-C++">virtual void Logv(const char* format, va_list ap) {
  const uint64_t thread_id = (*gettid_)();

  // We try twice: the first time with a fixed-size stack allocated buffer,
  // and the second time with a much larger dynamically allocated buffer.
  // &#36825;&#20010;&#22320;&#26041;&#20540;&#24471;&#23398;&#20064;&#19968;&#19979;.&#31532;&#19968;&#27425;&#20351;&#29992;stack&#20998;&#37197;&#20869;&#23384;&#65292;&#31532;&#20108;&#27425;&#20351;&#29992;heap&#20998;&#37197;&#20869;&#23384;.
  char buffer[500];
  for (int iter = 0; iter &lt; 2; iter++) {
    char* base;
    int bufsize;
    if (iter == 0) {
      bufsize = sizeof(buffer);
      base = buffer;
    } else {
      bufsize = 30000;
      base = new char[bufsize];
    }
    char* p = base;
    char* limit = base + bufsize;

    struct timeval now_tv;
    gettimeofday(&amp;now_tv, NULL);
    const time_t seconds = now_tv.tv_sec;
    struct tm t;
    localtime_r(&amp;seconds, &amp;t); // &#26412;&#22320;&#26102;&#38388;+microseconds &#32447;&#31243;&#21495; &#33258;&#23450;&#20041;&#26684;&#24335;.
    p += snprintf(p, limit - p,
                  <span style="color: #ffff00;">"%04d/%02d/%02d-%02d:%02d:%02d.%06d %llx "</span>,
                  t.tm_year + 1900,
                  t.tm_mon + 1,
                  t.tm_mday,
                  t.tm_hour,
                  t.tm_min,
                  t.tm_sec,
                  static_cast&lt;int&gt;(now_tv.tv_usec),
                  static_cast&lt;long long unsigned int&gt;(thread_id));

    // Print the message
    if (p &lt; limit) {
      va_list backup_ap;
      va_copy(backup_ap, ap);
      p += vsnprintf(p, limit - p, format, backup_ap);
      va_end(backup_ap);
    }

    // Truncate to available space if necessary
    if (p &gt;= limit) { // &#22914;&#26524;&#36229;&#36807;&#30340;&#35805;&#24182;&#19988;&#26159;stack&#20998;&#37197;&#37027;&#20040;&#37325;&#26032;&#19968;&#36718;.
      if (iter == 0) {
        continue;       // Try again with larger buffer
      } else {
        p = limit - 1; // &#31532;&#20108;&#36718;&#30340;&#35805;&#36827;&#34892;&#25130;&#26029;.
      }
    }

    // Add newline if necessary
    if (p == base || p[-1] != '\n') { // &#30830;&#20445;&#23384;&#22312;&#25442;&#34892;.
      *p++ = '\n';
    }

    assert(p &lt;= limit);
    fwrite(base, 1, p - base, file_); // &#20889;&#20837;&#25991;&#20214;&#24182;&#19988;&#36825;&#37324;&#27880;&#24847;&#38656;&#35201;flush.
    fflush(file_);
    if (base != buffer) {
      delete[] base;
    }
    break;
  }
}
</pre>


</div>

</div>

<div id="outline-container-1-10-4-4" class="outline-5">
<h5 id="sec-1-10-4-4"><span class="section-number-5">1.10.4.4</span> PosixRandomAccessFile</h5>
<div class="outline-text-5" id="text-1-10-4-4">

<p>util/env_posix.cc PosixRandomAccessFile是RandomAccessFile的实现。对于随机读取的话使用pread应该就可以了.
</p>


<pre class="src src-C++">virtual Status Read(uint64_t offset, size_t n, Slice* result,
                    char* scratch) const {
  Status s;
  ssize_t r = pread(fd_, scratch, n, static_cast&lt;off_t&gt;(offset));
  *result = Slice(scratch, (r &lt; 0) ? 0 : r);
  if (r &lt; 0) {
    // An error: return a non-ok status
    s = IOError(filename_, errno);
  }
  return s;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-4-5" class="outline-5">
<h5 id="sec-1-10-4-5"><span class="section-number-5">1.10.4.5</span> PosixSequentialFile</h5>
<div class="outline-text-5" id="text-1-10-4-5">

<p>util/env_posix.cc PosixSequentialFile是SequentialFile的实现。内部实现的持有FILE*指针.猜想对于顺序访问而言的话，缓存还是会非常有效果的
</p>


<pre class="src src-C++">virtual Status Read(size_t n, Slice* result, char* scratch) {
  Status s;
  size_t r = fread_unlocked(scratch, 1, n, file_);
  *result = Slice(scratch, r);
  if (r &lt; n) {
    if (feof(file_)) {
      // We leave status as ok if we hit the end of the file
    } else {
      // A partial read with an error: return a non-ok status
      s = IOError(filename_, errno);
    }
  }
  return s;
}

virtual Status Skip(uint64_t n) {
  if (fseek(file_, n, SEEK_CUR)) { // &#20174;&#24403;&#21069;&#36339;&#36807;n&#20010;&#23383;&#33410;.
    return IOError(filename_, errno);
  }
  return Status::OK();
}
</pre>

<p>
fread_unlocked表示内部不会存在多个线程来读取这个文件.可以在一定程度上提高性能.
</p>
</div>

</div>

<div id="outline-container-1-10-4-6" class="outline-5">
<h5 id="sec-1-10-4-6"><span class="section-number-5">1.10.4.6</span> PosixMmapFile</h5>
<div class="outline-text-5" id="text-1-10-4-6">

<p>util/env_posix.cc PosixMmapFile是为了实现WritableFile的.内部使用mmap来实现的文件追加写和同步方式.还是比较精巧的，值得仔细看看
</p>


<pre class="src src-C++">PosixMmapFile(const std::string&amp; fname, int fd, size_t page_size)
    : filename_(fname),
      fd_(fd),
      page_size_(page_size),
      map_size_(Roundup(65536, page_size)), // 65536 roundup to pagesize&#20316;&#20026;&#19968;&#20010;mmap&#30340;&#22823;&#23567;.
      base_(NULL), // mmap&#20986;&#26469;&#30340;base,dst(&#24403;&#21069;&#21487;&#29992;&#22320;&#22336;),limit(&#32467;&#26463;&#22320;&#22336;)
      limit_(NULL),
      dst_(NULL),
      last_sync_(NULL), // &#19979;&#36733;&#36827;&#34892;sync&#30340;&#36215;&#22987;&#22320;&#22336;
      file_offset_(0), //
      pending_sync_(false) { // &#26159;&#21542;&#23384;&#22312;pending sync&#30913;&#30424;&#20869;&#23481;.&#21542;&#21017;&#38656;&#35201;&#35843;&#29992;fdatasync
  assert((page_size &amp; (page_size - 1)) == 0);
}


~PosixMmapFile() {
  if (fd_ &gt;= 0) {
    PosixMmapFile::Close();
  }
}

virtual Status Append(const Slice&amp; data) { // &#23581;&#35797;&#22686;&#21152;&#25968;&#25454;.
  const char* src = data.data();
  size_t left = data.size();
  while (left &gt; 0) { // &#22914;&#26524;&#36824;&#26377;&#37096;&#20998;&#25968;&#25454;&#27809;&#26377;&#20889;&#20837;.
    assert(base_ &lt;= dst_);
    assert(dst_ &lt;= limit_);
    size_t avail = limit_ - dst_;
    if (avail == 0) {
      if (!UnmapCurrentRegion() || // unmap&#24403;&#21069;&#30340;&#21306;&#22495;&#24182;&#19988;&#20998;&#37197;&#26032;&#30340;&#21306;&#22495;.
          !MapNewRegion()) {
        return IOError(filename_, errno);
      }
    }

    size_t n = (left &lt;= avail) ? left : avail;
    memcpy(dst_, src, n);
    dst_ += n;
    src += n;
    left -= n;
  }
  return Status::OK();
}

virtual Status Close() {
  Status s;
  size_t unused = limit_ - dst_;
  if (!UnmapCurrentRegion()) { // &#23558;&#21097;&#20313;&#30340;&#37096;&#20998;unmap&#25481;
    s = IOError(filename_, errno);
  } else if (unused &gt; 0) {
    // Trim the extra space at the end of the file
    if (ftruncate(fd_, file_offset_ - unused) &lt; 0) { // &#21516;&#26102;&#38656;&#35201;truncate&#22810;mmap&#30340;&#37096;&#20998;.
      s = IOError(filename_, errno);
    }
  }

  if (close(fd_) &lt; 0) {
    if (s.ok()) {
      s = IOError(filename_, errno);
    }
  }

  fd_ = -1;
  base_ = NULL;
  limit_ = NULL;
  return s;
}

virtual Status Flush() {
  return Status::OK();
}

virtual Status Sync() {
  Status s;

  if (pending_sync_) { // &#22914;&#26524;&#23384;&#22312;&#38656;&#35201;sync&#30340;&#37096;&#20998;.
    // Some unmapped data was not synced
    pending_sync_ = false;
    if (fdatasync(fd_) &lt; 0) { // &#23558;&#36825;&#20010;&#37096;&#20998;data sync.
      s = IOError(filename_, errno);
    }
  }

  if (dst_ &gt; last_sync_) { // &#23558;&#20869;&#23384;&#37096;&#20998;&#36827;&#34892;sync.
    // Find the beginnings of the pages that contain the first and last
    // bytes to be synced.
    size_t p1 = TruncateToPageBoundary(last_sync_ - base_); // &#21487;&#33021;&#20250;&#22810;msync&#37096;&#20998;&#20294;&#26159;&#27809;&#26377;&#20851;&#31995;.
    size_t p2 = TruncateToPageBoundary(dst_ - base_ - 1);
    last_sync_ = dst_;
    if (msync(base_ + p1, p2 - p1 + page_size_, MS_SYNC) &lt; 0) {
      s = IOError(filename_, errno);
    }
  }

  return s;
}
</pre>



</div>

<div id="outline-container-1-10-4-6-1" class="outline-6">
<h6 id="sec-1-10-4-6-1"><span class="section-number-6">1.10.4.6.1</span> Roundup</h6>
<div class="outline-text-6" id="text-1-10-4-6-1">

<p>Roundup非常简单.使用时候就是希望mapsize作为pagesize的整数倍存在.
</p>


<pre class="src src-C++">// Roundup x to a multiple of y
static size_t Roundup(size_t x, size_t y) {
  return ((x + y - 1) / y) * y;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-4-6-2" class="outline-6">
<h6 id="sec-1-10-4-6-2"><span class="section-number-6">1.10.4.6.2</span> TruncateToPageBoundar</h6>
<div class="outline-text-6" id="text-1-10-4-6-2">

<p>我们需要记住这个函数的语境，是将s的长度截断到pagesize整数倍，这样可以让msync刷新确保正确。
</p>


<pre class="src src-C++">size_t TruncateToPageBoundary(size_t s) {
  s -= (s &amp; (page_size_ - 1));
  assert((s % page_size_) == 0);
  return s;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-4-6-3" class="outline-6">
<h6 id="sec-1-10-4-6-3"><span class="section-number-6">1.10.4.6.3</span> UnmapCurrentRegion</h6>
<div class="outline-text-6" id="text-1-10-4-6-3">

<p>解除当前的内存映射。
</p>



<pre class="src src-C++">bool UnmapCurrentRegion() {
  bool result = true;
  if (base_ != NULL) {
    if (last_sync_ &lt; limit_) { // &#22914;&#26524;&#19978;&#19968;&#27425;&#27809;&#20869;&#23384;&#26144;&#23556;&#23436;&#25104;&#30340;&#35805;.
      // Defer syncing this data until next Sync() call, if any
      pending_sync_ = true;
    }
    if (munmap(base_, limit_ - base_) != 0) { // &#35299;&#38500;&#20869;&#23384;&#26144;&#23556;.
      result = false;
    }
    file_offset_ += limit_ - base_; // &#24403;&#21069;fileoffset&#26377;&#22810;&#23569;.
    base_ = NULL;
    limit_ = NULL;
    last_sync_ = NULL;
    dst_ = NULL;

    // Increase the amount we map the next time, but capped at 1MB
    if (map_size_ &lt; (1&lt;&lt;20)) { // &#19979;&#27425;mapsize&#38656;&#35201;&#32763;&#20493;.
      map_size_ *= 2;
    }
  }
  return result;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-4-6-4" class="outline-6">
<h6 id="sec-1-10-4-6-4"><span class="section-number-6">1.10.4.6.4</span> MapNewRegion</h6>
<div class="outline-text-6" id="text-1-10-4-6-4">

<p>使用mmap分配一块新的内存然后用于后续的写文件
</p>


<pre class="src src-C++">bool MapNewRegion() {
  assert(base_ == NULL);
  if (ftruncate(fd_, file_offset_ + map_size_) &lt; 0) { // &#22240;&#20026;&#36825;&#27425;&#25105;&#20204;&#25171;&#31639;&#21482;&#20889;file_offset+map_size&#36825;&#20040;&#22823;
    // &#25152;&#20197;&#22810;&#20313;&#30340;&#37096;&#20998;&#25105;&#20204;&#21487;&#20197;&#25130;&#26029;.
    return false;
  }
  void* ptr = mmap(NULL, map_size_, PROT_READ | PROT_WRITE, MAP_SHARED,
                   fd_, file_offset_);
  if (ptr == MAP_FAILED) {
    return false;
  }
  base_ = reinterpret_cast&lt;char*&gt;(ptr);
  limit_ = base_ + map_size_;
  dst_ = base_;
  last_sync_ = base_;
  return true;
}
</pre>


</div>
</div>
</div>

</div>

<div id="outline-container-1-10-5" class="outline-4">
<h4 id="sec-1-10-5"><span class="section-number-4">1.10.5</span> Cache</h4>
<div class="outline-text-4" id="text-1-10-5">


</div>

<div id="outline-container-1-10-5-1" class="outline-5">
<h5 id="sec-1-10-5-1"><span class="section-number-5">1.10.5.1</span> ShardedLRUCache</h5>
<div class="outline-text-5" id="text-1-10-5-1">

<p>util/cache.cc 所谓Shard意思非常简单，就是将所有的请求进行load-balance.首先看看字段.里面使用到了LRUCache.LRUCache后面会讲到
</p>


<pre class="src src-C++">static const int kNumShardBits = 4;
static const int kNumShards = 1 &lt;&lt; kNumShardBits;

class ShardedLRUCache : public Cache {
 private:
  LRUCache shard_[kNumShards];
  port::Mutex id_mutex_;
  uint64_t last_id_;
};
</pre>

<p>
可以看到有16个slot.对于load-balance策略也非常简单.取hash结果的高位.
</p>


<pre class="src src-C++">static uint32_t Shard(uint32_t hash) {
  return hash &gt;&gt; (32 - kNumShardBits);
}
</pre>

<p>
对于Shard而言的话，capacity也需要进行均分:)
</p>


<pre class="src src-C++">explicit ShardedLRUCache(size_t capacity)
    : last_id_(0) {
  const size_t per_shard = (capacity + (kNumShards - 1)) / kNumShards;
  for (int s = 0; s &lt; kNumShards; s++) {
    shard_[s].SetCapacity(per_shard);
  }
}
</pre>


</div>

</div>

<div id="outline-container-1-10-5-2" class="outline-5">
<h5 id="sec-1-10-5-2"><span class="section-number-5">1.10.5.2</span> LRUCache</h5>
<div class="outline-text-5" id="text-1-10-5-2">

<p>util/cache.cc LRUCache实现就是按照LRU来实现的.LRUCache每一个item是一个LRUHandle，而LRUHandle管理是放在HandleTable里面管理的。
</p>


<pre class="src src-C++">// A single shard of sharded cache.
class LRUCache {
 public:
  LRUCache();
  ~LRUCache();

  // Separate from constructor so caller can easily make an array of LRUCache
  void SetCapacity(size_t capacity) { capacity_ = capacity; }

  // Like Cache methods, but with an extra <span style="color: #ffff00;">"hash"</span> parameter.
  Cache::Handle* Insert(const Slice&amp; key, uint32_t hash,
                        void* value, size_t charge,
                        void (*deleter)(const Slice&amp; key, void* value));
  Cache::Handle* Lookup(const Slice&amp; key, uint32_t hash);
  void Release(Cache::Handle* handle);
  void Erase(const Slice&amp; key, uint32_t hash);

 private:
  void LRU_Remove(LRUHandle* e);
  void LRU_Append(LRUHandle* e);
  void Unref(LRUHandle* e);

  // Initialized before use.
  size_t capacity_; // usage_&#30340;&#26368;&#22823;&#20540;.

  // mutex_ protects the following state.
  port::Mutex mutex_; // &#23545;&#20110;&#22810;&#32447;&#31243;&#26377;&#25928;
  size_t usage_; // &#24403;&#21069;&#20351;&#29992;&#22823;&#23567;.+=Insert&#21442;&#25968;&#30340;charge.
  uint64_t last_id_; // &#22312;ShardedLRUCache&#37324;&#38754;&#20351;&#29992;

  // Dummy head of LRU list.
  // lru.prev is newest entry, lru.next is oldest entry.
  LRUHandle lru_; // LRU&#38142;.

  HandleTable table_; // LRUHandle&#30340;&#31649;&#29702;&#23545;&#35937;&#34920;(hashtable).
};
</pre>

<p>
对于LRU_Remove/LRU_Append非常简单.这里稍微着重看看Insert/Loopup/Release/Erase的实现.
</p>

</div>

<div id="outline-container-1-10-5-2-1" class="outline-6">
<h6 id="sec-1-10-5-2-1"><span class="section-number-6">1.10.5.2.1</span> Insert</h6>
<div class="outline-text-6" id="text-1-10-5-2-1">

<p>Insert的工作就是创建一个LRUHandle对象加入hashtable以及LRU队列里面.注意这里的引用计数
</p>


<pre class="src src-C++">Cache::Handle* LRUCache::Insert(
    const Slice&amp; key, uint32_t hash, void* value, size_t charge,
    void (*deleter)(const Slice&amp; key, void* value)) {
  MutexLock l(&amp;mutex_);

  LRUHandle* e = reinterpret_cast&lt;LRUHandle*&gt;(
      malloc(sizeof(LRUHandle)-1 + key.size()));
  e-&gt;value = value; // value.
  e-&gt;deleter = deleter; // &#21024;&#38500;&#20989;&#25968;
  e-&gt;charge = charge; // &#21344;&#29992;&#22823;&#23567;
  e-&gt;key_length = key.size(); // key
  e-&gt;hash = hash; // hash
  e-&gt;refs = 2;  // One from LRUCache, one for the returned handle
  memcpy(e-&gt;key_data, key.data(), key.size());
  LRU_Append(e); // &#21152;&#20837;LRU&#38431;&#21015;
  usage_ += charge; // &#24403;&#21069;&#21344;&#29992;&#37327;

  LRUHandle* old = table_.Insert(e);
  if (old != NULL) { // &#28120;&#27760;&#20986;&#30340;&#20869;&#23481;.
    LRU_Remove(old);
    Unref(old);
  }

  while (usage_ &gt; capacity_ &amp;&amp; lru_.next != &amp;lru_) {
    LRUHandle* old = lru_.next;
    LRU_Remove(old);
    table_.Remove(old-&gt;key(), old-&gt;hash);
    Unref(old);
  }

  return reinterpret_cast&lt;Cache::Handle*&gt;(e);
}
</pre>


</div>

</div>

<div id="outline-container-1-10-5-2-2" class="outline-6">
<h6 id="sec-1-10-5-2-2"><span class="section-number-6">1.10.5.2.2</span> Lookup</h6>
<div class="outline-text-6" id="text-1-10-5-2-2">




<pre class="src src-C++">Cache::Handle* LRUCache::Lookup(const Slice&amp; key, uint32_t hash) {
  MutexLock l(&amp;mutex_);
  LRUHandle* e = table_.Lookup(key, hash); // &#25214;&#21040;&#23545;&#35937;
  if (e != NULL) {
    e-&gt;refs++; // &#38656;&#35201;&#20462;&#25913;&#24341;&#29992;&#35745;&#25968;.
    LRU_Remove(e); // &#20462;&#25913;&#19968;&#19979;LRU&#29366;&#24577;.
    LRU_Append(e);
  }
  return reinterpret_cast&lt;Cache::Handle*&gt;(e);
}
</pre>


</div>

</div>

<div id="outline-container-1-10-5-2-3" class="outline-6">
<h6 id="sec-1-10-5-2-3"><span class="section-number-6">1.10.5.2.3</span> Release</h6>
<div class="outline-text-6" id="text-1-10-5-2-3">




<pre class="src src-C++">void LRUCache::Release(Cache::Handle* handle) {
  MutexLock l(&amp;mutex_);
  Unref(reinterpret_cast&lt;LRUHandle*&gt;(handle)); // &#20943;&#23569;&#24341;&#29992;&#35745;&#25968;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-5-2-4" class="outline-6">
<h6 id="sec-1-10-5-2-4"><span class="section-number-6">1.10.5.2.4</span> Erase</h6>
<div class="outline-text-6" id="text-1-10-5-2-4">




<pre class="src src-C++">void LRUCache::Erase(const Slice&amp; key, uint32_t hash) {
  MutexLock l(&amp;mutex_);
  LRUHandle* e = table_.Remove(key, hash); // &#20174;table&#37324;&#38754;remove&#20986;&#26469;
  if (e != NULL) {
    LRU_Remove(e); // &#20174;LRU&#38431;&#21015;&#37324;&#38754;&#31227;&#38500;&#20986;&#26469;
    Unref(e); // --&#24341;&#29992;&#35745;&#25968;.
  }
}
</pre>


</div>
</div>

</div>

<div id="outline-container-1-10-5-3" class="outline-5">
<h5 id="sec-1-10-5-3"><span class="section-number-5">1.10.5.3</span> LRUHandle</h5>
<div class="outline-text-5" id="text-1-10-5-3">

<p>util/cache.cc LRUHandle是LRUCache的管理对象，我们主要就是为了看看里面的结构.LRUHandle一方面在LRU队列里面需要维护指针，
一方面在hashtable(HandleTable下面会讲到)需要维护指针.同时存在于LRU队列和HashTable里面.但是引用计数以LRU队列为准
</p>


<pre class="src src-C++">// An entry is a variable length heap-allocated structure.  Entries
// are kept in a circular doubly linked list ordered by access time.
struct LRUHandle {
  void* value;
  void (*deleter)(const Slice&amp;, void* value);
  LRUHandle* next_hash; // &#22312;hash table&#30340;&#21333;&#21521;&#38142;&#34920;.
  LRUHandle* next; // LRU&#38431;&#21015;&#25152;&#38656;&#35201;&#30340;&#25351;&#38024;.
  LRUHandle* prev;
  size_t charge;      // TODO(opt): Only allow uint32_t? // &#21344;&#29992;cache&#22823;&#23567;
  size_t key_length;
  uint32_t refs; // &#24341;&#29992;&#35745;&#25968;.
  uint32_t hash;      // Hash of key(); used for fast sharding and comparisons // &#21487;&#33021;&#38656;&#35201;&#36827;&#34892;rehash.
  char key_data[1];   // Beginning of key

  Slice key() const {
    // For cheaper lookups, we allow a temporary Handle object
    // to store a pointer to a key in <span style="color: #ffff00;">"value"</span>.
    if (next == this) {
      return *(reinterpret_cast&lt;Slice*&gt;(value));
    } else {
      return Slice(key_data, key_length);
    }
  }
};
</pre>


</div>

</div>

<div id="outline-container-1-10-5-4" class="outline-5">
<h5 id="sec-1-10-5-4"><span class="section-number-5">1.10.5.4</span> HandleTable</h5>
<div class="outline-text-5" id="text-1-10-5-4">

<p>util/cache.cc HandleTable实现非常简单，就是一个可扩展的hashtable.没有必要值得仔细分析。HandleTable主要就是用来管理
LRUHandle所管理的cache对象的。触发resize的操作是element &gt;= length.这里可以看看length的分配方式
</p>


<pre class="src src-C++">uint32_t new_length = 4;
while (new_length &lt; elems_) {
  new_length *= 2;
}
</pre>

<p>
length肯定是2^n.计算slot的方式就是
</p>


<pre class="src src-C++">LRUHandle** ptr = &amp;list_[hash &amp; (length_ - 1)];
</pre>


</div>
</div>

</div>

<div id="outline-container-1-10-6" class="outline-4">
<h4 id="sec-1-10-6"><span class="section-number-4">1.10.6</span> Batch</h4>
<div class="outline-text-4" id="text-1-10-6">


</div>

<div id="outline-container-1-10-6-1" class="outline-5">
<h5 id="sec-1-10-6-1"><span class="section-number-5">1.10.6.1</span> WriteBatch</h5>
<div class="outline-text-5" id="text-1-10-6-1">

<p>db/write_batch.cc db/write_batch_internal.h WriteBatch可以认为就是一个小型的数据记录仓库.
write_batch_internal.h里面是一些write_batch里面可能使用到的静态函数，将选择将声明放在这个头文件里面而不是放在include/leveldb/write_batch.h里面.
之前有一段注释表明WriteBatch内部二进制组织方式.
</p>


<pre class="src src-C++">// WriteBatch::rep_ :=
//    sequence: fixed64
//    count: fixed32
//    data: record[count]
// record :=
//    kTypeValue varstring varstring         |
//    kTypeDeletion varstring
// varstring :=
//    len: varint32
//    data: uint8[len]
</pre>

<ul>
<li>sequence fixed64
</li>
<li>记录长度 fixed32(因为这个写入是多次的,所以存放fixed比较容易修改)
</li>
<li>每条记录有头部表示数据还是删除.对于数据就是kv,对于删除只是存放k
</li>
<li>kv的话都是varint32 + data
</li>
</ul>

<p>这里rep_的类型是std::stirng.
</p>

</div>

<div id="outline-container-1-10-6-1-1" class="outline-6">
<h6 id="sec-1-10-6-1-1"><span class="section-number-6">1.10.6.1.1</span> Count</h6>
<div class="outline-text-6" id="text-1-10-6-1-1">




<pre class="src src-C++">int WriteBatchInternal::Count(const WriteBatch* b) {
  return DecodeFixed32(b-&gt;rep_.data() + 8);
}

void WriteBatchInternal::SetCount(WriteBatch* b, int n) {
  EncodeFixed32(&amp;b-&gt;rep_[8], n);
}
</pre>


</div>

</div>

<div id="outline-container-1-10-6-1-2" class="outline-6">
<h6 id="sec-1-10-6-1-2"><span class="section-number-6">1.10.6.1.2</span> Sequence</h6>
<div class="outline-text-6" id="text-1-10-6-1-2">




<pre class="src src-C++">SequenceNumber WriteBatchInternal::Sequence(const WriteBatch* b) {
  return SequenceNumber(DecodeFixed64(b-&gt;rep_.data()));
}

void WriteBatchInternal::SetSequence(WriteBatch* b, SequenceNumber seq) {
  EncodeFixed64(&amp;b-&gt;rep_[0], seq);
}
</pre>


</div>

</div>

<div id="outline-container-1-10-6-1-3" class="outline-6">
<h6 id="sec-1-10-6-1-3"><span class="section-number-6">1.10.6.1.3</span> Contents</h6>
<div class="outline-text-6" id="text-1-10-6-1-3">




<pre class="src src-C++">// &#30452;&#25509;&#35774;&#32622;WriteBatch&#20869;&#23481;.&#19981;&#36807;&#25105;&#35273;&#24471;&#24212;&#35813;&#27809;&#26377;&#22826;&#22810;&#29992;&#36884;&#21543;.
void WriteBatchInternal::SetContents(WriteBatch* b, const Slice&amp; contents) {
  assert(contents.size() &gt;= 12);
  b-&gt;rep_.assign(contents.data(), contents.size());
}
</pre>


</div>

</div>

<div id="outline-container-1-10-6-1-4" class="outline-6">
<h6 id="sec-1-10-6-1-4"><span class="section-number-6">1.10.6.1.4</span> Clear</h6>
<div class="outline-text-6" id="text-1-10-6-1-4">




<pre class="src src-C++">void WriteBatch::Clear() {
  rep_.clear();
  rep_.resize(12); // &#22836;&#37096;&#24517;&#28982;&#23384;&#25918;12&#20010;&#23383;&#33410;.
}
</pre>


</div>

</div>

<div id="outline-container-1-10-6-1-5" class="outline-6">
<h6 id="sec-1-10-6-1-5"><span class="section-number-6">1.10.6.1.5</span> Put</h6>
<div class="outline-text-6" id="text-1-10-6-1-5">




<pre class="src src-C++">void WriteBatch::Put(const Slice&amp; key, const Slice&amp; value) {
  WriteBatchInternal::SetCount(this, WriteBatchInternal::Count(this) + 1);
  rep_.push_back(static_cast&lt;char&gt;(kTypeValue)); // &#20165;&#20165;&#26159;value&#31867;&#22411;&#25805;&#20316;
  PutLengthPrefixedSlice(&amp;rep_, key); // &#25918;&#20837;k,v.&#20043;&#21069;&#37117;&#23384;&#25918;&#20102;&#38271;&#24230;.
  PutLengthPrefixedSlice(&amp;rep_, value);
}
</pre>


</div>

</div>

<div id="outline-container-1-10-6-1-6" class="outline-6">
<h6 id="sec-1-10-6-1-6"><span class="section-number-6">1.10.6.1.6</span> Delete</h6>
<div class="outline-text-6" id="text-1-10-6-1-6">




<pre class="src src-C++">void WriteBatch::Delete(const Slice&amp; key) {
  WriteBatchInternal::SetCount(this, WriteBatchInternal::Count(this) + 1);
  rep_.push_back(static_cast&lt;char&gt;(kTypeDeletion)); // &#20165;&#20165;&#26159;delete&#31867;&#22411;&#25805;&#20316;
  PutLengthPrefixedSlice(&amp;rep_, key); // &#20165;&#20165;&#26159;&#23384;&#25918;key.
}
</pre>


</div>

</div>

<div id="outline-container-1-10-6-1-7" class="outline-6">
<h6 id="sec-1-10-6-1-7"><span class="section-number-6">1.10.6.1.7</span> InsertInto</h6>
<div class="outline-text-6" id="text-1-10-6-1-7">




<pre class="src src-C++">// &#23558;WriteBatch&#20869;&#23481;&#20840;&#37096;&#25554;&#20837;&#21040;MemTable&#37324;&#38754;&#21435;.&#35843;&#29992;Iterate&#25509;&#21475;.
// MemTableInserter&#20250;&#22312;&#21518;&#38754;&#35762;&#35299;&#21040;.&#36825;&#20010;&#21487;&#20197;&#29992;&#20110;&#23558;WriteBatch&#25552;&#20132;.
Status WriteBatchInternal::InsertInto(const WriteBatch* b,
                                      MemTable* memtable) {
  MemTableInserter inserter;
  inserter.sequence_ = WriteBatchInternal::Sequence(b);
  inserter.mem_ = memtable;
  return b-&gt;Iterate(&amp;inserter);
}
</pre>


</div>

</div>

<div id="outline-container-1-10-6-1-8" class="outline-6">
<h6 id="sec-1-10-6-1-8"><span class="section-number-6">1.10.6.1.8</span> Iterate</h6>
<div class="outline-text-6" id="text-1-10-6-1-8">

<p>遍历内容存放到handler对象里面.要求handler有Put和Delete实现.这个实现在后面MemTableInserter有.
</p>


<pre class="src src-C++">Status WriteBatch::Iterate(Handler* handler) const {
  Slice input(rep_);
  if (input.size() &lt; 12) {
    return Status::Corruption(<span style="color: #ffff00;">"malformed WriteBatch (too small)"</span>);
  }

  // &#24573;&#30053;&#20043;&#21069;&#30340;12&#20010;&#23383;&#33410;.
  input.remove_prefix(12);
  Slice key, value;
  int found = 0; // found&#24212;&#35813;&#26159;&#29992;&#26469;&#36827;&#34892;&#26657;&#39564;&#30340;.
  while (!input.empty()) {
    found++;
    char tag = input[0];
    input.remove_prefix(1);
    switch (tag) {
      case kTypeValue: // &#22914;&#26524;&#26159;kv&#25968;&#25454;&#30340;&#35805;.
        if (GetLengthPrefixedSlice(&amp;input, &amp;key) &amp;&amp;
            GetLengthPrefixedSlice(&amp;input, &amp;value)) {
          handler-&gt;Put(key, value); // &#35843;&#29992;handler-&gt;Put&#25509;&#21475;.
        } else {
          return Status::Corruption(<span style="color: #ffff00;">"bad WriteBatch Put"</span>); // &#21542;&#21017;&#35748;&#20026;&#25968;&#25454;&#25439;&#22351;.
        }
        break;
      case kTypeDeletion: // &#22914;&#26524;&#26159;delete&#25805;&#20316;&#30340;&#35805;.
        if (GetLengthPrefixedSlice(&amp;input, &amp;key)) {
          handler-&gt;Delete(key); // &#37027;&#20040;&#35843;&#29992;Delete&#25509;&#21475;
        } else {
          return Status::Corruption(<span style="color: #ffff00;">"bad WriteBatch Delete"</span>);
        }
        break;
      default: // &#40664;&#35748;&#20026;&#25968;&#25454;&#25439;&#22351;.
        return Status::Corruption(<span style="color: #ffff00;">"unknown WriteBatch tag"</span>);
    }
  }
  // &#26657;&#39564;&#19968;&#19979;&#20010;&#25968;&#26159;&#21542;&#27491;&#30830;.
  if (found != WriteBatchInternal::Count(this)) {
    return Status::Corruption(<span style="color: #ffff00;">"WriteBatch has wrong count"</span>);
  } else {
    return Status::OK();
  }
}
</pre>


</div>
</div>

</div>

<div id="outline-container-1-10-6-2" class="outline-5">
<h5 id="sec-1-10-6-2"><span class="section-number-5">1.10.6.2</span> MemTable</h5>
<div class="outline-text-5" id="text-1-10-6-2">

<p>db/memtable.cc MemTable应该算是leveldb里面的table一种.只不过所有的内容都是存放在内存里面的。我们首先看看字段和数据结构.
(dirlt:阅读MemTable必须和WriteBatch的数据结构分开，这里非常容易弄混。WriteBatch是一个连续字节流的表示，是将所有的请求
序列化称为连续的字节流，而MemTable是将每一对kv做成一个连续字节流放入SkipList里面去.如果不分清楚的话这里非常容易搞混).
</p>

</div>

<div id="outline-container-1-10-6-2-1" class="outline-6">
<h6 id="sec-1-10-6-2-1"><span class="section-number-6">1.10.6.2.1</span> MemTable</h6>
<div class="outline-text-6" id="text-1-10-6-2-1">




<pre class="src src-C++">class MemTable {
 public:
  // MemTables are reference counted.  The initial reference count
  // is zero and the caller must call Ref() at least once.
  explicit MemTable(const InternalKeyComparator&amp; comparator);

  // Increase reference count.
  void Ref() { ++refs_; } // &#23384;&#22312;&#24341;&#29992;&#35745;&#25968;&#24182;&#19988;&#19968;&#24320;&#22987;==0.

  // Drop reference count.  Delete if no more references exist.
  void Unref() {
    --refs_;
    assert(refs_ &gt;= 0);
    if (refs_ &lt;= 0) {
      delete this;
    }
  }

  // Returns an estimate of the number of bytes of data in use by this
  // data structure.
  //
  // REQUIRES: external synchronization to prevent simultaneous
  // operations on the same MemTable.
  size_t ApproximateMemoryUsage(); // &#35843;&#29992;arena&#30340;MemoryUsage.&#22240;&#20026;&#36825;&#37324;&#38754;&#25152;&#26377;&#30340;&#20869;&#23384;&#37117;&#26159;&#20174;arena&#37324;&#38754;&#20998;&#37197;&#30340;.

  // Return an iterator that yields the contents of the memtable.
  //
  // The caller must ensure that the underlying MemTable remains live
  // while the returned iterator is live.  The keys returned by this
  // iterator are internal keys encoded by AppendInternalKey in the
  // db/format.{h,cc} module.
  Iterator* NewIterator(); // &#20135;&#29983;&#26032;&#30340;&#36845;&#20195;&#22120;.&#25509;&#19979;&#26469;&#25105;&#20204;&#20250;&#30475;&#30475;&#36845;&#20195;&#22120;&#26159;&#22914;&#20309;&#23454;&#29616;&#30340;&#12290;

  // Add an entry into memtable that maps key to value at the
  // specified sequence number and with the specified type.
  // Typically value will be empty if type==kTypeDeletion.
  void Add(SequenceNumber seq, ValueType type,
           const Slice&amp; key,
           const Slice&amp; value);

  // If memtable contains a value for key, store it in *value and return true.
  // If memtable contains a deletion for key, store a NotFound() error
  // in *status and return true.
  // Else, return false.
  bool Get(const LookupKey&amp; key, std::string* value, Status* s);

 private:
  ~MemTable();  // Private since only Unref() should be used to delete it

  struct KeyComparator {
    const InternalKeyComparator comparator;
    explicit KeyComparator(const InternalKeyComparator&amp; c) : comparator(c) { }
    int operator()(const char* a, const char* b) const;
  };
  friend class MemTableIterator;
  friend class MemTableBackwardIterator;

  typedef SkipList&lt;const char*, KeyComparator&gt; Table; // &#24213;&#23618;Table&#32467;&#26500;&#26159;&#20351;&#29992;SkipList&#23384;&#20648;&#30340;.

  KeyComparator comparator_; // k&#27604;&#36739;&#22120;.
  int refs_; // ref.
  Arena arena_; // &#20869;&#23384;&#20998;&#37197;
  Table table_; // table
};
</pre>


</div>

</div>

<div id="outline-container-1-10-6-2-2" class="outline-6">
<h6 id="sec-1-10-6-2-2"><span class="section-number-6">1.10.6.2.2</span> Compare</h6>
<div class="outline-text-6" id="text-1-10-6-2-2">

<p>这里KeyComparator的话因为考虑到key是length-prefixed的.底层使用InternalKeyComparator处理的就是
后面我们会看看InternalKeyComparator的实现.
</p>


<pre class="src src-C++">int MemTable::KeyComparator::operator()(const char* aptr, const char* bptr)
    const {
  // Internal keys are encoded as length-prefixed strings.
  Slice a = GetLengthPrefixedSlice(aptr);
  Slice b = GetLengthPrefixedSlice(bptr);
  return comparator.Compare(a, b); // &#36825;&#37324;&#35843;&#29992;&#24213;&#23618;&#30340;
  //InternalKeyComparator.&#27880;&#24847;&#36825;&#37324;&#30340;aptr,bptr&#21253;&#25324;&#20102;&#21518;&#38754;&#38468;&#21152;&#30340;8&#23383;&#33410;&#20449;&#24687;.(dirlt:&#27604;&#36739;&#32469;).
}
</pre>


</div>

</div>

<div id="outline-container-1-10-6-2-3" class="outline-6">
<h6 id="sec-1-10-6-2-3"><span class="section-number-6">1.10.6.2.3</span> Add</h6>
<div class="outline-text-6" id="text-1-10-6-2-3">




<pre class="src src-C++">void MemTable::Add(SequenceNumber s, ValueType type,
                   const Slice&amp; key,
                   const Slice&amp; value) {
  // Format of an entry is concatenation of:
  //  key_size     : varint32 of internal_key.size()
  //  key bytes    : char[internal_key.size()]
  //  value_size   : varint32 of value.size()
  //  value bytes  : char[value.size()]
  size_t key_size = key.size();
  size_t val_size = value.size();
  size_t internal_key_size = key_size + 8; // internal key size +8.
  const size_t encoded_len =
      // &#27880;&#24847;&#36825;&#37324;&#30340;key size&#21253;&#25324;&#20102;8&#23383;&#33410;&#30340;&#38468;&#21152;&#20449;&#24687;.
      VarintLength(internal_key_size) + internal_key_size +
      VarintLength(val_size) + val_size;
  char* buf = arena_.Allocate(encoded_len);
  char* p = EncodeVarint32(buf, internal_key_size);
  memcpy(p, key.data(), key_size);
  p += key_size;
  EncodeFixed64(p, (s &lt;&lt; 8) | type); // &#36825;&#23601;&#26159;8&#20010;&#23383;&#33410;&#20195;&#34920;&#30340;&#21547;&#20041;.(seq &lt;&lt; 8) | type.
  p += 8;
  p = EncodeVarint32(p, val_size);
  memcpy(p, value.data(), val_size);
  assert((p + val_size) - buf == encoded_len);
  table_.Insert(buf); // &#28982;&#21518;&#23558;&#36825;&#20010;key&#25554;&#20837;.
}
</pre>


</div>

</div>

<div id="outline-container-1-10-6-2-4" class="outline-6">
<h6 id="sec-1-10-6-2-4"><span class="section-number-6">1.10.6.2.4</span> Get</h6>
<div class="outline-text-6" id="text-1-10-6-2-4">




<pre class="src src-C++">// &#36825;&#37324;&#20351;&#29992;&#36845;&#20195;&#22120;&#26597;&#25214;&#23545;&#24212;&#30340;&#20869;&#23481;.&#26684;&#24335;&#30340;&#35805;&#21487;&#20197;&#21442;&#32771;Add&#30340;&#37324;&#38754;&#30340;&#23454;&#29616;
// key_size + key_data + (seq &lt;&lt; 8) | type(8 bytes) + val_size + val_data.
bool MemTable::Get(const LookupKey&amp; key, std::string* value, Status* s) {
  Slice memkey = key.memtable_key();
  Table::Iterator iter(&amp;table_);
  iter.Seek(memkey.data());
  if (iter.Valid()) {
    // entry format is:
    //    klength  varint32
    //    userkey  char[klength]
    //    tag      uint64
    //    vlength  varint32
    //    value    char[vlength]
    // Check that it belongs to same user key.  We do not check the
    // sequence number since the Seek() call above should have skipped
    // all entries with overly large sequence numbers.
    const char* entry = iter.key();
    uint32_t key_length;
    const char* key_ptr = GetVarint32Ptr(entry, entry+5, &amp;key_length);
    // &#27880;&#24847;&#36825;&#37324;&#20351;&#29992;&#24213;&#23618;&#30340;comparator&#26469;&#36827;&#34892;&#27604;&#36739;.
    if (comparator_.comparator.user_comparator()-&gt;Compare(
            Slice(key_ptr, key_length - 8),
            key.user_key()) == 0) {
      // Correct user key
      const uint64_t tag = DecodeFixed64(key_ptr + key_length - 8);
      switch (static_cast&lt;ValueType&gt;(tag &amp; 0xff)) {
        case kTypeValue: {
          Slice v = GetLengthPrefixedSlice(key_ptr + key_length);
          value-&gt;assign(v.data(), v.size());
          return true;
        }
        case kTypeDeletion:
          *s = Status::NotFound(Slice());
          return true;
      }
    }
  }
  return false;
}
</pre>


</div>
</div>

</div>

<div id="outline-container-1-10-6-3" class="outline-5">
<h5 id="sec-1-10-6-3"><span class="section-number-5">1.10.6.3</span> MemTableInserter</h5>
<div class="outline-text-5" id="text-1-10-6-3">

<p>db/write_batch.cc MemTableInserter作为WriteBatch::Handler实现,基本上可以认为是操作MemTable的代理类.
具体代码非常简单，实现部分可能需要看MemTable.这个后面会讲解
</p>


<pre class="src src-C++">class MemTableInserter : public WriteBatch::Handler {
 public:
  SequenceNumber sequence_;
  MemTable* mem_;

  virtual void Put(const Slice&amp; key, const Slice&amp; value) {
    mem_-&gt;Add(sequence_, kTypeValue, key, value);
    sequence_++; // &#36825;&#37324;&#36825;&#37324;sequence_&#22312;++.&#34429;&#28982;&#19981;&#22826;&#28165;&#26970;&#36825;&#37324;sequence&#26377;&#20160;&#20040;&#29992;&#36884;.
  }
  virtual void Delete(const Slice&amp; key) {
    mem_-&gt;Add(sequence_, kTypeDeletion, key, Slice());
    sequence_++;
  }
};
</pre>

<p>
至于sequence的初始值，在WriteBatchInternal::InsertInto里面是WriteBatch本身的Sequence作为初始值的。
</p>
</div>

</div>

<div id="outline-container-1-10-6-4" class="outline-5">
<h5 id="sec-1-10-6-4"><span class="section-number-5">1.10.6.4</span> MemtableIterator</h5>
<div class="outline-text-5" id="text-1-10-6-4">

<p>db/memtable.cc MemtableIterator实现非常简单，就是之前Table::Iterator的封装.后面我们会着重看看SkipList的实现.
</p>


<pre class="src src-C++">typedef SkipList&lt;const char*, KeyComparator&gt; Table;
class MemTableIterator: public Iterator {
 public:
  explicit MemTableIterator(MemTable::Table* table) : iter_(table) { }

  virtual bool Valid() const { return iter_.Valid(); }
  virtual void Seek(const Slice&amp; k) { iter_.Seek(EncodeKey(&amp;tmp_, k)); }
  virtual void SeekToFirst() { iter_.SeekToFirst(); }
  virtual void SeekToLast() { iter_.SeekToLast(); }
  virtual void Next() { iter_.Next(); }
  virtual void Prev() { iter_.Prev(); }
  virtual Slice key() const { return GetLengthPrefixedSlice(iter_.key()); }
  virtual Slice value() const {
    Slice key_slice = GetLengthPrefixedSlice(iter_.key());
    return GetLengthPrefixedSlice(key_slice.data() + key_slice.size());
  }

  virtual Status status() const { return Status::OK(); }

 private:
  MemTable::Table::Iterator iter_;
  std::string tmp_;       // For passing to EncodeKey
};
</pre>


</div>
</div>

</div>

<div id="outline-container-1-10-7" class="outline-4">
<h4 id="sec-1-10-7"><span class="section-number-4">1.10.7</span> Log</h4>
<div class="outline-text-4" id="text-1-10-7">


</div>

<div id="outline-container-1-10-7-1" class="outline-5">
<h5 id="sec-1-10-7-1"><span class="section-number-5">1.10.7.1</span> LogFormat</h5>
<div class="outline-text-5" id="text-1-10-7-1">

<p>db/log_format.h 里面规定的是db log格式上面的一些常量和信息.内容非常少，但是可以给予我们一点启发
</p>


<pre class="src src-C++">enum RecordType { // record&#31867;&#22411;.
  // Zero is reserved for preallocated files
  kZeroType = 0,

  kFullType = 1,

  // For fragments
  kFirstType = 2,
  kMiddleType = 3,
  kLastType = 4
};
static const int kMaxRecordType = kLastType;

static const int kBlockSize = 32768; // &#19968;&#20010;block&#22823;&#23567;.

// Header is checksum (4 bytes), type (1 byte), length (2 bytes).
// &#20174;EmitPhysicalRecord&#21487;&#20197;&#30475;&#21040;&#65292;&#23454;&#38469;&#23433;&#25490;&#26159;checksum,length,type.
static const int kHeaderSize = 4 + 1 + 2; // &#19968;&#20010;block&#30340;header&#26159;&#24590;&#20040;&#23433;&#25490;&#30340;.
</pre>


<p>
下面LogWriter以及LogReader里面给出这个格式的实现，代码里面可以看出具体的实现。
但是幸运的是在level的文档里面也有这个format的说明。
</p>


<pre class="example">The log file contents are a sequence of 32KB blocks.  The only
exception is that the tail of the file may contain a partial block.

Each block consists of a sequence of records:
   block := record* trailer?
   record :=
checksum: uint32// crc32c of type and data[]
length: uint16
type: uint8// One of FULL, FIRST, MIDDLE, LAST
data: uint8[length]

A record never starts within the last six bytes of a block (since it
won't fit).  Any leftover bytes here form the trailer, which must
consist entirely of zero bytes and must be skipped by readers.

Aside: if exactly seven bytes are left in the current block, and a new
non-zero length record is added, the writer must emit a FIRST record
(which contains zero bytes of user data) to fill up the trailing seven
bytes of the block and then emit all of the user data in subsequent
blocks.

More types may be added in the future.  Some Readers may skip record
types they do not understand, others may report that some data was
skipped.

FULL == 1
FIRST == 2
MIDDLE == 3
LAST == 4

The FULL record contains the contents of an entire user record.

FIRST, MIDDLE, LAST are types used for user records that have been
split into multiple fragments (typically because of block boundaries).
FIRST is the type of the first fragment of a user record, LAST is the
type of the last fragment of a user record, and MID is the type of all
interior fragments of a user record.

Example: consider a sequence of user records:
   A: length 1000
   B: length 97270
   C: length 8000
A will be stored as a FULL record in the first block.

B will be split into three fragments: first fragment occupies the rest
of the first block, second fragment occupies the entirety of the
second block, and the third fragment occupies a prefix of the third
block.  This will leave six bytes free in the third block, which will
be left empty as the trailer.

C will be stored as a FULL record in the fourth block.

===================

Some benefits over the recordio format:

(1) We do not need any heuristics for resyncing - just go to next
block boundary and scan.  If there is a corruption, skip to the next
block.  As a side-benefit, we do not get confused when part of the
contents of one log file are embedded as a record inside another log
file.

(2) Splitting at approximate boundaries (e.g., for mapreduce) is
simple: find the next block boundary and skip records until we
hit a FULL or FIRST record.

(3) We do not need extra buffering for large records.

Some downsides compared to recordio format:

(1) No packing of tiny records.  This could be fixed by adding a new
record type, so it is a shortcoming of the current implementation,
not necessarily the format.

(2) No compression.  Again, this could be fixed by adding new record types.
</pre>


</div>

</div>

<div id="outline-container-1-10-7-2" class="outline-5">
<h5 id="sec-1-10-7-2"><span class="section-number-5">1.10.7.2</span> LogWriter</h5>
<div class="outline-text-5" id="text-1-10-7-2">

<p>db/log_writer.h db log writer.这里我们需要结合前面的LogFormatter一起看看.
</p>


<pre class="src src-C++">class Writer {
 public:
  // Create a writer that will append data to <span style="color: #ffff00;">"*dest"</span>.
  // <span style="color: #ffff00;">"*dest"</span> must be initially empty.
  // <span style="color: #ffff00;">"*dest"</span> must remain live while this Writer is in use.
  explicit Writer(WritableFile* dest);
  ~Writer();

  Status AddRecord(const Slice&amp; slice);

 private:
  WritableFile* dest_;
  int block_offset_;       // Current offset in block.&#22312;&#24403;&#21069;block&#30340;&#20301;&#32622;.

  // crc32c values for all supported record types.  These are
  // pre-computed to reduce the overhead of computing the crc of the
  // record type stored in the header.
  uint32_t type_crc_[kMaxRecordType + 1]; // &#21508;&#31181;&#31867;&#22411;&#30340;crc32c.

  Status EmitPhysicalRecord(RecordType type, const char* ptr, size_t length);
};
</pre>



</div>

<div id="outline-container-1-10-7-2-1" class="outline-6">
<h6 id="sec-1-10-7-2-1"><span class="section-number-6">1.10.7.2.1</span> Writer</h6>
<div class="outline-text-6" id="text-1-10-7-2-1">




<pre class="src src-C++">Writer::Writer(WritableFile* dest)
    : dest_(dest),
      block_offset_(0) {
  for (int i = 0; i &lt;= kMaxRecordType; i++) {
    char t = static_cast&lt;char&gt;(i); // &#38024;&#23545;&#31867;&#22411;&#35745;&#31639;&#30340;CRC32C.
    type_crc_[i] = crc32c::Value(&amp;t, 1);
  }
}
</pre>


</div>

</div>

<div id="outline-container-1-10-7-2-2" class="outline-6">
<h6 id="sec-1-10-7-2-2"><span class="section-number-6">1.10.7.2.2</span> AddRecord</h6>
<div class="outline-text-6" id="text-1-10-7-2-2">

<p>我们这里看看每条Log到底是怎么写入的.
</p>


<pre class="src src-C++">Status Writer::AddRecord(const Slice&amp; slice) {
  const char* ptr = slice.data();
  size_t left = slice.size();

  // Fragment the record if necessary and emit it.  Note that if slice
  // is empty, we still want to iterate once to emit a single
  // zero-length record
  // &#23545;&#20110;Slice&#21097;&#20313;&#38271;&#24230;&#20026;0&#30340;&#35805;&#37027;&#20040;&#20381;&#28982;&#38656;&#35201;&#36755;&#20986;&#19968;&#26465;&#35760;&#24405;.
  Status s;
  bool begin = true; // &#24403;&#21069;&#20026;&#22836;&#37096;.
  do {
    const int leftover = kBlockSize - block_offset_; // &#24403;&#21069;block&#21097;&#20313;&#22810;&#23569;&#20869;&#23481;.
    assert(leftover &gt;= 0);
    if (leftover &lt; kHeaderSize) { // &#19981;&#36275;&#20197;&#23384;&#25918;&#19979;Header.
      // Switch to a new block
      if (leftover &gt; 0) {
        // Fill the trailer (literal below relies on kHeaderSize being 7)
        assert(kHeaderSize == 7);
        dest_-&gt;Append(Slice(<span style="color: #ffff00;">"\x00\x00\x00\x00\x00\x00"</span>, leftover)); // &#21097;&#20313;&#30340;&#37096;&#20998;&#22635;&#20805;0x00.
      }
      block_offset_ = 0; // &#29616;&#22312;blcok_offset==0&#37325;&#26032;&#24320;&#36767;&#20102;&#19968;&#22359;&#20869;&#23481;.
    }

    // Invariant: we never leave &lt; kHeaderSize bytes in a block.
    assert(kBlockSize - block_offset_ - kHeaderSize &gt;= 0);

    // &#24403;&#21069;&#21097;&#20313;&#22810;&#23569;&#20869;&#23481;.
    const size_t avail = kBlockSize - block_offset_ - kHeaderSize;
    const size_t fragment_length = (left &lt; avail) ? left : avail;

    RecordType type;
    const bool end = (left == fragment_length); // &#36825;&#20010;&#26159;&#21542;&#20026;&#35760;&#24405;&#30340;&#23614;&#37096;.
    if (begin &amp;&amp; end) { // &#22914;&#26524;&#23436;&#20840;&#35760;&#24405;&#37027;&#20040;FullType.
      type = kFullType;
    } else if (begin) { // &#22914;&#26524;&#21482;&#26159;&#24320;&#22836;,FirstType.
      type = kFirstType;
    } else if (end) { // &#22914;&#26524;&#19981;&#26159;&#24320;&#22836;&#20294;&#26159;&#32467;&#23614;LastType.
      type = kLastType;
    } else {
      type = kMiddleType; // &#21542;&#21017;MiddleType.
    }

    s = EmitPhysicalRecord(type, ptr, fragment_length); // &#23558;&#36825;&#20010;&#37096;&#20998;&#36755;&#20986;.
    ptr += fragment_length;
    left -= fragment_length;
    begin = false;
  } while (s.ok() &amp;&amp; left &gt; 0);
  return s;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-7-2-3" class="outline-6">
<h6 id="sec-1-10-7-2-3"><span class="section-number-6">1.10.7.2.3</span> EmitPhysicalRecord</h6>
<div class="outline-text-6" id="text-1-10-7-2-3">

<p>我们在上面AddRecord里面看到了调用EmitPhysicalRecord.我们这里看看实现.参考在LogFormatter里面的注释.
</p>


<pre class="src src-C++">Status Writer::EmitPhysicalRecord(RecordType t, const char* ptr, size_t n) {
  assert(n &lt;= 0xffff);  // Must fit in two bytes
  assert(block_offset_ + kHeaderSize + n &lt;= kBlockSize);

  // Format the header
  char buf[kHeaderSize];
  // &#36825;&#37324;&#23384;&#22312;&#24046;&#21035;&#65292;&#26368;&#21518;&#19968;&#20010;&#23383;&#33410;&#34920;&#31034;type.
  buf[4] = static_cast&lt;char&gt;(n &amp; 0xff); // &#20302;&#20301;.
  buf[5] = static_cast&lt;char&gt;(n &gt;&gt; 8); // &#39640;&#20301;.&#36825;&#26679;&#21487;&#20197;&#23567;&#31471;&#26041;&#24335;&#35835;&#21462;.
  buf[6] = static_cast&lt;char&gt;(t);

  // Compute the crc of the record type and the payload.
  uint32_t crc = crc32c::Extend(type_crc_[t], ptr, n); // &#38024;&#23545;ptr&#36827;&#34892;CRC32&#21152;&#23494;.
  crc = crc32c::Mask(crc);                 // Adjust for storage
  EncodeFixed32(buf, crc); // &#23384;&#25918;&#22312;header&#37096;&#20998;.

  // Write the header and the payload
  Status s = dest_-&gt;Append(Slice(buf, kHeaderSize)); // &#39318;&#20808;&#20889;&#20837;Header&#37096;&#20998;.
  if (s.ok()) {
    s = dest_-&gt;Append(Slice(ptr, n)); // &#28982;&#21518;&#36861;&#21152;&#25968;&#25454;&#37096;&#20998;.
    if (s.ok()) {
      s = dest_-&gt;Flush();
    }
  }
  block_offset_ += kHeaderSize + n;
  return s;
}
</pre>


</div>
</div>

</div>

<div id="outline-container-1-10-7-3" class="outline-5">
<h5 id="sec-1-10-7-3"><span class="section-number-5">1.10.7.3</span> LogReader</h5>
<div class="outline-text-5" id="text-1-10-7-3">

<p>db/log_reader.h db log reader.这里我们需要结合前面的LogReader以及LogFormatter一起看看.
</p>


<pre class="src src-C++">class Reader {
 public:
  // Interface for reporting errors.
  // &#27719;&#25253;&#38169;&#35823;&#25509;&#21475;.
  class Reporter {
   public:
    virtual ~Reporter();

    // Some corruption was detected.  <span style="color: #ffff00;">"size"</span> is the approximate number
    // of bytes dropped due to the corruption.
    virtual void Corruption(size_t bytes, const Status&amp; status) = 0;
  };

  // Create a reader that will return log records from <span style="color: #ffff00;">"*file"</span>.
  // <span style="color: #ffff00;">"*file"</span> must remain live while this Reader is in use.
  //
  // If <span style="color: #ffff00;">"reporter"</span> is non-NULL, it is notified whenever some data is
  // dropped due to a detected corruption.  <span style="color: #ffff00;">"*reporter"</span> must remain
  // live while this Reader is in use.
  //
  // If <span style="color: #ffff00;">"checksum"</span> is true, verify checksums if available.
  //
  // The Reader will start reading at the first record located at physical
  // position &gt;= initial_offset within the file.
  Reader(SequentialFile* file, Reporter* reporter, bool checksum,
         uint64_t initial_offset);

  ~Reader();

  // Read the next record into *record.  Returns true if read
  // successfully, false if we hit end of the input.  May use
  // <span style="color: #ffff00;">"*scratch"</span> as temporary storage.  The contents filled in *record
  // will only be valid until the next mutating operation on this
  // reader or the next mutation to *scratch.
  bool ReadRecord(Slice* record, std::string* scratch);

  // Returns the physical offset of the last record returned by ReadRecord.
  //
  // Undefined before the first call to ReadRecord.
  uint64_t LastRecordOffset();

 private:
  SequentialFile* const file_; // &#39034;&#24207;&#35835;&#21462;&#25991;&#20214;&#23545;&#35937;.
  Reporter* const reporter_; // &#25253;&#21578;&#38169;&#35823;&#23545;&#35937;.
  bool const checksum_; // &#26816;&#26597;CRC32C.
  char* const backing_store_; // block buffer.
  Slice buffer_; // record buffer.
  // &#34920;&#31034;&#19978;&#27425;&#35835;&#21462;block&#26159;&#21542;&#21040;&#36798;&#23614;&#37096;.
  bool eof_;   // Last Read() indicated EOF by returning &lt; kBlockSize

  // Offset of the last record returned by ReadRecord.
  uint64_t last_record_offset_; // &#19978;&#27425;ReadRecord&#23436;&#25104;&#20043;&#21518;&#30340;&#25991;&#20214;&#20559;&#31227;.
  // Offset of the first location past the end of buffer_.
  uint64_t end_of_buffer_offset_; // &#35835;&#21462;&#21040;buffer_&#20043;&#21518;&#39034;&#24207;&#25991;&#20214;&#20559;&#31227;.

  // Offset at which to start looking for the first record to return
  uint64_t const initial_offset_; // &#21021;&#22987;&#21270;&#35835;&#21462;&#30340;offset.

  // Extend record types with the following special values
  enum {
    kEof = kMaxRecordType + 1,
    // Returned whenever we find an invalid physical record.
    // Currently there are three situations in which this happens:
    // * The record has an invalid CRC (ReadPhysicalRecord reports a drop)
    // * The record is a 0-length record (No drop is reported)
    // * The record is below constructor's initial_offset (No drop is reported)
    kBadRecord = kMaxRecordType + 2
  };

  // Skips all blocks that are completely before <span style="color: #ffff00;">"initial_offset_"</span>.
  //
  // Returns true on success. Handles reporting.
  bool SkipToInitialBlock();

  // Return type, or one of the preceding special values
  unsigned int ReadPhysicalRecord(Slice* result);

  // Reports dropped bytes to the reporter.
  // buffer_ must be updated to remove the dropped bytes prior to invocation.
  void ReportCorruption(size_t bytes, const char* reason);
  void ReportDrop(size_t bytes, const Status&amp; reason);
};
</pre>



</div>

<div id="outline-container-1-10-7-3-1" class="outline-6">
<h6 id="sec-1-10-7-3-1"><span class="section-number-6">1.10.7.3.1</span> Reader</h6>
<div class="outline-text-6" id="text-1-10-7-3-1">

<p>构造函数非常简单，注意这里开辟的backing_store_，可以猜想到这个backing_store是读取block内容临时开辟.
对于这些字段的含义可能第一眼看上去不太明白，这个分析代码应该可以看到每个字段的含义。
</p>


<pre class="src src-C++">Reader::Reader(SequentialFile* file, Reporter* reporter, bool checksum,
               uint64_t initial_offset)
    : file_(file),
      reporter_(reporter),
      checksum_(checksum),
      backing_store_(new char[kBlockSize]),
      buffer_(),
      eof_(false),
      last_record_offset_(0),
      end_of_buffer_offset_(0),
      initial_offset_(initial_offset) {
}
</pre>


</div>

</div>

<div id="outline-container-1-10-7-3-2" class="outline-6">
<h6 id="sec-1-10-7-3-2"><span class="section-number-6">1.10.7.3.2</span> ReadPhysicalRecord</h6>
<div class="outline-text-6" id="text-1-10-7-3-2">

<p>从文件里面读取一个物理块大小出来kBlockSize.并且解析内容存放在bakcing_store_里面，同时返回type.
这里很多细节都没有仔细看,只是理解大致的意思.
</p>


<pre class="src src-C++">unsigned int Reader::ReadPhysicalRecord(Slice* result) {
  while (true) {
    if (buffer_.size() &lt; kHeaderSize) { // &#22914;&#26524;&#20043;&#21069;&#35835;&#21462;&#30340;&#20869;&#23481;&#19981;&#22815;kHeaderSize&#22823;&#23567;&#30340;&#35805;.
      if (!eof_) { // &#22914;&#26524;&#19978;&#27425;&#35835;&#21462;&#27809;&#26377;&#21040;&#26411;&#23614;&#30340;&#35805;&#65292;&#37027;&#20040;&#35748;&#20026;&#19978;&#27425;&#35835;&#21462;&#26080;&#25928;&#65292;&#30452;&#25509;&#24573;&#30053;.
        // Last read was a full read, so this is a trailer to skip
        buffer_.clear();
        // &#24573;&#30053;&#20043;&#21518;&#37325;&#26032;&#35835;&#21462;&#19968;&#22359;.
        Status status = file_-&gt;Read(kBlockSize, &amp;buffer_, backing_store_);
        // &#20462;&#27491;&#35835;&#21462;&#20559;&#31227;.&#24403;&#21069;&#35835;&#21462;&#20559;&#31227;.
        end_of_buffer_offset_ += buffer_.size();
        if (!status.ok()) { // &#22914;&#26524;&#35835;&#21462;&#22833;&#36133;&#30340;&#35805;.
          buffer_.clear();
          ReportDrop(kBlockSize, status);
          eof_ = true;
          return kEof;
        } else if (buffer_.size() &lt; kBlockSize) {
          // &#25104;&#21151;&#20294;&#26159;&#24050;&#32463;&#36798;&#21040;&#32467;&#23614;&#20102;.eof_=true
          // &#37325;&#26032;&#21028;&#26029;&#35835;&#21462;&#30340;&#26159;&#21542;&#20026;&#27491;&#30830;&#30340;&#35760;&#24405;.
          // &#22914;&#26524;&#27809;&#26377;&#27491;&#30830;&#35835;&#21462;&#30340;&#35805;(&lt;kHeaderSize).&#20250;&#36827;&#20837;&#19979;&#38754;&#37027;&#20010;&#38169;&#35823;&#36923;&#36753;.
          // &#21542;&#21017;&#36827;&#20837;&#27491;&#24120;&#36923;&#36753;.
          eof_ = true;
        }
        continue;
      } else if (buffer_.size() == 0) { // &#36825;&#20010;&#26159;&#30830;&#23454;&#27809;&#26377;&#20219;&#20309;&#35760;&#24405;&#23384;&#22312;&#20102;.
        // End of file
        return kEof;
      } else { // &#25991;&#20214;&#26411;&#23614;&#35835;&#21462;&#22833;&#36133;(&#25130;&#26029;)
        size_t drop_size = buffer_.size();
        buffer_.clear();
        ReportCorruption(drop_size, <span style="color: #ffff00;">"truncated record at end of file"</span>);
        return kEof;
      }
    }

    // &#20551;&#35774;&#21040;&#36825;&#37324;&#30340;&#35805;&#25105;&#20204;&#37117;&#24050;&#32463;&#35835;&#21462;&#20102;&#19968;&#20010;&#23436;&#25972;&#30340;block&#20102;.&#25105;&#20204;&#39318;&#20808;&#35299;&#26512;&#22836;&#37096;.
    // Parse the header
    const char* header = buffer_.data();
    const uint32_t a = static_cast&lt;uint32_t&gt;(header[4]) &amp; 0xff;
    const uint32_t b = static_cast&lt;uint32_t&gt;(header[5]) &amp; 0xff;
    const unsigned int type = header[6]; // &#26681;&#25454;&#31867;&#22411;&#21644;&#38271;&#24230;.
    const uint32_t length = a | (b &lt;&lt; 8);
    if (kHeaderSize + length &gt; buffer_.size()) {
      size_t drop_size = buffer_.size();
      buffer_.clear();
      ReportCorruption(drop_size, <span style="color: #ffff00;">"bad record length"</span>);
      return kBadRecord;
    }

    if (type == kZeroType &amp;&amp; length == 0) {
      // Skip zero length record without reporting any drops since
      // such records are produced by the mmap based writing code in
      // env_posix.cc that preallocates file regions.
      buffer_.clear();
      return kBadRecord;
    }

    // &#26816;&#26597;crc&#26657;&#39564;.
    // Check crc
    if (checksum_) {
      uint32_t expected_crc = crc32c::Unmask(DecodeFixed32(header));
      uint32_t actual_crc = crc32c::Value(header + 6, 1 + length); // &#20570;crc32c&#38656;&#35201;&#21253;&#21547;type&#23383;&#27573;.
      if (actual_crc != expected_crc) {
        // Drop the rest of the buffer since <span style="color: #ffff00;">"length"</span> itself may have
        // been corrupted and if we trust it, we could find some
        // fragment of a real log record that just happens to look
        // like a valid log record.
        size_t drop_size = buffer_.size();
        buffer_.clear();
        ReportCorruption(drop_size, <span style="color: #ffff00;">"checksum mismatch"</span>);
        return kBadRecord;
      }
    }

    // &#23545;buffer_&#36825;&#37324;&#20570;&#19968;&#20010;&#26657;&#39564;.
    buffer_.remove_prefix(kHeaderSize + length);

    // Skip physical record that started before initial_offset_
    if (end_of_buffer_offset_ - buffer_.size() - kHeaderSize - length &lt;
        initial_offset_) {
      result-&gt;clear();
      return kBadRecord;
    }

    *result = Slice(header + kHeaderSize, length);
    return type;
  }
}
</pre>


</div>

</div>

<div id="outline-container-1-10-7-3-3" class="outline-6">
<h6 id="sec-1-10-7-3-3"><span class="section-number-6">1.10.7.3.3</span> ReadRecord</h6>
<div class="outline-text-6" id="text-1-10-7-3-3">

<p>ReadRecord读取的是一条逻辑记录.底层调用ReadPhysicalRecord将多条物理记录结合起来.实话说里面具体逻辑没有看懂，
但是大致意思算是明白了。对于FullType来说的话record里面使用backing_store内存，而对于First/Middle/Last来说的话
里面使用的是scratch分配的内存.
</p>


<pre class="src src-C++">bool Reader::ReadRecord(Slice* record, std::string* scratch) {
  // &#22914;&#26524;&#36824;&#27809;&#26377;&#36339;&#36807;initial offset&#30340;&#35805;
  if (last_record_offset_ &lt; initial_offset_) {
    if (!SkipToInitialBlock()) { // &#36825;&#20010;&#20989;&#25968;&#21518;&#38754;&#20250;&#20998;&#26512;.
      return false;
    }
  }

  scratch-&gt;clear(); // &#23558;scratch&#20197;&#21450;record&#28165;&#31354;
  record-&gt;clear(); // &#22914;&#26524;&#27809;&#26377;&#29468;&#38169;&#30340;&#35805;&#65292;&#37027;&#20040;record&#37324;&#38754;&#31649;&#29702;&#30340;&#26159;scratch&#30340;&#20869;&#23384;.
  // &#20294;&#26159;&#20043;&#21518;&#20250;&#21457;&#29616;&#20854;&#23454;record&#37324;&#38754;&#20063;&#21487;&#33021;&#21547;&#26377;backing_store&#30340;&#20869;&#23481;.
  bool in_fragmented_record = false;
  // Record offset of the logical record that we're reading
  // 0 is a dummy value to make compilers happy
  uint64_t prospective_record_offset = 0;

  Slice fragment;
  while (true) {
    uint64_t physical_record_offset = end_of_buffer_offset_ - buffer_.size();
    const unsigned int record_type = ReadPhysicalRecord(&amp;fragment); // &#35835;&#21462;&#19968;&#20010;block.
    switch (record_type) {
      case kFullType:
        if (in_fragmented_record) {
          // Handle bug in earlier versions of log::Writer where
          // it could emit an empty kFirstType record at the tail end
          // of a block followed by a kFullType or kFirstType record
          // at the beginning of the next block.
          if (scratch-&gt;empty()) {
            in_fragmented_record = false; // &#24573;&#30053;&#36825;&#31181;&#38169;&#35823;.&#21487;&#33021;&#26159;&#32771;&#34385;&#20860;&#23481;.
          } else { // &#35835;&#21462;&#21040;FullType&#20294;&#26159;&#21364;&#26377;fragmented&#30340;&#34920;&#31034;.
            ReportCorruption(scratch-&gt;size(), <span style="color: #ffff00;">"partial record without end(1)"</span>);
          }
        }
        prospective_record_offset = physical_record_offset;
        scratch-&gt;clear();
        *record = fragment; // &#30452;&#25509;&#32473;record.&#36825;&#37324;record&#25345;&#26377;backing_store&#25968;&#25454;.
        last_record_offset_ = prospective_record_offset;
        return true;

      case kFirstType:
        if (in_fragmented_record) {
          // Handle bug in earlier versions of log::Writer where
          // it could emit an empty kFirstType record at the tail end
          // of a block followed by a kFullType or kFirstType record
          // at the beginning of the next block.
          if (scratch-&gt;empty()) {
            in_fragmented_record = false; // &#24573;&#30053;&#36825;&#31181;&#38169;&#35823;,&#21487;&#33021;&#26159;&#32771;&#34385;&#20860;&#23481;.
          } else {
            ReportCorruption(scratch-&gt;size(), <span style="color: #ffff00;">"partial record without end(2)"</span>);
          }
        }
        prospective_record_offset = physical_record_offset;
        scratch-&gt;assign(fragment.data(), fragment.size());
        in_fragmented_record = true;
        break;

      case kMiddleType:
        if (!in_fragmented_record) {
          ReportCorruption(fragment.size(),
                           <span style="color: #ffff00;">"missing start of fragmented record(1)"</span>);
        } else {
          scratch-&gt;append(fragment.data(), fragment.size());
        }
        break;

      case kLastType:
        if (!in_fragmented_record) {
          ReportCorruption(fragment.size(),
                           <span style="color: #ffff00;">"missing start of fragmented record(2)"</span>);
        } else {
          scratch-&gt;append(fragment.data(), fragment.size());
          *record = Slice(*scratch);
          last_record_offset_ = prospective_record_offset;
          return true;
        }
        break;

      case kEof:
        if (in_fragmented_record) {
          ReportCorruption(scratch-&gt;size(), <span style="color: #ffff00;">"partial record without end(3)"</span>);
          scratch-&gt;clear();
        }
        return false;

      case kBadRecord:
        if (in_fragmented_record) {
          ReportCorruption(scratch-&gt;size(), <span style="color: #ffff00;">"error in middle of record"</span>);
          in_fragmented_record = false;
          scratch-&gt;clear();
        }
        break;

      default: {
        char buf[40];
        snprintf(buf, sizeof(buf), <span style="color: #ffff00;">"unknown record type %u"</span>, record_type);
        ReportCorruption(
            (fragment.size() + (in_fragmented_record ? scratch-&gt;size() : 0)),
            buf);
        in_fragmented_record = false;
        scratch-&gt;clear();
        break;
      }
    }
  }
  return false;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-7-3-4" class="outline-6">
<h6 id="sec-1-10-7-3-4"><span class="section-number-6">1.10.7.3.4</span> SkipToInitialBlock</h6>
<div class="outline-text-6" id="text-1-10-7-3-4">

<p>跳过开头的部分.实际上只是跳过按照kBlockSize整数块部分。这个部分不需要用户主动调用.在ReadRecord里面调用.
</p>


<pre class="src src-C++">bool Reader::SkipToInitialBlock() {
  size_t offset_in_block = initial_offset_ % kBlockSize;
  uint64_t block_start_location = initial_offset_ - offset_in_block;

  // Don't search a block if we'd be in the trailer
  if (offset_in_block &gt; kBlockSize - 6) { // &#36825;&#20010;&#19981;&#22826;&#26126;&#30333;&#26159;&#20160;&#20040;&#24847;&#24605;.&#20026;&#20160;&#20040;&#26159;6.
    offset_in_block = 0;
    block_start_location += kBlockSize;
  }

  end_of_buffer_offset_ = block_start_location;

  // Skip to start of first block that can contain the initial record
  if (block_start_location &gt; 0) {
    Status skip_status = file_-&gt;Skip(block_start_location);
    if (!skip_status.ok()) {
      ReportDrop(block_start_location, skip_status); // &#21518;&#38754;&#20250;&#20998;&#26512;.
      return false;
    }
  }

  return true;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-7-3-5" class="outline-6">
<h6 id="sec-1-10-7-3-5"><span class="section-number-6">1.10.7.3.5</span> ReportDrop</h6>
<div class="outline-text-6" id="text-1-10-7-3-5">




<pre class="src src-C++">void Reader::ReportDrop(size_t bytes, const Status&amp; reason) {
  if (reporter_ != NULL &amp;&amp;
      end_of_buffer_offset_ - buffer_.size() - bytes &gt;= initial_offset_) { // &#23545;&#20110;&#21518;&#38754;&#36825;&#20010;&#26465;&#20214;&#27809;&#26377;&#30475;&#25026;
    // &#24212;&#35813;&#26159;&#21028;&#26029;&#22914;&#26524;&#36824;&#27809;&#26377;&#24320;&#22987;&#35835;&#30340;&#35805;&#37027;&#20040;&#19981;&#20250;&#25253;&#21578;&#38169;&#35823;.
    reporter_-&gt;Corruption(bytes, reason);
  }
}
</pre>


</div>

</div>

<div id="outline-container-1-10-7-3-6" class="outline-6">
<h6 id="sec-1-10-7-3-6"><span class="section-number-6">1.10.7.3.6</span> ReportCorruption</h6>
<div class="outline-text-6" id="text-1-10-7-3-6">

<p>这个过程非常简单就是调用ReportDrop.然后使用Status::Corruption封装.
</p>


<pre class="src src-C++">void Reader::ReportCorruption(size_t bytes, const char* reason) {
  ReportDrop(bytes, Status::Corruption(reason));
}
</pre>


</div>

</div>

<div id="outline-container-1-10-7-3-7" class="outline-6">
<h6 id="sec-1-10-7-3-7"><span class="section-number-6">1.10.7.3.7</span> LastRecordOffset</h6>
<div class="outline-text-6" id="text-1-10-7-3-7">

<p>上次调用ReadRecord之后的文件偏移是多少
</p>


<pre class="src src-C++">uint64_t Reader::LastRecordOffset() {
  return last_record_offset_;
}
</pre>


</div>
</div>
</div>

</div>

<div id="outline-container-1-10-8" class="outline-4">
<h4 id="sec-1-10-8"><span class="section-number-4">1.10.8</span> Table</h4>
<div class="outline-text-4" id="text-1-10-8">


</div>

<div id="outline-container-1-10-8-1" class="outline-5">
<h5 id="sec-1-10-8-1"><span class="section-number-5">1.10.8.1</span> TableFormat</h5>
<div class="outline-text-5" id="text-1-10-8-1">

<p>我们在分析后面的接口之前最好首先看看table文件的组织格式是怎么样的。这些table都是排好序的所以查询特别快。
对于这些table通常称为sstable(sorted string table).关于table格式在leveldb/doc/table_format.txt里面有说明.
本质上我们可认为sstable是一个二级索引文件.首先读取footer.得到metaindex block和index block位置.然后读取index block
或者是metaindex block(上面存在排序k进行二分查找)，然后读取data block(k排序然后进行二分查找).
</p>


<pre class="example">File format
===========

  &lt;beginning_of_file&gt;
  [data block 1]
  [data block 2]
  ...
  [data block N]
  [meta block 1]
  ...
  [meta block K]
  [metaindex block]
  [index block]
  [Footer]        (fixed size; starts at file_size - sizeof(Footer))
  &lt;end_of_file&gt;

The file contains internal pointers.  Each such pointer is called
a BlockHandle and contains the following information:
offset:    varint64
size:    varint64

(1) The sequence of key/value pairs in the file are stored in sorted
order and partitioned into a sequence of data blocks.  These blocks
come one after another at the beginning of the file.  Each data block
is formatted according to the code in block_builder.cc, and then
optionally compressed.

(2) After the data blocks we store a bunch of meta blocks.  The
supported meta block types are described below.  More meta block types
may be added in the future.  Each meta block is again formatted using
block_builder.cc and then optionally compressed.

(3) A "metaindex" block.  It contains one entry for every other meta
block where the key is the name of the meta block and the value is a
BlockHandle pointing to that meta block.

(4) An "index" block.  This block contains one entry per data block,
where the key is a string &gt;= last key in that data block and before
the first key in the successive data block.  The value is the
BlockHandle for the data block.

(6) At the very end of the file is a fixed length footer that contains
the BlockHandle of the metaindex and index blocks as well as a magic number.
       metaindex_handle:       char[p];    // Block handle for metaindex
index_handle:       char[q];    // Block handle for index
padding:       char[40-p-q]; // 0 bytes to make fixed length
       // (40==2*BlockHandle::kMaxEncodedLength)
magic:       fixed64;    // == 0xdb4775248b80fb57

"stats" Meta Block
------------------

This meta block contains a bunch of stats.  The key is the name
of the statistic.  The value contains the statistic.
TODO(postrelease): record following stats.
  data size
  index size
  key size (uncompressed)
  value size (uncompressed)
  number of entries
  number of data blocks
</pre>


</div>

</div>

<div id="outline-container-1-10-8-2" class="outline-5">
<h5 id="sec-1-10-8-2"><span class="section-number-5">1.10.8.2</span> BuildTable</h5>
<div class="outline-text-5" id="text-1-10-8-2">

<p>db/builder.h BuildTable过程非常简单就是构造一个sstable.
</p>


<pre class="src src-C++">Status BuildTable(const std::string&amp; dbname,
                  Env* env,
                  const Options&amp; options,
                  TableCache* table_cache,
                  Iterator* iter,
                  FileMetaData* meta) {
  Status s;
  meta-&gt;file_size = 0;
  iter-&gt;SeekToFirst();

  std::string fname = TableFileName(dbname, meta-&gt;number); // &#27880;&#24847;number&#36825;&#20010;&#23383;&#27573;&#21547;&#20041;.
  if (iter-&gt;Valid()) {
    WritableFile* file;
    s = env-&gt;NewWritableFile(fname, &amp;file); // &#21019;&#24314;&#26032;&#30340;&#25991;&#20214;.
    if (!s.ok()) {
      return s;
    }

    TableBuilder* builder = new TableBuilder(options, file);
    meta-&gt;smallest.DecodeFrom(iter-&gt;key()); // &#36941;&#21382;iter&#37324;&#38754;&#30340;&#23545;&#35937;.&#36825;&#37324;&#20250;&#35760;&#24405;
    // &#26368;&#23567;&#21644;&#26368;&#22823;&#30340;key&#35760;&#24405;&#22312;meta&#37324;&#38754;.
    for (; iter-&gt;Valid(); iter-&gt;Next()) {
      Slice key = iter-&gt;key();
      meta-&gt;largest.DecodeFrom(key);
      builder-&gt;Add(key, iter-&gt;value());
    }

    // Finish and check for builder errors
    if (s.ok()) {
      s = builder-&gt;Finish(); // &#20889;&#20837;index&#20197;&#21450;footer&#37096;&#20998;.
      if (s.ok()) {
        meta-&gt;file_size = builder-&gt;FileSize();
        assert(meta-&gt;file_size &gt; 0);
      }
    } else {
      builder-&gt;Abandon();
    }
    delete builder;

    // Finish and check for file errors
    if (s.ok()) {
      s = file-&gt;Sync();
    }
    if (s.ok()) {
      s = file-&gt;Close();
    }
    delete file;
    file = NULL;

    // &#20250;&#23558;&#36825;&#20010;sstable&#21152;&#20837;&#21040;TableCache&#37324;&#38754;.
    if (s.ok()) {
      // Verify that the table is usable
      Iterator* it = table_cache-&gt;NewIterator(ReadOptions(),
                                              meta-&gt;number,
                                              meta-&gt;file_size);
      s = it-&gt;status();
      delete it;
    }
  }

  // Check for input iterator errors
  if (!iter-&gt;status().ok()) {
    s = iter-&gt;status();
  }

  if (s.ok() &amp;&amp; meta-&gt;file_size &gt; 0) {
    // Keep it
  } else {
    env-&gt;DeleteFile(fname);
  }
  return s;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-8-3" class="outline-5">
<h5 id="sec-1-10-8-3"><span class="section-number-5">1.10.8.3</span> TableCache</h5>
<div class="outline-text-5" id="text-1-10-8-3">

<p>db/table_cache.cc TableCache的工作非常简单，就是针对Table对象以及Table::Iterator对象进行cache.
这样底层的话可以防止过多的文件打开。了解这个功能之后代码就非常好阅读了。我们首先看看TableCache结构.
对于Cache的key使用uint64_t file_number来进行标记.
</p>


<pre class="src src-C++">class TableCache {
 public:
  TableCache(const std::string&amp; dbname, const Options* options, int entries);
  ~TableCache();

  // Return an iterator for the specified file number (the corresponding
  // file length must be exactly <span style="color: #ffff00;">"file_size"</span> bytes).  If <span style="color: #ffff00;">"tableptr"</span> is
  // non-NULL, also sets <span style="color: #ffff00;">"*tableptr"</span> to point to the Table object
  // underlying the returned iterator, or NULL if no Table object underlies
  // the returned iterator.  The returned <span style="color: #ffff00;">"*tableptr"</span> object is owned by
  // the cache and should not be deleted, and is valid for as long as the
  // returned iterator is live.
  Iterator* NewIterator(const ReadOptions&amp; options,
                        uint64_t file_number,
                        uint64_t file_size,
                        Table** tableptr = NULL);

  // Evict any entry for the specified file number
  void Evict(uint64_t file_number);

 private:
  Env* const env_; // &#24213;&#23618;env
  const std::string dbname_; // &#25171;&#24320;db&#21517;&#31216;.
  const Options* options_; // &#25171;&#24320;options.
  Cache* cache_; // Cache&#23545;&#35937;.
};
</pre>



</div>

<div id="outline-container-1-10-8-3-1" class="outline-6">
<h6 id="sec-1-10-8-3-1"><span class="section-number-6">1.10.8.3.1</span> TableCache</h6>
<div class="outline-text-6" id="text-1-10-8-3-1">




<pre class="src src-C++">TableCache::TableCache(const std::string&amp; dbname,
                       const Options* options,
                       int entries)
    : env_(options-&gt;env),
      dbname_(dbname),
      options_(options),
      // entries&#34920;&#31034;Cache&#30340;capacity.
      cache_(NewLRUCache(entries)) {
}

TableCache::~TableCache() {
  delete cache_;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-8-3-2" class="outline-6">
<h6 id="sec-1-10-8-3-2"><span class="section-number-6">1.10.8.3.2</span> Evict</h6>
<div class="outline-text-6" id="text-1-10-8-3-2">




<pre class="src src-C++">void TableCache::Evict(uint64_t file_number) {
  char buf[sizeof(file_number)];
  EncodeFixed64(buf, file_number);
  cache_-&gt;Erase(Slice(buf, sizeof(buf)));
}
</pre>


</div>

</div>

<div id="outline-container-1-10-8-3-3" class="outline-6">
<h6 id="sec-1-10-8-3-3"><span class="section-number-6">1.10.8.3.3</span> NewIterator</h6>
<div class="outline-text-6" id="text-1-10-8-3-3">




<pre class="src src-C++">struct TableAndFile {
  RandomAccessFile* file; // &#23558;file&#21644;table&#32465;&#23450;.
  Table* table;
};

static void DeleteEntry(const Slice&amp; key, void* value) {
  TableAndFile* tf = reinterpret_cast&lt;TableAndFile*&gt;(value);
  delete tf-&gt;table;
  delete tf-&gt;file;
  delete tf;
}

static void UnrefEntry(void* arg1, void* arg2) {
  Cache* cache = reinterpret_cast&lt;Cache*&gt;(arg1);
  Cache::Handle* h = reinterpret_cast&lt;Cache::Handle*&gt;(arg2);
  cache-&gt;Release(h);
}

Iterator* TableCache::NewIterator(const ReadOptions&amp; options,
                                  uint64_t file_number,
                                  uint64_t file_size,
                                  Table** tableptr) {
  if (tableptr != NULL) {
    *tableptr = NULL;
  }

  char buf[sizeof(file_number)];
  EncodeFixed64(buf, file_number); // &#26681;&#25454;file_number&#20316;&#20026;key&#26597;&#35810;.
  Slice key(buf, sizeof(buf));
  Cache::Handle* handle = cache_-&gt;Lookup(key); // &#39318;&#20808;&#22312;cache&#37324;&#38754;&#26597;&#25214;.
  if (handle == NULL) {
    std::string fname = TableFileName(dbname_, file_number);
    RandomAccessFile* file = NULL;
    Table* table = NULL;
    Status s = env_-&gt;NewRandomAccessFile(fname, &amp;file);
    if (s.ok()) {
      s = Table::Open(*options_, file, file_size, &amp;table);
    }

    if (!s.ok()) {
      assert(table == NULL);
      delete file;
      // We do not cache error results so that if the error is transient,
      // or somebody repairs the file, we recover automatically.
      return NewErrorIterator(s);
    }
    // &#21019;&#24314;&#19968;&#20010;cache item
    // &#27880;&#24847;&#36825;&#37324;charge=1&#37027;&#20040;capacity&#23601;&#34920;&#31034;&#20010;&#25968;.
    TableAndFile* tf = new TableAndFile;
    tf-&gt;file = file;
    tf-&gt;table = table;
    handle = cache_-&gt;Insert(key, tf, 1, &amp;DeleteEntry);
  }

  Table* table = reinterpret_cast&lt;TableAndFile*&gt;(cache_-&gt;Value(handle))-&gt;table;
  Iterator* result = table-&gt;NewIterator(options);
  // &#36825;&#37324;cleanup&#20989;&#25968;&#26159;&#20943;&#23569;&#24341;&#29992;&#35745;&#25968;.
  result-&gt;RegisterCleanup(&amp;UnrefEntry, cache_, handle);
  if (tableptr != NULL) {
    *tableptr = table;
  }
  return result;
}
</pre>


</div>
</div>

</div>

<div id="outline-container-1-10-8-4" class="outline-5">
<h5 id="sec-1-10-8-4"><span class="section-number-5">1.10.8.4</span> Table</h5>
<div class="outline-text-5" id="text-1-10-8-4">

<p>table/table.cc 这个接口在include/leveldb/table.h里面已经给出了.我们这里就是看看具体实现.
</p>

</div>

<div id="outline-container-1-10-8-4-1" class="outline-6">
<h6 id="sec-1-10-8-4-1"><span class="section-number-6">1.10.8.4.1</span> Rep</h6>
<div class="outline-text-6" id="text-1-10-8-4-1">

<p>Rep是Table内部的数据结构.这样实现了之后那么头文件里面可以不包含任何实现了.
</p>


<pre class="src src-C++">struct Table::Rep {
  ~Rep() {
    delete index_block;
  }

  Options options;
  Status status;
  RandomAccessFile* file;
  uint64_t cache_id; // TODO(dirlt):&#22312;BlockReader&#37324;&#38754;&#20316;&#20026;cache key&#30340;&#19968;&#37096;&#20998;&#23384;&#22312;.
  // &#38382;&#39064;&#26159;&#36825;&#20010;cache_id&#20027;&#35201;&#26159;&#29992;&#26469;&#35299;&#20915;&#20160;&#20040;&#38382;&#39064;&#30340;&#21602;?

  BlockHandle metaindex_handle;  // Handle to metaindex_block: saved from footer
  Block* index_block; // &#20445;&#23384;data index&#30340;block.
};
</pre>


</div>

</div>

<div id="outline-container-1-10-8-4-2" class="outline-6">
<h6 id="sec-1-10-8-4-2"><span class="section-number-6">1.10.8.4.2</span> Open</h6>
<div class="outline-text-6" id="text-1-10-8-4-2">




<pre class="src src-C++">Status Table::Open(const Options&amp; options,
                   RandomAccessFile* file,
                   uint64_t size,
                   Table** table) {
  *table = NULL;
  if (size &lt; Footer::kEncodedLength) { // &#23545;&#20110;&#25991;&#20214;&#22823;&#23567;&#32943;&#23450;&#38656;&#35201;&#19968;&#20010;footer&#23545;&#35937;.
    return Status::InvalidArgument(<span style="color: #ffff00;">"file is too short to be an sstable"</span>);
  }

  char footer_space[Footer::kEncodedLength]; // footer&#31354;&#38388;.
  Slice footer_input; // &#35835;&#21462;footer.
  Status s = file-&gt;Read(size - Footer::kEncodedLength, Footer::kEncodedLength,
                        &amp;footer_input, footer_space);
  if (!s.ok()) return s;

  Footer footer;
  s = footer.DecodeFrom(&amp;footer_input);
  if (!s.ok()) return s;

  // Read the index block
  Block* index_block = NULL;
  if (s.ok()) { // &#35835;&#21462;index block.
    s = ReadBlock(file, ReadOptions(), footer.index_handle(), &amp;index_block);
  }

  if (s.ok()) {
    // We've successfully read the footer and the index block: we're
    // ready to serve requests.
    Rep* rep = new Table::Rep; // new&#21019;&#24314;Rep&#23545;&#35937;&#28982;&#21518;&#26500;&#36896;Table&#23545;&#35937;.
    rep-&gt;options = options;
    rep-&gt;file = file;
    rep-&gt;metaindex_handle = footer.metaindex_handle();
    rep-&gt;index_block = index_block;
    rep-&gt;cache_id = (options.block_cache ? options.block_cache-&gt;NewId() : 0);
    *table = new Table(rep);
  } else {
    if (index_block) delete index_block;
  }

  return s;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-8-4-3" class="outline-6">
<h6 id="sec-1-10-8-4-3"><span class="section-number-6">1.10.8.4.3</span> ApproximateOffsetOf</h6>
<div class="outline-text-6" id="text-1-10-8-4-3">

<p>根据key找到kv在file的偏移.
</p>


<pre class="src src-C++">uint64_t Table::ApproximateOffsetOf(const Slice&amp; key) const {
  Iterator* index_iter =
      rep_-&gt;index_block-&gt;NewIterator(rep_-&gt;options.comparator);
  index_iter-&gt;Seek(key); // &#20351;&#29992;iterator seek&#21040;kv&#30340;index&#30340;&#20301;&#32622;.
  uint64_t result;
  if (index_iter-&gt;Valid()) {
    BlockHandle handle;
    Slice input = index_iter-&gt;value();
    Status s = handle.DecodeFrom(&amp;input); // &#20174;index&#36825;&#20010;BlockHandle&#20013;&#30693;&#36947;&#25968;&#25454;&#30340;&#20559;&#31227;.
    if (s.ok()) {
      result = handle.offset();
    } else {
      // Strange: we can't decode the block handle in the index block.
      // We'll just return the offset of the metaindex block, which is
      // close to the whole file size for this case.
      result = rep_-&gt;metaindex_handle.offset();
    }
  } else {
    // key is past the last key in the file.  Approximate the offset
    // by returning the offset of the metaindex block (which is
    // right near the end of the file).
    result = rep_-&gt;metaindex_handle.offset();
  }
  // &#22914;&#26524;&#25214;&#19981;&#21040;&#36825;&#20010;key&#30340;&#35805;&#65292;&#37027;&#20040;&#36820;&#22238;metaindex block&#30340;&#20559;&#31227;.
  // &#36825;&#20010;&#26159;meta block&#30340;&#26368;&#21518;&#20301;&#32622;.
  delete index_iter;
  return result;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-8-4-4" class="outline-6">
<h6 id="sec-1-10-8-4-4"><span class="section-number-6">1.10.8.4.4</span> NewIterator</h6>
<div class="outline-text-6" id="text-1-10-8-4-4">

<p>NewIterator创建的是TwoLevelIterator.意思非常简单因为需要读取两次才能够读到内容.首先读取index block,
然后读取具体的data block.关于TwoLevelIterator的实现会在后面分析.建议首先分析TwoLevelIterator
然后分析BlockReader.
</p>


<pre class="src src-C++">Iterator* Table::NewIterator(const ReadOptions&amp; options) const {
  return NewTwoLevelIterator(
      rep_-&gt;index_block-&gt;NewIterator(rep_-&gt;options.comparator),
      &amp;Table::BlockReader, const_cast&lt;Table*&gt;(this), options);
}
</pre>


</div>

</div>

<div id="outline-container-1-10-8-4-5" class="outline-6">
<h6 id="sec-1-10-8-4-5"><span class="section-number-6">1.10.8.4.5</span> DeleteBlock</h6>
<div class="outline-text-6" id="text-1-10-8-4-5">




<pre class="src src-C++">static void DeleteBlock(void* arg, void* ignored) {
  delete reinterpret_cast&lt;Block*&gt;(arg); // &#20316;&#20026;Block&#30452;&#25509;delete.
}
</pre>


</div>

</div>

<div id="outline-container-1-10-8-4-6" class="outline-6">
<h6 id="sec-1-10-8-4-6"><span class="section-number-6">1.10.8.4.6</span> DeleteCachedBlock</h6>
<div class="outline-text-6" id="text-1-10-8-4-6">




<pre class="src src-C++">static void DeleteCachedBlock(const Slice&amp; key, void* value) {
  Block* block = reinterpret_cast&lt;Block*&gt;(value); // &#20316;&#20026;Block&#30452;&#25509;&#21024;&#38500;.
  delete block;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-8-4-7" class="outline-6">
<h6 id="sec-1-10-8-4-7"><span class="section-number-6">1.10.8.4.7</span> ReleaseBlock</h6>
<div class="outline-text-6" id="text-1-10-8-4-7">




<pre class="src src-C++">static void ReleaseBlock(void* arg, void* h) {
  Cache* cache = reinterpret_cast&lt;Cache*&gt;(arg);
  Cache::Handle* handle = reinterpret_cast&lt;Cache::Handle*&gt;(h);
  cache-&gt;Release(handle);
}
</pre>


</div>

</div>

<div id="outline-container-1-10-8-4-8" class="outline-6">
<h6 id="sec-1-10-8-4-8"><span class="section-number-6">1.10.8.4.8</span> BlockReader</h6>
<div class="outline-text-6" id="text-1-10-8-4-8">

<p>BlockReader任务就是通过读取index_value给定的位置然后读取对应的Block位置并且返回BlockIterator对象.
</p>


<pre class="src src-C++">// Convert an index iterator value (i.e., an encoded BlockHandle)
// into an iterator over the contents of the corresponding block.
Iterator* Table::BlockReader(void* arg,
                             const ReadOptions&amp; options,
                             const Slice&amp; index_value) {
  Table* table = reinterpret_cast&lt;Table*&gt;(arg);
  Cache* block_cache = table-&gt;rep_-&gt;options.block_cache;
  Block* block = NULL;
  Cache::Handle* cache_handle = NULL;

  BlockHandle handle;
  Slice input = index_value;
  Status s = handle.DecodeFrom(&amp;input); // &#20808;&#25214;&#21040;offset&#21644;size.
  // We intentionally allow extra stuff in index_value so that we
  // can add more features in the future.

  if (s.ok()) {
    if (block_cache != NULL) { // &#22914;&#26524;&#23384;&#22312;Cache&#30340;&#35805;.
      char cache_key_buffer[16];
      EncodeFixed64(cache_key_buffer, table-&gt;rep_-&gt;cache_id); // &#23558;handle.offset&#21644;cache_id&#20570;&#19968;&#20010;&#31614;&#21517;&#26597;&#35810;.
      EncodeFixed64(cache_key_buffer+8, handle.offset());
      Slice key(cache_key_buffer, sizeof(cache_key_buffer));
      cache_handle = block_cache-&gt;Lookup(key);
      if (cache_handle != NULL) {
        // &#22914;&#26524;&#23384;&#22312;&#36825;&#20010;&#23545;&#35937;&#30340;&#35805;.
        block = reinterpret_cast&lt;Block*&gt;(block_cache-&gt;Value(cache_handle));
      } else {
        // &#22914;&#26524;&#27809;&#26377;&#36825;&#20010;&#23545;&#35937;&#30340;&#35805;.&#37027;&#20040;&#30452;&#25509;&#35835;&#21462;&#23545;&#35937;.
        s = ReadBlock(table-&gt;rep_-&gt;file, options, handle, &amp;block);
        if (s.ok() &amp;&amp; options.fill_cache) { // &#22914;&#26524;&#26597;&#21040;&#32467;&#26524;&#25918;&#21040;cache&#30340;&#35805;.
          cache_handle = block_cache-&gt;Insert( // &#25554;&#20837;&#36825;&#20010;&#23545;&#35937;.
              // &#36825;&#37324;&#20174;Cache&#20013;&#21024;&#38500;&#30340;&#22238;&#35843;&#23601;&#26159;&#30452;&#25509;delete.
              key, block, block-&gt;size(), &amp;DeleteCachedBlock);
        }
      }
    } else {
      s = ReadBlock(table-&gt;rep_-&gt;file, options, handle, &amp;block);
    }
  }

  Iterator* iter;
  if (block != NULL) {
    // &#24471;&#21040;&#36825;&#20010;block&#20043;&#21518;&#30340;&#35805;&#37027;&#20040;&#21019;&#24314;&#36825;&#20010;Iterator.
    // &#36825;&#20010;&#26159;&#19968;&#20010;user comparator.
    iter = block-&gt;NewIterator(table-&gt;rep_-&gt;options.comparator);
    if (cache_handle == NULL) { // &#22914;&#26524;&#27809;&#26377;&#25918;&#22312;cache&#37324;&#38754;&#30340;&#35805;.
      // &#37027;&#20040;&#24403;&#36825;&#20010;iterator&#22833;&#25928;&#30340;&#35805;&#37027;&#20040;&#30452;&#25509;&#23558;Block&#21024;&#38500;.
      iter-&gt;RegisterCleanup(&amp;DeleteBlock, block, NULL);
    } else {
      // &#21542;&#21017;&#30340;&#35805;&#37027;&#20040;&#38656;&#35201;&#20351;&#29992;&#24341;&#29992;&#35745;&#25968;.&#25152;&#20197;ReleaseBlock&#37324;&#38754;&#26159;&#37319;&#29992;Release&#26041;&#24335;.
      iter-&gt;RegisterCleanup(&amp;ReleaseBlock, block_cache, cache_handle);
    }
  } else {
    iter = NewErrorIterator(s);
  }
  return iter;
}
</pre>


</div>
</div>

</div>

<div id="outline-container-1-10-8-5" class="outline-5">
<h5 id="sec-1-10-8-5"><span class="section-number-5">1.10.8.5</span> TableBuilder</h5>
<div class="outline-text-5" id="text-1-10-8-5">

<p>table/table_builde.cc TableBuilder接口在之前include/leveldb/table_builder.h里面已经提供了。
这里我们具体看看TableBuilder的接口.关于table格式的话可以参考TableFormat这节.注意这里TableBuilder
只是将kv加入到了block并且写入了磁盘，但是对于index block并没有写入磁盘。
</p>

</div>

<div id="outline-container-1-10-8-5-1" class="outline-6">
<h6 id="sec-1-10-8-5-1"><span class="section-number-6">1.10.8.5.1</span> Rep</h6>
<div class="outline-text-6" id="text-1-10-8-5-1">

<p>Rep是TableBuilder里面具体涉及到的字段.我们来看看这个结构
</p>


<pre class="src src-C++">struct TableBuilder::Rep {
  Options options; // &#25968;&#25454;options.
  Options index_block_options; // index options.
  WritableFile* file; // sstable&#25991;&#20214;.
  uint64_t offset; // &#24403;&#21069;&#21521;&#36825;&#20010;file&#20889;&#20837;&#20102;&#22810;&#23569;&#25968;&#25454;.
  Status status; // file&#25805;&#20316;&#36820;&#22238;&#30340;status.
  BlockBuilder data_block; // data block.
  BlockBuilder index_block; // index block.
  std::string last_key; // &#19978;&#27425;&#25554;&#20837;&#30340;key.
  int64_t num_entries; // &#24050;&#32463;&#25554;&#20837;&#20102;&#22810;&#23569;&#20010;kv.
  bool closed;          // Either Finish() or Abandon() has been called.

  // We do not emit the index entry for a block until we have seen the
  // first key for the next data block.  This allows us to use shorter
  // keys in the index block.  For example, consider a block boundary
  // between the keys <span style="color: #ffff00;">"the quick brown fox"</span> and <span style="color: #ffff00;">"the who"</span>.  We can use
  // <span style="color: #ffff00;">"the r"</span> as the key for the index block entry since it is &gt;= all
  // entries in the first block and &lt; all entries in subsequent
  // blocks.
  //
  // Invariant: r-&gt;pending_index_entry is true only if data_block is empty.
  bool pending_index_entry; // &#26159;&#21542;&#21018;&#25165;&#35843;&#29992;&#20102;Finish.
  BlockHandle pending_handle;  // Handle to add to index block

  std::string compressed_output; // &#20316;&#20026;compressed&#23384;&#25918;&#30340;&#20869;&#23481;.

  Rep(const Options&amp; opt, WritableFile* f)
      : options(opt),
        index_block_options(opt),
        file(f),
        offset(0),
        data_block(&amp;options),
        index_block(&amp;index_block_options),
        num_entries(0),
        closed(false),
        pending_index_entry(false) {
    // &#37324;&#38754;&#23384;&#25918;&#30340;key&#26159;&#20840;&#37327;.
    index_block_options.block_restart_interval = 1; // index block option restart&#20026;1.
  }
};
</pre>


</div>

</div>

<div id="outline-container-1-10-8-5-2" class="outline-6">
<h6 id="sec-1-10-8-5-2"><span class="section-number-6">1.10.8.5.2</span> ChangeOptions</h6>
<div class="outline-text-6" id="text-1-10-8-5-2">




<pre class="src src-C++">Status TableBuilder::ChangeOptions(const Options&amp; options) {
  // Note: if more fields are added to Options, update
  // this function to catch changes that should not be allowed to
  // change in the middle of building a Table.
  if (options.comparator != rep_-&gt;options.comparator) {
    // &#38656;&#35201;&#30830;&#20445;comparator&#23545;&#35937;&#27809;&#26377;&#21457;&#29983;&#25913;&#21464;.
    return Status::InvalidArgument(<span style="color: #ffff00;">"changing comparator while building table"</span>);
  }

  // Note that any live BlockBuilders point to rep_-&gt;options and therefore
  // will automatically pick up the updated options.
  rep_-&gt;options = options;
  rep_-&gt;index_block_options = options;
  rep_-&gt;index_block_options.block_restart_interval = 1
  return Status::OK();
}
</pre>


</div>

</div>

<div id="outline-container-1-10-8-5-3" class="outline-6">
<h6 id="sec-1-10-8-5-3"><span class="section-number-6">1.10.8.5.3</span> Add</h6>
<div class="outline-text-6" id="text-1-10-8-5-3">




<pre class="src src-C++">void TableBuilder::Add(const Slice&amp; key, const Slice&amp; value) {
  Rep* r = rep_;
  assert(!r-&gt;closed);
  if (!ok()) return;
  if (r-&gt;num_entries &gt; 0) { // &#30830;&#20445;&#25353;&#29031;&#39034;&#24207;&#25805;&#20316;.
    assert(r-&gt;options.comparator-&gt;Compare(key, Slice(r-&gt;last_key)) &gt; 0);
  }

  if (r-&gt;pending_index_entry) { // &#22914;&#26524;&#36825;&#37324;&#26032;&#24320;&#36767;&#19968;&#20010;block&#30340;&#35805;&#23545;&#20110;&#31532;&#19968;&#22359;&#27809;&#26377;.
    // &#37027;&#20040;&#25105;&#20204;&#36825;&#37324;&#20570;&#19968;&#20010;index.
    // index key&#26159;&#25353;&#29031;last_ley&#21644;key&#20043;&#38388;&#30340;FindShortestSeparator&#24471;&#21040;&#30340;
    // &#36825;&#26679;&#21487;&#20197;&#20351;&#29992;&#20108;&#20998;&#27861;&#26469;&#36827;&#34892;&#25628;&#32034;.
    assert(r-&gt;data_block.empty());
    r-&gt;options.comparator-&gt;FindShortestSeparator(&amp;r-&gt;last_key, key);
    std::string handle_encoding;
    // &#38405;&#35835;&#23436;Finish&#20250;&#21457;&#29616;&#36825;&#37324;handle_encoding&#23454;&#38469;&#19978;&#26159;&#23601;&#26159;last_key&#30340;&#20301;&#32622;.
    // &#36825;&#37324;&#20351;&#29992;FindShortestSeparator&#26356;&#21152;&#33410;&#30465;&#31354;&#38388;&#20316;&#20026;index_block&#37324;&#38754;&#30340;&#20869;&#23481;.:).
    // &#20294;&#36825;&#37324;&#20063;&#20915;&#23450;&#20102;index_block&#30340;key&#19981;&#33021;&#22815;&#20316;&#20026;data block&#37324;&#38754;&#20934;&#30830;&#30340;key.
    r-&gt;pending_handle.EncodeTo(&amp;handle_encoding);
    r-&gt;index_block.Add(r-&gt;last_key, Slice(handle_encoding));
    r-&gt;pending_index_entry = false;
  }

  // &#26356;&#26032;last_key&#24182;&#19988;&#25554;&#20837;data block.
  r-&gt;last_key.assign(key.data(), key.size());
  r-&gt;num_entries++;
  r-&gt;data_block.Add(key, value);

  // &#22914;&#26524;&#24403;&#21069;&#30340;size&#36229;&#36807;block size&#30340;&#35805;&#37027;&#20040;&#23601;&#38656;&#35201;&#21047;&#26032;.
  const size_t estimated_block_size = r-&gt;data_block.CurrentSizeEstimate();
  if (estimated_block_size &gt;= r-&gt;options.block_size) {
    Flush();
  }
}
</pre>


</div>

</div>

<div id="outline-container-1-10-8-5-4" class="outline-6">
<h6 id="sec-1-10-8-5-4"><span class="section-number-6">1.10.8.5.4</span> Flush</h6>
<div class="outline-text-6" id="text-1-10-8-5-4">




<pre class="src src-C++">void TableBuilder::Flush() {
  Rep* r = rep_;
  assert(!r-&gt;closed);
  if (!ok()) return;
  if (r-&gt;data_block.empty()) return;
  assert(!r-&gt;pending_index_entry);
  // &#23558;data block&#20316;&#20026;Block&#20889;&#20837;&#28982;&#21518;&#23558;&#36825;&#20010;handle&#25918;&#22312;pengding_handle&#37324;&#38754;.
  // &#36825;&#20010;WriteBlock&#21518;&#38754;&#20250;&#20180;&#32454;&#20998;&#26512;&#20102;.
  WriteBlock(&amp;r-&gt;data_block, &amp;r-&gt;pending_handle);
  if (ok()) {
    r-&gt;pending_index_entry = true;
    r-&gt;status = r-&gt;file-&gt;Flush();
  }
}
</pre>


</div>

</div>

<div id="outline-container-1-10-8-5-5" class="outline-6">
<h6 id="sec-1-10-8-5-5"><span class="section-number-6">1.10.8.5.5</span> WriteBlock</h6>
<div class="outline-text-6" id="text-1-10-8-5-5">

<p>写入block的内容并且将block所在的位置交给handle.
</p>


<pre class="src src-C++">void TableBuilder::WriteBlock(BlockBuilder* block, BlockHandle* handle) {
  // File format contains a sequence of blocks where each block has:
  //    block_data: uint8[n]
  //    type: uint8
  //    crc: uint32
  assert(ok());
  Rep* r = rep_;
  Slice raw = block-&gt;Finish();

  Slice block_contents;
  CompressionType type = r-&gt;options.compression;
  // TODO(postrelease): Support more compression options: zlib?
  switch (type) {
    case kNoCompression:
      block_contents = raw;
      break;

    case kSnappyCompression: {
      std::string* compressed = &amp;r-&gt;compressed_output;
      // &#23581;&#35797;&#20351;&#29992;snappy compress.&#22914;&#26524;&#21387;&#32553;&#26356;&#22823;&#30340;&#35805;&#37027;&#20040;&#25918;&#24323;.
      if (port::Snappy_Compress(raw.data(), raw.size(), compressed) &amp;&amp;
          compressed-&gt;size() &lt; raw.size() - (raw.size() / 8u)) {
        block_contents = *compressed;
      } else {
        // Snappy not supported, or compressed less than 12.5%, so just
        // store uncompressed form
        block_contents = raw;
        type = kNoCompression;
      }
      break;
    }
  }
  // &#35774;&#32622;handle&#20026;block&#30340;&#20301;&#32622;.
  handle-&gt;set_offset(r-&gt;offset);
  handle-&gt;set_size(block_contents.size());
  r-&gt;status = r-&gt;file-&gt;Append(block_contents);
  if (r-&gt;status.ok()) {
    // &#20889;&#20837;type&#21644;crc33c:).
    char trailer[kBlockTrailerSize];
    trailer[0] = type;
    uint32_t crc = crc32c::Value(block_contents.data(), block_contents.size());
    crc = crc32c::Extend(crc, trailer, 1);  // Extend crc to cover block type
    EncodeFixed32(trailer+1, crc32c::Mask(crc));
    r-&gt;status = r-&gt;file-&gt;Append(Slice(trailer, kBlockTrailerSize));
    if (r-&gt;status.ok()) {
      r-&gt;offset += block_contents.size() + kBlockTrailerSize;
    }
  }
  r-&gt;compressed_output.clear();
  block-&gt;Reset();
}
</pre>


</div>

</div>

<div id="outline-container-1-10-8-5-6" class="outline-6">
<h6 id="sec-1-10-8-5-6"><span class="section-number-6">1.10.8.5.6</span> Finish</h6>
<div class="outline-text-6" id="text-1-10-8-5-6">

<p>Finish写入的TableFormat表述的最后面的index部分以及footer.
</p>


<pre class="src src-C++">Status TableBuilder::Finish() {
  Rep* r = rep_;
  Flush();
  assert(!r-&gt;closed);
  r-&gt;closed = true;
  BlockHandle metaindex_block_handle;
  BlockHandle index_block_handle;
  if (ok()) { // &#23454;&#38469;&#19978;&#36825;&#20010;meta_index_block&#37096;&#20998;&#27809;&#26377;&#20219;&#20309;&#20869;&#23481;.
    BlockBuilder meta_index_block(&amp;r-&gt;options);
    // TODO(postrelease): Add stats and other meta blocks
    WriteBlock(&amp;meta_index_block, &amp;metaindex_block_handle); // &#20889;&#20837;&#20043;&#21518;&#28982;&#21518;&#24471;&#21040;handle.
  }
  if (ok()) {
    if (r-&gt;pending_index_entry) {
      r-&gt;options.comparator-&gt;FindShortSuccessor(&amp;r-&gt;last_key);
      std::string handle_encoding;
      r-&gt;pending_handle.EncodeTo(&amp;handle_encoding);
      r-&gt;index_block.Add(r-&gt;last_key, Slice(handle_encoding));
      r-&gt;pending_index_entry = false;
    }
    // &#20889;&#20837;index block.
    WriteBlock(&amp;r-&gt;index_block, &amp;index_block_handle);
  }
  if (ok()) { // &#26368;&#21518;&#23558;footer&#37096;&#20998;&#20889;&#20837;.
    Footer footer;
    footer.set_metaindex_handle(metaindex_block_handle);
    footer.set_index_handle(index_block_handle);
    std::string footer_encoding;
    footer.EncodeTo(&amp;footer_encoding);
    r-&gt;status = r-&gt;file-&gt;Append(footer_encoding);
    if (r-&gt;status.ok()) {
      r-&gt;offset += footer_encoding.size();
    }
  }
  return r-&gt;status;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-8-5-7" class="outline-6">
<h6 id="sec-1-10-8-5-7"><span class="section-number-6">1.10.8.5.7</span> Abandon</h6>
<div class="outline-text-6" id="text-1-10-8-5-7">




<pre class="src src-C++">// &#25805;&#20316;&#38750;&#24120;&#31616;&#21333;&#23601;&#26159;&#25918;&#24323;&#26500;&#24314;.
void TableBuilder::Abandon() {
  Rep* r = rep_;
  assert(!r-&gt;closed);
  r-&gt;closed = true;
}
</pre>


</div>
</div>

</div>

<div id="outline-container-1-10-8-6" class="outline-5">
<h5 id="sec-1-10-8-6"><span class="section-number-5">1.10.8.6</span> BlockBuilder</h5>
<div class="outline-text-5" id="text-1-10-8-6">

<p>table/block_builder.h 从提供的接口来看的话，BlockBuilder功能应该是将多个有序的kv写到一个连续内存块内部。
我们首先看看结构然后具体分析里面的方法.提供的Reset接口允许BlockBuilder重复使用.底层针对key的prefix部分进行了压缩.
</p>


<pre class="src src-C++">class BlockBuilder {
 public:
  explicit BlockBuilder(const Options* options);

  // Reset the contents as if the BlockBuilder was just constructed.
  void Reset();

  // REQUIRES: Finish() has not been callled since the last call to Reset().
  // REQUIRES: key is larger than any previously added key
  void Add(const Slice&amp; key, const Slice&amp; value); // &#30830;&#20445;key&#30340;&#26377;&#24207;&#24615;.

  // Finish building the block and return a slice that refers to the
  // block contents.  The returned slice will remain valid for the
  // lifetime of this builder or until Reset() is called.
  Slice Finish(); // &#23436;&#25104;&#20043;&#21518;&#36820;&#22238;&#20889;&#20837;&#30340;buffer.

  // Returns an estimate of the current (uncompressed) size of the block
  // we are building.
  size_t CurrentSizeEstimate() const; // &#36820;&#22238;block buffer&#22823;&#23567;.

  // Return true iff no entries have been added since the last Reset()
  bool empty() const {
    return buffer_.empty();
  }

 private:
  const Options*        options_;
  std::string           buffer_;      // Destination buffer
  std::vector&lt;uint32_t&gt; restarts_;    // Restart points
  int                   counter_;     // Number of entries emitted since restart
  bool                  finished_;    // Has Finish() been called?
  std::string           last_key_;
};
</pre>



</div>

<div id="outline-container-1-10-8-6-1" class="outline-6">
<h6 id="sec-1-10-8-6-1"><span class="section-number-6">1.10.8.6.1</span> PrefixCompressed</h6>
<div class="outline-text-6" id="text-1-10-8-6-1">

<p>我们首先看看BlockBuilder是如何针对key进行prefix-compressed的.对于每K个key的话会保存一个完整key,然后对于
剩余的K-1个key采用prefix-compressed的方式压缩。共享的部分长度叫做shared_bytes,非共享的部分叫做unshared_bytes.
对于保存这些完整的key的点，叫做restarts.这个非常好理解。然后从下面注释可以看到restarts的信息保存在最后.
</p>


<pre class="src src-C++">// When we store a key, we drop the prefix shared with the previous
// string.  This helps reduce the space requirement significantly.
// Furthermore, once every K keys, we do not apply the prefix
// compression and store the entire key.  We call this a <span style="color: #ffff00;">"restart</span>
<span style="color: #ffff00;">// point"</span>.  The tail end of the block stores the offsets of all of the
// restart points, and can be used to do a binary search when looking
// for a particular key.  Values are stored as-is (without compression)
// immediately following the corresponding key.
//
// An entry for a particular key-value pair has the form:
//     shared_bytes: varint32
//     unshared_bytes: varint32
//     value_length: varint32
//     key_delta: char[unshared_bytes]
//     value: char[value_length]
// shared_bytes == 0 for restart points.
//
// The trailer of the block has the form:
//     restarts: uint32[num_restarts]
//     num_restarts: uint32
// restarts[i] contains the offset within the block of the ith restart point.
</pre>


</div>

</div>

<div id="outline-container-1-10-8-6-2" class="outline-6">
<h6 id="sec-1-10-8-6-2"><span class="section-number-6">1.10.8.6.2</span> BlockBuilder</h6>
<div class="outline-text-6" id="text-1-10-8-6-2">

<p>构造函数非常简单.这里options-&gt;block_restrat_interval可能就是之前说的参数K
</p>


<pre class="src src-C++">BlockBuilder::BlockBuilder(const Options* options)
    : options_(options),
      restarts_(),
      counter_(0),
      finished_(false) {
  assert(options-&gt;block_restart_interval &gt;= 1);
  restarts_.push_back(0);       // First restart point is at offset 0
}
</pre>

<p>
我们这里注意到0就是restarts一个点.
</p>
</div>

</div>

<div id="outline-container-1-10-8-6-3" class="outline-6">
<h6 id="sec-1-10-8-6-3"><span class="section-number-6">1.10.8.6.3</span> Reset</h6>
<div class="outline-text-6" id="text-1-10-8-6-3">

<p>Reset和构造函数非常简单.
</p>


<pre class="src src-C++">void BlockBuilder::Reset() {
  buffer_.clear();
  restarts_.clear();
  restarts_.push_back(0);       // First restart point is at offset 0
  counter_ = 0;
  finished_ = false;
  last_key_.clear();
}
</pre>


</div>

</div>

<div id="outline-container-1-10-8-6-4" class="outline-6">
<h6 id="sec-1-10-8-6-4"><span class="section-number-6">1.10.8.6.4</span> CurrentSizeEstimate</h6>
<div class="outline-text-6" id="text-1-10-8-6-4">

<p>按照PrefixCompressed里面的注释来看的话，长度应该就是按照下面的代码计算出来的
</p>


<pre class="src src-C++">size_t BlockBuilder::CurrentSizeEstimate() const {
  return (buffer_.size() +                        // Raw data buffer
          restarts_.size() * sizeof(uint32_t) +   // Restart array
          sizeof(uint32_t));                      // Restart array length
}
</pre>


</div>

</div>

<div id="outline-container-1-10-8-6-5" class="outline-6">
<h6 id="sec-1-10-8-6-5"><span class="section-number-6">1.10.8.6.5</span> Finish</h6>
<div class="outline-text-6" id="text-1-10-8-6-5">

<p>Finish的工作就是将restarts的信息全部写入到block buffer的结尾吧.同时将buffer_包装称为Slice返回.
</p>


<pre class="src src-C++">Slice BlockBuilder::Finish() {
  // Append restart array
  for (size_t i = 0; i &lt; restarts_.size(); i++) {
    PutFixed32(&amp;buffer_, restarts_[i]);
  }
  PutFixed32(&amp;buffer_, restarts_.size());
  finished_ = true;
  return Slice(buffer_);
}
</pre>


</div>

</div>

<div id="outline-container-1-10-8-6-6" class="outline-6">
<h6 id="sec-1-10-8-6-6"><span class="section-number-6">1.10.8.6.6</span> Add</h6>
<div class="outline-text-6" id="text-1-10-8-6-6">

<p>我们这里仔细看看prefix-compressed是相对哪一个key来进行压缩的.阅读代码会发现是针对last_key来进行的.
</p>


<pre class="src src-C++">void BlockBuilder::Add(const Slice&amp; key, const Slice&amp; value) {
  Slice last_key_piece(last_key_);
  assert(!finished_); // &#39318;&#20808;&#25105;&#20204;&#19981;&#20801;&#35768;finished.
  // &#22240;&#20026;counter_&#26159;&#33258;restart&#30340;&#35805;&#37027;&#20040;&#20250;reset0.&#25152;&#20197;&#24212;&#35813;&#26159;&lt;=.
  assert(counter_ &lt;= options_-&gt;block_restart_interval);
  // &#22914;&#26524;&#26377;&#20869;&#23481;&#30340;&#35805;&#65292;&#37027;&#20040;&#36825;&#37324;&#38656;&#35201;&#39564;&#35777;key&#26159;&#21542;&#26377;&#24207;.
  assert(buffer_.empty() // No values yet?
         || options_-&gt;comparator-&gt;Compare(key, last_key_piece) &gt; 0);
  size_t shared = 0;
  if (counter_ &lt; options_-&gt;block_restart_interval) {
    // See how much sharing to do with previous string
    const size_t min_length = std::min(last_key_piece.size(), key.size());
    // &#36825;&#37324;prefix compress&#38024;&#23545;last_key&#26469;&#20570;&#30340;.
    while ((shared &lt; min_length) &amp;&amp; (last_key_piece[shared] == key[shared])) {
      shared++;
    }
  } else {
    // Restart compression
    restarts_.push_back(buffer_.size()); // &#27880;&#24847;&#36825;&#37324;restart&#23384;&#25918;&#30340;&#26159;&#23383;&#33410;&#20559;&#31227;&#32780;&#19981;&#26159;counter.
    // &#22240;&#20026;&#35760;&#24405;counter&#37027;&#20040;&#22312;read&#30340;&#26102;&#20505;&#27809;&#26377;&#21150;&#27861;&#36824;&#21407;&#65292;&#22240;&#20026;kv&#37117;&#26159;&#21464;&#38271;&#30340;.
    counter_ = 0;
    // &#22914;&#26524;restart point&#30340;&#35805;&#65292;&#37027;&#20040;shared&#30340;&#37096;&#20998;&#24212;&#35813;&#26159;0.
  }
  const size_t non_shared = key.size() - shared;

  // Add <span style="color: #ffff00;">"&lt;shared&gt;&lt;non_shared&gt;&lt;value_size&gt;"</span> to buffer_
  PutVarint32(&amp;buffer_, shared);
  PutVarint32(&amp;buffer_, non_shared);
  PutVarint32(&amp;buffer_, value.size());

  // Add string delta to buffer_ followed by value
  buffer_.append(key.data() + shared, non_shared);
  buffer_.append(value.data(), value.size());

  // Update state
  last_key_.resize(shared);
  last_key_.append(key.data() + shared, non_shared);
  assert(Slice(last_key_) == key);
  counter_++;
}
</pre>


</div>
</div>

</div>

<div id="outline-container-1-10-8-7" class="outline-5">
<h5 id="sec-1-10-8-7"><span class="section-number-5">1.10.8.7</span> Block</h5>
<div class="outline-text-5" id="text-1-10-8-7">

<p>table/block.h Block可以认为是BlockBuilder的Reader对象，解析BlockBuilder生成的Block.提供访问接口是遍历。
首先我们看看具体接口.可以看到解析的就是一个完整的Block对象.
</p>


<pre class="src src-C+">class Block {
 public:
  // Initialize the block with the specified contents.
  // Takes ownership of data[] and will delete[] it when done.
  Block(const char* data, size_t size);

  ~Block();

  size_t size() const { return size_; }
  Iterator* NewIterator(const Comparator* comparator); // &#35775;&#38382;&#25509;&#21475;&#26041;&#24335;&#26159;&#36941;&#21382;.

 private:
  uint32_t NumRestarts() const;

  const char* data_;
  size_t size_;
  uint32_t restart_offset_;     // Offset in data_ of restart array
  // restart&#25968;&#32452;&#30340;&#20559;&#31227;.&#27599;&#20010;restart&#37117;&#26159;4&#20010;&#23383;&#33410;.
  class Iter; // &#20869;&#37096;&#23454;&#29616;.
};
</pre>



</div>

<div id="outline-container-1-10-8-7-1" class="outline-6">
<h6 id="sec-1-10-8-7-1"><span class="section-number-6">1.10.8.7.1</span> NumRestarts</h6>
<div class="outline-text-6" id="text-1-10-8-7-1">

<p>从之前的BloclBuilder知道restart个数在最后面的4字节
</p>


<pre class="src src-C++">inline uint32_t Block::NumRestarts() const {
  assert(size_ &gt;= 2*sizeof(uint32_t));
  return DecodeFixed32(data_ + size_ - sizeof(uint32_t));
}
</pre>


</div>

</div>

<div id="outline-container-1-10-8-7-2" class="outline-6">
<h6 id="sec-1-10-8-7-2"><span class="section-number-6">1.10.8.7.2</span> Block</h6>
<div class="outline-text-6" id="text-1-10-8-7-2">

<p>注意这里data已经由这个Block来托管了.在析构函数里面会释放data_
</p>


<pre class="src src-C++">Block::Block(const char* data, size_t size)
    : data_(data),
      size_(size) {
  if (size_ &lt; sizeof(uint32_t)) {
    size_ = 0;  // Error marker
  } else {
    restart_offset_ = size_ - (1 + NumRestarts()) * sizeof(uint32_t); // &#27880;&#24847;&#26368;&#21518;&#38754;&#26377;&#19968;&#20010;uint32&#34920;&#31034;restart&#20010;&#25968;.
    if (restart_offset_ &gt; size_ - sizeof(uint32_t)) { // &#22914;&#26524;restart_offset_&#23384;&#22312;&#38382;&#39064;&#30340;&#35805;.
      // The size is too small for NumRestarts() and therefore
      // restart_offset_ wrapped around.
      size_ = 0;
    }
  }
}

Block::~Block() {
  delete[] data_;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-8-7-3" class="outline-6">
<h6 id="sec-1-10-8-7-3"><span class="section-number-6">1.10.8.7.3</span> NewIterator</h6>
<div class="outline-text-6" id="text-1-10-8-7-3">

<p>创建一个迭代器.采用了工厂方法创建了具体类.关于这个具体类在后面会被称为BlockIterator来进行分析.
</p>


<pre class="src src-C++">Iterator* Block::NewIterator(const Comparator* cmp) {
  if (size_ &lt; 2*sizeof(uint32_t)) {
    return NewErrorIterator(Status::Corruption(<span style="color: #ffff00;">"bad block contents"</span>));
  }
  const uint32_t num_restarts = NumRestarts();
  if (num_restarts == 0) {
    return NewEmptyIterator();
  } else {
    return new Iter(cmp, data_, restart_offset_, num_restarts);  // &#21019;&#24314;BlockIterator.
  }
}
</pre>


</div>
</div>

</div>

<div id="outline-container-1-10-8-8" class="outline-5">
<h5 id="sec-1-10-8-8"><span class="section-number-5">1.10.8.8</span> BlockIterator</h5>
<div class="outline-text-5" id="text-1-10-8-8">

<p>table/block.cc BlockIterator本身完成的功能很简单就是Block的遍历器，我们首先看看结构
</p>


<pre class="src src-C++">class Block::Iter : public Iterator {
 private:
  const Comparator* const comparator_; // &#27604;&#36739;&#23545;&#35937;.
  const char* const data_;      // underlying block contents
  uint32_t const restarts_;     // Offset of restart array (list of fixed32)
  uint32_t const num_restarts_; // Number of uint32_t entries in restart array

  // current_ is offset in data_ of current entry.  &gt;= restarts_ if !Valid
  uint32_t current_; // &#24403;&#21069;&#30340;data_&#20301;&#32622;.
  uint32_t restart_index_;  // Index of restart block in which current_ falls
  std::string key_; // &#36825;&#37324;key&#38656;&#35201;&#21333;&#29420;&#20445;&#23384;,&#22240;&#20026;&#25105;&#20204;&#20351;&#29992;&#20102;prefix-compressed.
  Slice value_;
  Status status_;
}
</pre>



</div>

<div id="outline-container-1-10-8-8-1" class="outline-6">
<h6 id="sec-1-10-8-8-1"><span class="section-number-6">1.10.8.8.1</span> BlockIterator</h6>
<div class="outline-text-6" id="text-1-10-8-8-1">

<p>构造函数非常简单
</p>


<pre class="src src-C++">Iter(const Comparator* comparator,
     const char* data,
     uint32_t restarts,
     uint32_t num_restarts)
    : comparator_(comparator),
      data_(data),
      restarts_(restarts),
      num_restarts_(num_restarts),
      current_(restarts_),
      restart_index_(num_restarts_) {
  assert(num_restarts_ &gt; 0);
}
</pre>


</div>

</div>

<div id="outline-container-1-10-8-8-2" class="outline-6">
<h6 id="sec-1-10-8-8-2"><span class="section-number-6">1.10.8.8.2</span> NextEntryOffset</h6>
<div class="outline-text-6" id="text-1-10-8-8-2">

<p>得到下一个entry的偏移.直接使用value_的偏移和大小即可计算出来
</p>


<pre class="src src-C++">// Return the offset in data_ just past the end of the current entry.
inline uint32_t NextEntryOffset() const {
  return (value_.data() + value_.size()) - data_;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-8-8-3" class="outline-6">
<h6 id="sec-1-10-8-8-3"><span class="section-number-6">1.10.8.8.3</span> GetRestartPoint</h6>
<div class="outline-text-6" id="text-1-10-8-8-3">

<p>得到某个index的restart offset.这个直接访问最后的restart可以得到.
</p>


<pre class="src src-C++">uint32_t GetRestartPoint(uint32_t index) {
  assert(index &lt; num_restarts_);
  return DecodeFixed32(data_ + restarts_ + index * sizeof(uint32_t));
}
</pre>


</div>

</div>

<div id="outline-container-1-10-8-8-4" class="outline-6">
<h6 id="sec-1-10-8-8-4"><span class="section-number-6">1.10.8.8.4</span> SeekToRestartPoint</h6>
<div class="outline-text-6" id="text-1-10-8-8-4">

<p>这个接口的语义是到某个restart point.我们需要调整restart_index_.这里value_为了可以调用NextEntryOffset.
</p>


<pre class="src src-C++">void SeekToRestartPoint(uint32_t index) {
  key_.clear();
  restart_index_ = index;
  // current_ will be fixed by ParseNextKey();

  // ParseNextKey() starts at the end of value_, so set value_ accordingly
  uint32_t offset = GetRestartPoint(index);
  value_ = Slice(data_ + offset, 0);
}
</pre>


</div>

</div>

<div id="outline-container-1-10-8-8-5" class="outline-6">
<h6 id="sec-1-10-8-8-5"><span class="section-number-6">1.10.8.8.5</span> Next</h6>
<div class="outline-text-6" id="text-1-10-8-8-5">

<p>Next底层调用了ParseNextKey.后面我们会仔细看看ParseNextKey.
</p>


<pre class="src src-C++">virtual void Next() {
  assert(Valid());
  ParseNextKey();
}
</pre>


</div>

</div>

<div id="outline-container-1-10-8-8-6" class="outline-6">
<h6 id="sec-1-10-8-8-6"><span class="section-number-6">1.10.8.8.6</span> SeekToFirst</h6>
<div class="outline-text-6" id="text-1-10-8-8-6">




<pre class="src src-C++">virtual void SeekToFirst() {
  SeekToRestartPoint(0); // &#21040;restart0.
  ParseNextKey(); // &#28982;&#21518;&#35299;&#26512;&#19979;&#19968;&#20010;&#20803;&#32032;&#21363;&#21487;.
}
</pre>


</div>

</div>

<div id="outline-container-1-10-8-8-7" class="outline-6">
<h6 id="sec-1-10-8-8-7"><span class="section-number-6">1.10.8.8.7</span> SeekToLast</h6>
<div class="outline-text-6" id="text-1-10-8-8-7">




<pre class="src src-C++">virtual void SeekToLast() {
  SeekToRestartPoint(num_restarts_ - 1); // &#39318;&#20808;&#21040;&#26368;&#21518;&#19968;&#20010;restart.
  while (ParseNextKey() &amp;&amp; NextEntryOffset() &lt; restarts_) { // &#19968;&#30452;&#35299;&#26512;&#21040;&#26368;&#21518;&#19968;&#20010;&#20803;&#32032;.
    // Keep skipping
  }
}
</pre>


</div>

</div>

<div id="outline-container-1-10-8-8-8" class="outline-6">
<h6 id="sec-1-10-8-8-8"><span class="section-number-6">1.10.8.8.8</span> ParseNextKey</h6>
<div class="outline-text-6" id="text-1-10-8-8-8">




<pre class="src src-C++">bool ParseNextKey() {
  current_ = NextEntryOffset(); // &#19979;&#19968;&#20010;entry offset.
  const char* p = data_ + current_;
  const char* limit = data_ + restarts_;  // Restarts come right after data
  if (p &gt;= limit) { // &#22914;&#26524;&#21040;&#36798;&#32467;&#23614;&#30340;&#35805;.
    // No more entries to return.  Mark as invalid.
    current_ = restarts_;
    restart_index_ = num_restarts_;
    return false;
  }

  // Decode next entry
  uint32_t shared, non_shared, value_length;
  p = DecodeEntry(p, limit, &amp;shared, &amp;non_shared, &amp;value_length); // &#20174;p&#35299;&#26512;key&#20986;&#26469;.
  // &#21516;&#26102;&#24212;&#35813;&#21462;&#20986;&#20102;prefix&#37096;&#20998;.
  if (p == NULL || key_.size() &lt; shared) {
    CorruptionError();
    return false;
  } else {
    key_.resize(shared);
    key_.append(p, non_shared); // &#21152;&#20837;&#21518;&#38754;&#30340;&#37096;&#20998;
    value_ = Slice(p + non_shared, value_length);
    // &#21028;&#26029;&#19979;&#19968;&#20010;restart point&#26159;&#21542;&gt;=current_.
    while (restart_index_ + 1 &lt; num_restarts_ &amp;&amp;
           GetRestartPoint(restart_index_ + 1) &lt; current_) {
      ++restart_index_; // &#21542;&#21017;&#38656;&#35201;&#36827;&#20837;&#19979;&#19968;&#20010;restart point.
    }
    return true;
  }
}
</pre>


</div>

</div>

<div id="outline-container-1-10-8-8-9" class="outline-6">
<h6 id="sec-1-10-8-8-9"><span class="section-number-6">1.10.8.8.9</span> DecodeEntry</h6>
<div class="outline-text-6" id="text-1-10-8-8-9">

<p>从头部decode出shared,non_shared以及value_length.这里面为了加快判断的话有一个技巧.返回的是下一个要读取的地址.
</p>


<pre class="src src-C++">static inline const char* DecodeEntry(const char* p, const char* limit,
                                      uint32_t* shared,
                                      uint32_t* non_shared,
                                      uint32_t* value_length) {
  if (limit - p &lt; 3) return NULL;
  *shared = reinterpret_cast&lt;const unsigned char*&gt;(p)[0];
  *non_shared = reinterpret_cast&lt;const unsigned char*&gt;(p)[1];
  *value_length = reinterpret_cast&lt;const unsigned char*&gt;(p)[2];
  // &#33267;&#23569;&#23384;&#22312;3&#20010;&#23383;&#33410;.&#20294;&#26159;&#22914;&#26524;&#20219;&#24847;3&#20010;&#23383;&#33410;&lt;128&#30340;&#35805;&#65292;&#34920;&#31034;&#27599;&#20010;&#37096;&#20998;&#37117;&#26159;1&#20010;&#23383;&#33410;.
  if ((*shared | *non_shared | *value_length) &lt; 128) {
    // Fast path: all three values are encoded in one byte each
    p += 3;
  } else { // &#22914;&#26524;&#27809;&#26377;&#36825;&#20010;fast path&#30340;&#35805;&#37027;&#20040;&#20998;&#21035;&#21462;&#20986;3&#20010;&#21464;&#38271;uint32.
    if ((p = GetVarint32Ptr(p, limit, shared)) == NULL) return NULL;
    if ((p = GetVarint32Ptr(p, limit, non_shared)) == NULL) return NULL;
    if ((p = GetVarint32Ptr(p, limit, value_length)) == NULL) return NULL;
  }

  if (static_cast&lt;uint32_t&gt;(limit - p) &lt; (*non_shared + *value_length)) {
    return NULL;
  }
  return p;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-8-8-10" class="outline-6">
<h6 id="sec-1-10-8-8-10"><span class="section-number-6">1.10.8.8.10</span> Prev</h6>
<div class="outline-text-6" id="text-1-10-8-8-10">

<p>Prev相对于Next有一点低效.首先遍历找到restart point,然后在这个restart range里面遍历.
</p>


<pre class="src src-C++">virtual void Prev() {
  assert(Valid());

  // Scan backwards to a restart point before current_
  const uint32_t original = current_;
  while (GetRestartPoint(restart_index_) &gt;= original) { // &#39318;&#20808;&#25214;&#21040;restart range.
    if (restart_index_ == 0) {
      // No more entries
      current_ = restarts_;
      restart_index_ = num_restarts_;
      return;
    }
    restart_index_--;
  }

  SeekToRestartPoint(restart_index_); // &#28982;&#21518;&#36339;&#21040;&#36825;&#20010;restart range.
  do { // &#22312;&#36825;&#20010;restart range&#37324;&#38754;&#36941;&#21382;.
    // Loop until end of current entry hits the start of original entry
  } while (ParseNextKey() &amp;&amp; NextEntryOffset() &lt; original);
}
</pre>


</div>

</div>

<div id="outline-container-1-10-8-8-11" class="outline-6">
<h6 id="sec-1-10-8-8-11"><span class="section-number-6">1.10.8.8.11</span> Seek</h6>
<div class="outline-text-6" id="text-1-10-8-8-11">

<p>Seek非常简单，首先在restart point地方因为里面存放都是有序的完整的key.那么可以restart point
这些地方进行二分查找.然后在restart range里面通过遍历查找.还算是比较高效吧。注意这里如果没有找到的话，
返回的是第一个&gt;=target的对象.
</p>


<pre class="src src-C++">virtual void Seek(const Slice&amp; target) {
  // Binary search in restart array to find the first restart point
  // with a key &gt;= target
  uint32_t left = 0;
  uint32_t right = num_restarts_ - 1;
  while (left &lt; right) { // &#22312;restart&#36825;&#20123;&#37096;&#20998;&#20108;&#20998;&#26597;&#25214;.
    uint32_t mid = (left + right + 1) / 2;
    uint32_t region_offset = GetRestartPoint(mid);
    uint32_t shared, non_shared, value_length;
    const char* key_ptr = DecodeEntry(data_ + region_offset,
                                      data_ + restarts_,
                                      &amp;shared, &amp;non_shared, &amp;value_length);
    if (key_ptr == NULL || (shared != 0)) {
      CorruptionError();
      return;
    }
    Slice mid_key(key_ptr, non_shared);
    if (Compare(mid_key, target) &lt; 0) {
      // Key at <span style="color: #ffff00;">"mid"</span> is smaller than <span style="color: #ffff00;">"target"</span>.  Therefore all
      // blocks before <span style="color: #ffff00;">"mid"</span> are uninteresting.
      left = mid;
    } else {
      // Key at <span style="color: #ffff00;">"mid"</span> is &gt;= <span style="color: #ffff00;">"target"</span>.  Therefore all blocks at or
      // after <span style="color: #ffff00;">"mid"</span> are uninteresting.
      right = mid - 1;
    }
  }

  // Linear search (within restart block) for first key &gt;= target
  SeekToRestartPoint(left); // &#20174;&#36825;&#20010;&#37096;&#20998;&#24320;&#22987;&#36941;&#21382;&#26597;&#25214;.
  while (true) {
    if (!ParseNextKey()) {
      return;
    }
    if (Compare(key_, target) &gt;= 0) {
      return;
    }
  }
}
</pre>


</div>
</div>

</div>

<div id="outline-container-1-10-8-9" class="outline-5">
<h5 id="sec-1-10-8-9"><span class="section-number-5">1.10.8.9</span> BlockHandle</h5>
<div class="outline-text-5" id="text-1-10-8-9">

<p>table/format.h BlockHandle用于压缩和解压文件信息.包括两个字段offset和size.不是很麻烦
</p>


<pre class="src src-C++">// BlockHandle is a pointer to the extent of a file that stores a data
// block or a meta block.
class BlockHandle {
 public:
  BlockHandle();

  // The offset of the block in the file.
  uint64_t offset() const { return offset_; }
  void set_offset(uint64_t offset) { offset_ = offset; }

  // The size of the stored block
  uint64_t size() const { return size_; }
  void set_size(uint64_t size) { size_ = size; }

  void EncodeTo(std::string* dst) const;
  Status DecodeFrom(Slice* input);

  // Maximum encoding length of a BlockHandle
  enum { kMaxEncodedLength = 10 + 10 }; // uint64&#26368;&#22823;&#21387;&#32553;&#22823;&#23567;&#20026;10&#23383;&#33410;.

 private:
  uint64_t offset_;
  uint64_t size_;
};
inline BlockHandle::BlockHandle()
    : offset_(~static_cast&lt;uint64_t&gt;(0)), // &#21021;&#22987;&#20540;&#38750;&#24120;&#22823;.
      size_(~static_cast&lt;uint64_t&gt;(0)) {
}
</pre>



</div>

<div id="outline-container-1-10-8-9-1" class="outline-6">
<h6 id="sec-1-10-8-9-1"><span class="section-number-6">1.10.8.9.1</span> EncodeTo</h6>
<div class="outline-text-6" id="text-1-10-8-9-1">




<pre class="src src-C++">void BlockHandle::EncodeTo(std::string* dst) const {
  // Sanity check that all fields have been set
  assert(offset_ != ~static_cast&lt;uint64_t&gt;(0));
  assert(size_ != ~static_cast&lt;uint64_t&gt;(0));
  PutVarint64(dst, offset_);
  PutVarint64(dst, size_);
}
</pre>


</div>

</div>

<div id="outline-container-1-10-8-9-2" class="outline-6">
<h6 id="sec-1-10-8-9-2"><span class="section-number-6">1.10.8.9.2</span> DecodeFrom</h6>
<div class="outline-text-6" id="text-1-10-8-9-2">




<pre class="src src-C++">Status BlockHandle::DecodeFrom(Slice* input) {
  if (GetVarint64(input, &amp;offset_) &amp;&amp;
      GetVarint64(input, &amp;size_)) {
    return Status::OK();
  } else {
    return Status::Corruption(<span style="color: #ffff00;">"bad block handle"</span>);
  }
}
</pre>


</div>
</div>

</div>

<div id="outline-container-1-10-8-10" class="outline-5">
<h5 id="sec-1-10-8-10"><span class="section-number-5">1.10.8.10</span> Footer</h5>
<div class="outline-text-5" id="text-1-10-8-10">

<p>db/format.h Footer里面打包称为定长信息.从注释上说保存在各个table文件末尾.现在还不知道具体有什么用途.
(但是阅读完TableFormat这节之后应该知道这两个字段的含义).前面两个BlockHandle使用变长打包但是空出了MaxEncodedLength.
最后8个字节使用
</p>


<pre class="src src-C++">// kTableMagicNumber was picked by running
//    echo http://code.google.com/p/leveldb/ | sha1sum
// and taking the leading 64 bits.
static const uint64_t kTableMagicNumber = 0xdb4775248b80fb57ull;
</pre>

<p>
使用这个魔术数字比较有意思。我们来看看大致的结构.
</p>


<pre class="src src-C++">// Footer encapsulates the fixed information stored at the tail
// end of every table file.
class Footer {
 public:
  Footer() { }

  // The block handle for the metaindex block of the table
  const BlockHandle&amp; metaindex_handle() const { return metaindex_handle_; }
  void set_metaindex_handle(const BlockHandle&amp; h) { metaindex_handle_ = h; }

  // The block handle for the index block of the table
  const BlockHandle&amp; index_handle() const {
    return index_handle_;
  }
  void set_index_handle(const BlockHandle&amp; h) {
    index_handle_ = h;
  }

  void EncodeTo(std::string* dst) const;
  Status DecodeFrom(Slice* input);

  // Encoded length of a Footer.  Note that the serialization of a
  // Footer will always occupy exactly this many bytes.  It consists
  // of two block handles and a magic number.
  enum {
    kEncodedLength = 2*BlockHandle::kMaxEncodedLength + 8 // &#22266;&#23450;&#38271;&#24230;.
  };

 private:
  BlockHandle metaindex_handle_; // metaindex handle.
  BlockHandle index_handle_; // index handle.
};
</pre>



</div>

<div id="outline-container-1-10-8-10-1" class="outline-6">
<h6 id="sec-1-10-8-10-1"><span class="section-number-6">1.10.8.10.1</span> EncodeTo</h6>
<div class="outline-text-6" id="text-1-10-8-10-1">




<pre class="src src-C++">void Footer::EncodeTo(std::string* dst) const {
#ifndef NDEBUG
  const size_t original_size = dst-&gt;size();
#endif
  metaindex_handle_.EncodeTo(dst);
  index_handle_.EncodeTo(dst);
  dst-&gt;resize(2 * BlockHandle::kMaxEncodedLength);  // Padding
  PutFixed32(dst, static_cast&lt;uint32_t&gt;(kTableMagicNumber &amp; 0xffffffffu));
  PutFixed32(dst, static_cast&lt;uint32_t&gt;(kTableMagicNumber &gt;&gt; 32));
  assert(dst-&gt;size() == original_size + kEncodedLength);
}
</pre>


</div>

</div>

<div id="outline-container-1-10-8-10-2" class="outline-6">
<h6 id="sec-1-10-8-10-2"><span class="section-number-6">1.10.8.10.2</span> DecodeFrom</h6>
<div class="outline-text-6" id="text-1-10-8-10-2">

<p>这里input作为输入，头部是EncodeTo的内容后面可能带有其他数据。解析完成之后将剩余返回给input.
</p>


<pre class="src src-C++">Status Footer::DecodeFrom(Slice* input) {
  const char* magic_ptr = input-&gt;data() + kEncodedLength - 8;
  const uint32_t magic_lo = DecodeFixed32(magic_ptr);
  const uint32_t magic_hi = DecodeFixed32(magic_ptr + 4);
  const uint64_t magic = ((static_cast&lt;uint64_t&gt;(magic_hi) &lt;&lt; 32) |
                          (static_cast&lt;uint64_t&gt;(magic_lo)));
  if (magic != kTableMagicNumber) {
    return Status::InvalidArgument(<span style="color: #ffff00;">"not an sstable (bad magic number)"</span>);
  }

  Status result = metaindex_handle_.DecodeFrom(input);
  if (result.ok()) {
    result = index_handle_.DecodeFrom(input);
  }
  if (result.ok()) {
    // We skip over any leftover data (just padding for now) in <span style="color: #ffff00;">"input"</span>
    const char* end = magic_ptr + 8;
    *input = Slice(end, input-&gt;data() + input-&gt;size() - end);
  }
  return result;
}
</pre>


</div>
</div>

</div>

<div id="outline-container-1-10-8-11" class="outline-5">
<h5 id="sec-1-10-8-11"><span class="section-number-5">1.10.8.11</span> ReadBlock</h5>
<div class="outline-text-5" id="text-1-10-8-11">

<p>table/format.cc ReadBlock应该是从随机文件里面读取Block出来.对于这个Block的位置的话由handle提供.
注意每个Block后面还有crc和type.这个可以参考TableBuilder实现。然后将读取的Block二进制构造Block对象返回。
</p>


<pre class="src src-C++">// 1-byte type + 32-bit crc
// type&#34920;&#31034;&#20351;&#29992;&#20160;&#20040;&#21387;&#32553;&#26041;&#24335;.
static const size_t kBlockTrailerSize = 5;
</pre>


<p>
下面看看具体实现代码
</p>


<pre class="src src-C++">Status ReadBlock(RandomAccessFile* file,
                 const ReadOptions&amp; options,
                 const BlockHandle&amp; handle,
                 Block** block) {
  *block = NULL;

  // Read the block contents as well as the type/crc footer.
  // See table_builder.cc for the code that built this structure.
  size_t n = static_cast&lt;size_t&gt;(handle.size());
  char* buf = new char[n + kBlockTrailerSize];
  Slice contents;
  Status s = file-&gt;Read(handle.offset(), n + kBlockTrailerSize, &amp;contents, buf);
  if (!s.ok()) {
    delete[] buf;
    return s;
  }
  if (contents.size() != n + kBlockTrailerSize) {
    delete[] buf;
    return Status::Corruption(<span style="color: #ffff00;">"truncated block read"</span>);
  }

  // &#26657;&#39564;CRC32C
  // Check the crc of the type and the block contents
  const char* data = contents.data();    // Pointer to where Read put the data
  if (options.verify_checksums) {
    const uint32_t crc = crc32c::Unmask(DecodeFixed32(data + n + 1));
    const uint32_t actual = crc32c::Value(data, n + 1);
    if (actual != crc) {
      delete[] buf;
      s = Status::Corruption(<span style="color: #ffff00;">"block checksum mismatch"</span>);
      return s;
    }
  }

  // &#26681;&#25454;type&#21028;&#26029;&#20351;&#29992;&#20160;&#20040;&#21387;&#32553;&#26041;&#24335;.
  switch (data[n]) {
    case kNoCompression:
      if (data != buf) {
        // File implementation gave us pointer to some other data.
        // Copy into buf[].
        memcpy(buf, data, n + kBlockTrailerSize);
      }

      // Ok
      break;
    case kSnappyCompression: {
      // ... // &#36825;&#37324;&#25105;&#25925;&#24847;&#30465;&#21435;&#20102;.&#25105;&#20204;&#36825;&#37324;&#26242;&#26102;&#19981;&#20851;&#31995;&#36825;&#20010;&#36923;&#36753;
      // &#20351;&#29992;Snappy&#26469;&#35299;&#21387;&#32553;.
      break;
    }
    default:
      delete[] buf;
      return Status::Corruption(<span style="color: #ffff00;">"bad block type"</span>);
  }

  // &#36820;&#22238;Block&#23545;&#35937;.
  // Block&#23545;&#35937;&#21487;&#20197;&#36890;&#36807;&#36845;&#20195;&#22120;&#26469;&#36827;&#34892;&#35775;&#38382;.
  *block = new Block(buf, n);  // Block takes ownership of buf[]
  return Status::OK();
}
</pre>


</div>

</div>

<div id="outline-container-1-10-8-12" class="outline-5">
<h5 id="sec-1-10-8-12"><span class="section-number-5">1.10.8.12</span> IteratorWrapper</h5>
<div class="outline-text-5" id="text-1-10-8-12">

<p>table/iterator_wrapper.h IteratorWrapper就是Iterator的装饰者。对于Valid,Key进行了缓存.
这个其实还是比较有必要的.因为有些iterator取key和valid代价比较大.不过似乎对于虚函数没有节省开销，
因为内部存放的还是Iterator对象而不是模板。阅读完了TwoLevelIterator就会发现，这个类存在原因，
主要是为了管理Iterator对象的管理。比如Set的时候会将原来的Iterator对象释放，析构函数会将持有的Iterator释放。
</p>


<pre class="src src-C++">// A internal wrapper class with an interface similar to Iterator that
// caches the valid() and key() results for an underlying iterator.
// This can help avoid virtual function calls and also gives better
// cache locality.
</pre>


</div>

</div>

<div id="outline-container-1-10-8-13" class="outline-5">
<h5 id="sec-1-10-8-13"><span class="section-number-5">1.10.8.13</span> EmptyIterator</h5>
<div class="outline-text-5" id="text-1-10-8-13">

<p>EmptyIterator用来构造返回错误或者是空的Iterator.提供了两个函数
</p><ul>
<li>NewEmptyIterator
</li>
<li>NewErrorIterator
</li>
</ul>

<p>来进行构造。具体实现放在了table/iterator.cc里面
</p>


<pre class="src src-C++">class EmptyIterator : public Iterator {
 public:
  EmptyIterator(const Status&amp; s) : status_(s) { }
  virtual bool Valid() const { return false; }
  virtual void Seek(const Slice&amp; target) { }
  virtual void SeekToFirst() { }
  virtual void SeekToLast() { }
  virtual void Next() { assert(false); }
  virtual void Prev() { assert(false); }
  Slice key() const { assert(false); return Slice(); }
  Slice value() const { assert(false); return Slice(); }
  virtual Status status() const { return status_; }
 private:
  Status status_;
};
</pre>


</div>

</div>

<div id="outline-container-1-10-8-14" class="outline-5">
<h5 id="sec-1-10-8-14"><span class="section-number-5">1.10.8.14</span> TwoLevelIterator</h5>
<div class="outline-text-5" id="text-1-10-8-14">

<p>table/two_level_iterator.h TwoLevelIterator是一个二级Iterator配合sstable二级索引文件使用的。
通过工厂方法来进行构造所以接口非常简单。主要还是看TwoLevelIterator里面的实现。
</p>


<pre class="src src-C++">// Return a new two level iterator.  A two-level iterator contains an
// index iterator whose values point to a sequence of blocks where
// each block is itself a sequence of key,value pairs.  The returned
// two-level iterator yields the concatenation of all key/value pairs
// in the sequence of blocks.  Takes ownership of <span style="color: #ffff00;">"index_iter"</span> and
// will delete it when no longer needed.
//
// Uses a supplied function to convert an index_iter value into
// an iterator over the contents of the corresponding block.
extern Iterator* NewTwoLevelIterator(
    Iterator* index_iter, // index block iterator.
    Iterator* (*block_function)(
        void* arg,
        const ReadOptions&amp; options,
        const Slice&amp; index_value),
    void* arg,
    const ReadOptions&amp; options);
</pre>



</div>

<div id="outline-container-1-10-8-14-1" class="outline-6">
<h6 id="sec-1-10-8-14-1"><span class="section-number-6">1.10.8.14.1</span> NewTwoLevelIterator</h6>
<div class="outline-text-6" id="text-1-10-8-14-1">




<pre class="src src-C++">Iterator* NewTwoLevelIterator(
    Iterator* index_iter,
    BlockFunction block_function,
    void* arg,
    const ReadOptions&amp; options) {
  // &#38750;&#24120;&#31616;&#21333;&#23601;&#26159;&#21019;&#24314;&#23545;&#35937;.
  return new TwoLevelIterator(index_iter, block_function, arg, options);
}
</pre>


<p>
然后我们看看TwoLevelIterator的结构以及构造函数实现。接下来我们看看几个主要的接口。
</p>


<pre class="src src-C++">typedef Iterator* (*BlockFunction)(void*, const ReadOptions&amp;, const Slice&amp;);

class TwoLevelIterator: public Iterator {
 private:
  BlockFunction block_function_;
  void* arg_;
  const ReadOptions options_;
  Status status_;
  IteratorWrapper index_iter_;
  // &#23545;&#20110;key,value&#36825;&#26679;&#30340;&#26041;&#27861;&#30452;&#25509;&#32473;data_iter_&#20195;&#29702;&#21363;&#21487;.
  IteratorWrapper data_iter_; // May be NULL
  // If data_iter_ is non-NULL, then <span style="color: #ffff00;">"data_block_handle_"</span> holds the
  // <span style="color: #ffff00;">"index_value"</span> passed to block_function_ to create the data_iter_.
  std::string data_block_handle_;
};

TwoLevelIterator::TwoLevelIterator(
    Iterator* index_iter,
    BlockFunction block_function,
    void* arg,
    const ReadOptions&amp; options)
    : block_function_(block_function),
      arg_(arg),
      options_(options),
      index_iter_(index_iter),
      data_iter_(NULL) {
}
</pre>


</div>

</div>

<div id="outline-container-1-10-8-14-2" class="outline-6">
<h6 id="sec-1-10-8-14-2"><span class="section-number-6">1.10.8.14.2</span> Seek</h6>
<div class="outline-text-6" id="text-1-10-8-14-2">




<pre class="src src-C++">void TwoLevelIterator::Seek(const Slice&amp; target) {
  index_iter_.Seek(target); // &#39318;&#20808;&#36890;&#36807;index iter&#36827;&#34892;&#23450;&#20301;.
  // &#27880;&#24847;&#36825;&#37324;&#21487;&#33021;&#27809;&#26377;&#25214;&#21040;&#12290;BlockIterator::Seek&#34892;&#20026;&#26159;&#25214;&#21040;&gt;=target&#23545;&#35937;.
  InitDataBlock(); // &#21021;&#22987;&#21270;data_iter.
  if (data_iter_.iter() != NULL) data_iter_.Seek(target); // &#20351;&#29992;data_iter&#23450;&#20301;.
  SkipEmptyDataBlocksForward(); // &#21521;&#21069;&#30053;&#36807;&#31354;&#30333;&#35760;&#24405;.
}
</pre>


</div>

</div>

<div id="outline-container-1-10-8-14-3" class="outline-6">
<h6 id="sec-1-10-8-14-3"><span class="section-number-6">1.10.8.14.3</span> SeekToFirst</h6>
<div class="outline-text-6" id="text-1-10-8-14-3">




<pre class="src src-C++">void TwoLevelIterator::SeekToFirst() {
  index_iter_.SeekToFirst(); // &#39318;&#20808;index inter.
  InitDataBlock();
  if (data_iter_.iter() != NULL) data_iter_.SeekToFirst(); // &#28982;&#21518;data iter.
  SkipEmptyDataBlocksForward(); // &#21521;&#21069;&#36339;&#36807;&#31354;&#30333;&#35760;&#24405;.
}
</pre>


</div>

</div>

<div id="outline-container-1-10-8-14-4" class="outline-6">
<h6 id="sec-1-10-8-14-4"><span class="section-number-6">1.10.8.14.4</span> SeekToLast</h6>
<div class="outline-text-6" id="text-1-10-8-14-4">




<pre class="src src-C++">void TwoLevelIterator::SeekToLast() {
  index_iter_.SeekToLast(); // &#39318;&#20808;index iter.
  InitDataBlock();
  if (data_iter_.iter() != NULL) data_iter_.SeekToLast(); // &#28982;&#21518;data iter.
  SkipEmptyDataBlocksBackward(); // &#21521;&#21518;&#36339;&#36807;&#31354;&#30333;&#35760;&#24405;.
}
</pre>


</div>

</div>

<div id="outline-container-1-10-8-14-5" class="outline-6">
<h6 id="sec-1-10-8-14-5"><span class="section-number-6">1.10.8.14.5</span> Next</h6>
<div class="outline-text-6" id="text-1-10-8-14-5">




<pre class="src src-C++">void TwoLevelIterator::Next() {
  assert(Valid());
  data_iter_.Next();
  SkipEmptyDataBlocksForward(); // &#21521;&#21069;&#36339;&#36807;&#31354;&#30333;&#35760;&#24405;.&#36825;&#20010;&#37096;&#20998;&#21487;&#33021;&#38656;&#35201;&#32771;&#34385;data_iter_&#22833;&#25928;.
}
</pre>


</div>

</div>

<div id="outline-container-1-10-8-14-6" class="outline-6">
<h6 id="sec-1-10-8-14-6"><span class="section-number-6">1.10.8.14.6</span> Prev</h6>
<div class="outline-text-6" id="text-1-10-8-14-6">




<pre class="src src-C++">void TwoLevelIterator::Prev() {
  assert(Valid());
  data_iter_.Prev();
  SkipEmptyDataBlocksBackward(); // &#21521;&#21518;&#36339;&#36807;&#31354;&#30333;&#35760;&#24405;.&#36825;&#20010;&#37096;&#20998;&#21487;&#33021;&#38656;&#35201;&#32771;&#34385;data_iter_&#22833;&#25928;.
}
</pre>


</div>

</div>

<div id="outline-container-1-10-8-14-7" class="outline-6">
<h6 id="sec-1-10-8-14-7"><span class="section-number-6">1.10.8.14.7</span> InitDataBlock</h6>
<div class="outline-text-6" id="text-1-10-8-14-7">




<pre class="src src-C++">void TwoLevelIterator::InitDataBlock() {
  if (!index_iter_.Valid()) {
    SetDataIterator(NULL); // &#22914;&#26524;index_iter&#24050;&#32463;&#22833;&#25928;&#30340;&#35805;.
  } else {
    Slice handle = index_iter_.value();
    if (data_iter_.iter() != NULL &amp;&amp; handle.compare(data_block_handle_) == 0) {
      // data_iter_ is already constructed with this iterator, so
      // no need to change anything
    } else { // &#35843;&#29992;block_function&#26469;&#35835;&#21462;&#20855;&#20307;&#30340;data block.
      // &#36825;&#37324;&#21487;&#20197;&#30475;&#21040;,block_function&#30340;&#29992;&#36884;&#23601;&#26159;&#35835;&#21462;handle
      // &#20854;&#20013;handle&#37324;&#38754;&#26159;&#23545;&#24212;data block&#25152;&#22312;&#30340;&#20301;&#32622;&#12290;
      Iterator* iter = (*block_function_)(arg_, options_, handle);
      // &#35774;&#32622;data block handle.:).
      data_block_handle_.assign(handle.data(), handle.size());
      SetDataIterator(iter);
    }
  }
}
</pre>


</div>

</div>

<div id="outline-container-1-10-8-14-8" class="outline-6">
<h6 id="sec-1-10-8-14-8"><span class="section-number-6">1.10.8.14.8</span> SetDataIterator</h6>
<div class="outline-text-6" id="text-1-10-8-14-8">




<pre class="src src-C++">void TwoLevelIterator::SetDataIterator(Iterator* data_iter) {
  if (data_iter_.iter() != NULL) SaveError(data_iter_.status());
  data_iter_.Set(data_iter); // &#27880;&#24847;&#36825;&#37324;IteratorWrapper&#36827;&#34892;Set&#30340;&#35805;&#21407;&#26469;&#20250;&#37322;&#25918;.
  // &#36825;&#20063;&#35299;&#37322;&#20102;&#20026;&#20160;&#20040;&#25105;&#20204;&#38656;&#35201;IteratorWrapper&#23545;&#35937;&#23384;&#22312;.
}
</pre>


</div>

</div>

<div id="outline-container-1-10-8-14-9" class="outline-6">
<h6 id="sec-1-10-8-14-9"><span class="section-number-6">1.10.8.14.9</span> SkipEmptyDataBlocksForward</h6>
<div class="outline-text-6" id="text-1-10-8-14-9">

<p>对于空的DataBlock的话那么!data_iter_.Valid().对于空的DataBlock可以跳过IndexBlock快速跨越。
</p>


<pre class="src src-C++">void TwoLevelIterator::SkipEmptyDataBlocksForward() {
  while (data_iter_.iter() == NULL || !data_iter_.Valid()) {
    // Move to next block
    if (!index_iter_.Valid()) {
      SetDataIterator(NULL);
      return;
    }
    index_iter_.Next();
    InitDataBlock();
    if (data_iter_.iter() != NULL) data_iter_.SeekToFirst();
  }
}
</pre>


</div>

</div>

<div id="outline-container-1-10-8-14-10" class="outline-6">
<h6 id="sec-1-10-8-14-10"><span class="section-number-6">1.10.8.14.10</span> SkipEmptyDataBlocksBackward</h6>
<div class="outline-text-6" id="text-1-10-8-14-10">




<pre class="src src-C++">void TwoLevelIterator::SkipEmptyDataBlocksBackward() {
  while (data_iter_.iter() == NULL || !data_iter_.Valid()) {
    // Move to next block
    if (!index_iter_.Valid()) {
      SetDataIterator(NULL);
      return;
    }
    index_iter_.Prev();
    InitDataBlock();
    if (data_iter_.iter() != NULL) data_iter_.SeekToLast();
  }
}
</pre>


</div>
</div>

</div>

<div id="outline-container-1-10-8-15" class="outline-5">
<h5 id="sec-1-10-8-15"><span class="section-number-5">1.10.8.15</span> MergingIterator</h5>
<div class="outline-text-5" id="text-1-10-8-15">

<p>table/merger.cc 可以认为这个是一个Iterator的多路归并实现。但是巧妙的是将多路Iterator
归并称为一个Iterator进行遍历。从注释上面可以看到对于key不会进行去重。依然是一个工厂方法。
</p>


<pre class="src src-C++">// Return an iterator that provided the union of the data in
// children[0,n-1].  Takes ownership of the child iterators and
// will delete them when the result iterator is deleted.
//
// The result does no duplicate suppression.  I.e., if a particular
// key is present in K child iterators, it will be yielded K times.
//
// REQUIRES: n &gt;= 0
extern Iterator* NewMergingIterator(
    const Comparator* comparator, Iterator** children, int n);
</pre>



</div>

<div id="outline-container-1-10-8-15-1" class="outline-6">
<h6 id="sec-1-10-8-15-1"><span class="section-number-6">1.10.8.15.1</span> NewMergingIterator</h6>
<div class="outline-text-6" id="text-1-10-8-15-1">




<pre class="src src-C++">// &#27880;&#24847;&#36825;&#37324;&#25105;&#20204;&#38656;&#35201;&#25176;&#31649;list&#37324;&#38754;&#30340;Iterator&#23545;&#35937;.
Iterator* NewMergingIterator(const Comparator* cmp, Iterator** list, int n) {
  assert(n &gt;= 0);
  if (n == 0) {
    return NewEmptyIterator(); // &#23545;&#20110;n==0&#37027;&#20040;&#26159;empty iterator.
  } else if (n == 1) {
    return list[0]; // &#22914;&#26524;n==1&#30340;&#35805;&#37027;&#20040;&#21482;&#38656;&#35201;&#36820;&#22238;&#31532;&#19968;&#20010;&#21363;&#21487;.
    // &#36825;&#37324;&#24182;&#27809;&#26377;&#38382;&#39064;&#22240;&#20026;&#25105;&#20204;&#26368;&#21518;&#20250;&#30452;&#25509;delete&#36825;&#20010;&#23545;&#35937;&#30340;&#12290;
  } else {
    return new MergingIterator(cmp, list, n); // &#21542;&#21017;&#23601;&#38656;&#35201;&#36827;&#34892;&#21512;&#24182;.
  }
}
</pre>


</div>

</div>

<div id="outline-container-1-10-8-15-2" class="outline-6">
<h6 id="sec-1-10-8-15-2"><span class="section-number-6">1.10.8.15.2</span> MergingIterator</h6>
<div class="outline-text-6" id="text-1-10-8-15-2">

<p>首先看看结构以及构造和析构函数.
</p>


<pre class="src src-C++">class MergingIterator : public Iterator {
 public:
  MergingIterator(const Comparator* comparator, Iterator** children, int n)
      : comparator_(comparator),
        children_(new IteratorWrapper[n]),
        n_(n),
        current_(NULL),
        direction_(kForward) {
    for (int i = 0; i &lt; n; i++) {
      children_[i].Set(children[i]);
    }
  }

  virtual ~MergingIterator() {
    delete[] children_;
  }

 private:
  // We might want to use a heap in case there are lots of children.
  // For now we use a simple array since we expect a very small number
  // of children in leveldb.
  const Comparator* comparator_; // &#27604;&#36739;&#22120;.
  IteratorWrapper* children_; // &#22810;&#36335;Iterator.
  int n_; // &#22810;&#23569;&#36335;.
  IteratorWrapper* current_; // &#24403;&#21069;Iterator.

  // Which direction is the iterator moving?
  enum Direction {
    kForward,
    kReverse
  };
  Direction direction_; // &#26041;&#21521;.
};
</pre>


</div>

</div>

<div id="outline-container-1-10-8-15-3" class="outline-6">
<h6 id="sec-1-10-8-15-3"><span class="section-number-6">1.10.8.15.3</span> Key</h6>
<div class="outline-text-6" id="text-1-10-8-15-3">




<pre class="src src-C++">virtual Slice key() const {
  assert(Valid());
  return current_-&gt;key();
}
</pre>


</div>

</div>

<div id="outline-container-1-10-8-15-4" class="outline-6">
<h6 id="sec-1-10-8-15-4"><span class="section-number-6">1.10.8.15.4</span> Value</h6>
<div class="outline-text-6" id="text-1-10-8-15-4">




<pre class="src src-C++">virtual Slice value() const {
  assert(Valid());
  return current_-&gt;value();
}
</pre>


</div>

</div>

<div id="outline-container-1-10-8-15-5" class="outline-6">
<h6 id="sec-1-10-8-15-5"><span class="section-number-6">1.10.8.15.5</span> Seek</h6>
<div class="outline-text-6" id="text-1-10-8-15-5">




<pre class="src src-C++">virtual void Seek(const Slice&amp; target) {
  for (int i = 0; i &lt; n_; i++) { // &#27599;&#20010;children&#37117;seek&#21040;&#36825;&#20010;target.
    children_[i].Seek(target);
  }
  FindSmallest(); // &#28982;&#21518;&#23545;&#27604;&#19968;&#19979;&#26368;&#23567;&#30340;&#23545;&#35937;.&#35774;&#32622;&#20026;current.
  direction_ = kForward; // &#35774;&#32622;&#19968;&#19979;&#26041;&#21521;.
  // &#23545;&#20110;Key,Value&#30340;&#35805;&#35843;&#29992;current&#36825;&#20010;Iterator.
}
</pre>


</div>

</div>

<div id="outline-container-1-10-8-15-6" class="outline-6">
<h6 id="sec-1-10-8-15-6"><span class="section-number-6">1.10.8.15.6</span> SeekToFirst</h6>
<div class="outline-text-6" id="text-1-10-8-15-6">




<pre class="src src-C++">virtual void SeekToFirst() {
  for (int i = 0; i &lt; n_; i++) {
    children_[i].SeekToFirst();
  }
  FindSmallest();
  direction_ = kForward;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-8-15-7" class="outline-6">
<h6 id="sec-1-10-8-15-7"><span class="section-number-6">1.10.8.15.7</span> SeekToLast</h6>
<div class="outline-text-6" id="text-1-10-8-15-7">




<pre class="src src-C++">virtual void SeekToLast() {
  for (int i = 0; i &lt; n_; i++) {
    children_[i].SeekToLast();
  }
  FindLargest(); // &#25214;&#21040;&#26368;&#22823;&#30340;&#20316;&#20026;current_.
  direction_ = kReverse;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-8-15-8" class="outline-6">
<h6 id="sec-1-10-8-15-8"><span class="section-number-6">1.10.8.15.8</span> Next</h6>
<div class="outline-text-6" id="text-1-10-8-15-8">




<pre class="src src-C++">virtual void Next() {
  assert(Valid());

  // &#22914;&#26524;&#19981;&#26159;&#27491;&#26041;&#21521;&#30340;&#35805;.&#19981;&#36807;&#35273;&#24471;&#36825;&#20010;&#37096;&#20998;&#20195;&#30721;&#21487;&#33021;&#23384;&#22312;&#38382;&#39064;.
  // &#19981;&#36807;&#20063;&#27809;&#26377;&#26356;&#22909;&#30340;&#35299;&#20915;&#21150;&#27861;&#20102;&#12290;&#25105;&#35273;&#24471;&#36825;&#37324;&#30452;&#25509;assert&#23601;&#22909;&#20102;&#65292;&#19981;&#38656;&#35201;&#35843;&#25972;&#12290;
  // Ensure that all children are positioned after key().
  // If we are moving in the forward direction, it is already
  // true for all of the non-current_ children since current_ is
  // the smallest child and key() == current_-&gt;key().  Otherwise,
  // we explicitly position the non-current_ children.
  if (direction_ != kForward) {
    for (int i = 0; i &lt; n_; i++) {
      IteratorWrapper* child = &amp;children_[i];
      if (child != current_) {
        child-&gt;Seek(key());
        if (child-&gt;Valid() &amp;&amp;
            comparator_-&gt;Compare(key(), child-&gt;key()) == 0) {
          child-&gt;Next();
        }
      }
    }
    direction_ = kForward;
  }
  current_-&gt;Next();
  FindSmallest();
}
</pre>


</div>

</div>

<div id="outline-container-1-10-8-15-9" class="outline-6">
<h6 id="sec-1-10-8-15-9"><span class="section-number-6">1.10.8.15.9</span> Prev</h6>
<div class="outline-text-6" id="text-1-10-8-15-9">




<pre class="src src-C++">virtual void Prev() {
  assert(Valid());

  // &#22914;&#26524;&#19981;&#26159;&#21453;&#26041;&#21521;&#30340;&#35805;.&#19981;&#36807;&#35273;&#24471;&#36825;&#20010;&#37096;&#20998;&#20195;&#30721;&#21487;&#33021;&#23384;&#22312;&#38382;&#39064;.
  // &#19981;&#36807;&#20063;&#27809;&#26377;&#26356;&#22909;&#30340;&#35299;&#20915;&#21150;&#27861;&#20102;&#12290;&#25105;&#35273;&#24471;&#36825;&#37324;&#30452;&#25509;assert&#23601;&#22909;&#20102;&#65292;&#26681;&#26412;&#19981;&#38656;&#35201;&#35843;&#25972;&#12290;
  // Ensure that all children are positioned before key().
  // If we are moving in the reverse direction, it is already
  // true for all of the non-current_ children since current_ is
  // the largest child and key() == current_-&gt;key().  Otherwise,
  // we explicitly position the non-current_ children.
  if (direction_ != kReverse) {
    for (int i = 0; i &lt; n_; i++) {
      IteratorWrapper* child = &amp;children_[i];
      if (child != current_) {
        child-&gt;Seek(key());
        if (child-&gt;Valid()) {
          // Child is at first entry &gt;= key().  Step back one to be &lt; key()
          child-&gt;Prev();
        } else {
          // Child has no entries &gt;= key().  Position at last entry.
          child-&gt;SeekToLast();
        }
      }
    }
    direction_ = kReverse;
  }

  current_-&gt;Prev();
  FindLargest();
}
</pre>


</div>

</div>

<div id="outline-container-1-10-8-15-10" class="outline-6">
<h6 id="sec-1-10-8-15-10"><span class="section-number-6">1.10.8.15.10</span> FindSmallest</h6>
<div class="outline-text-6" id="text-1-10-8-15-10">

<p>从这些Iterator找到最小的Iterator作为current.算法naive.
</p>


<pre class="src src-C++">void MergingIterator::FindSmallest() {
  IteratorWrapper* smallest = NULL;
  for (int i = 0; i &lt; n_; i++) {
    IteratorWrapper* child = &amp;children_[i];
    if (child-&gt;Valid()) {
      if (smallest == NULL) {
        smallest = child;
      } else if (comparator_-&gt;Compare(child-&gt;key(), smallest-&gt;key()) &lt; 0) {
        smallest = child;
      }
    }
  }
  current_ = smallest;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-8-15-11" class="outline-6">
<h6 id="sec-1-10-8-15-11"><span class="section-number-6">1.10.8.15.11</span> FindLargest</h6>
<div class="outline-text-6" id="text-1-10-8-15-11">

<p>从这些Iterator里面找到最大的Iterator作为current.算法naive.
</p>


<pre class="src src-C++">void MergingIterator::FindLargest() {
  IteratorWrapper* largest = NULL;
  for (int i = n_-1; i &gt;= 0; i--) {
    IteratorWrapper* child = &amp;children_[i];
    if (child-&gt;Valid()) {
      if (largest == NULL) {
        largest = child;
      } else if (comparator_-&gt;Compare(child-&gt;key(), largest-&gt;key()) &gt; 0) {
        largest = child;
      }
    }
  }
  current_ = largest;
}
</pre>


</div>
</div>
</div>

</div>

<div id="outline-container-1-10-9" class="outline-4">
<h4 id="sec-1-10-9"><span class="section-number-4">1.10.9</span> Util</h4>
<div class="outline-text-4" id="text-1-10-9">


</div>

<div id="outline-container-1-10-9-1" class="outline-5">
<h5 id="sec-1-10-9-1"><span class="section-number-5">1.10.9.1</span> Arena</h5>
<div class="outline-text-5" id="text-1-10-9-1">

<p>util/arena.h[.cc] arena作为一个局部,对于逻辑来说存在生命周期的内存分配器.所有的内存都在这上面分配然后一次性释放.
</p>


<pre class="src src-C++">class Arena {
 public:
  Arena();
  ~Arena();

  // Return a pointer to a newly allocated memory block of <span style="color: #ffff00;">"bytes"</span> bytes.
  char* Allocate(size_t bytes);

  // Allocate memory with the normal alignment guarantees provided by malloc
  char* AllocateAligned(size_t bytes);

  // Returns an estimate of the total memory usage of data allocated
  // by the arena (including space allocated but not yet used for user
  // allocations).
  size_t MemoryUsage() const { // &#24403;&#21069;&#20998;&#37197;&#20869;&#23384;&#20197;&#21450;std::vector&#20998;&#37197;&#20869;&#23384;.
    return blocks_memory_ + blocks_.capacity() * sizeof(char*);
  }

 private:
  char* AllocateFallback(size_t bytes); // &#22914;&#26524;&#24403;&#21069;&#30340;block&#19981;&#22815;&#20998;&#37197;&#30340;&#35805;&#65292;&#37027;&#20040;&#38656;&#35201;new&#19968;&#20010;&#26032;&#30340;block.
  char* AllocateNewBlock(size_t block_bytes); // new&#26032;&#30340;block&#36923;&#36753;.

  // Allocation state
  char* alloc_ptr_; // &#24403;&#21069;&#20801;&#35768;&#20998;&#37197;&#30340;ptr
  size_t alloc_bytes_remaining_; // &#24403;&#21069;&#36824;&#26377;&#36830;&#32493;&#20869;&#23384;&#22320;&#22336;&#36824;&#26377;&#22810;&#23569;&#27809;&#26377;&#20998;&#37197;&#25481;

  // Array of new[] allocated memory blocks
  std::vector&lt;char*&gt; blocks_; // &#29616;&#22312;&#20998;&#37197;&#20102;&#22810;&#23569;&#36830;&#32493;&#20869;&#23384;&#22320;&#22336;

  // Bytes of memory in blocks allocated so far
  size_t blocks_memory_; // &#24403;&#21069;&#20998;&#37197;&#20102;&#22810;&#23569;&#20869;&#23384;.
};
</pre>

<p>
阅读完了这个接口基本上就能够猜想到怎么实现了.都是基于sample方式的内存分配,每次分配固定大小的block
然后在上面不断地进行切分。但是这里必须确保block内存大小足够大，不然不能够正常分配内存.(dirlt:
不过阅读了后面实现，发现如果超过block的话按照本身大小分配，不会存在问题).
</p>
<p>
还是稍微看看实现吧
</p>


<pre class="src src-C++">inline char* Arena::Allocate(size_t bytes) {
  // The semantics of what to return are a bit messy if we allow
  // 0-byte allocations, so we disallow them here (we don't need
  // them for our internal use).
  assert(bytes &gt; 0);
  if (bytes &lt;= alloc_bytes_remaining_) { // &#26597;&#30475;&#24403;&#21069;&#26159;&#21542;&#21487;&#20197;&#20998;&#37197;.
    char* result = alloc_ptr_;
    alloc_ptr_ += bytes;
    alloc_bytes_remaining_ -= bytes;
    return result;
  }
  return AllocateFallback(bytes);
}

static const int kBlockSize = 4096; // block size&#26159;4K.

Arena::Arena() {
  blocks_memory_ = 0;
  alloc_ptr_ = NULL;  // First allocation will allocate a block
  alloc_bytes_remaining_ = 0;
}

Arena::~Arena() {
  for (size_t i = 0; i &lt; blocks_.size(); i++) {
    delete[] blocks_[i];
  }
}

char* Arena::AllocateFallback(size_t bytes) {
  if (bytes &gt; kBlockSize / 4) { // &#22914;&#26524;&#20998;&#37197;&#36229;&#36807;1K.&#37027;&#20040;&#30452;&#25509;&#20998;&#37197;&#21344;&#29992;.
    // Object is more than a quarter of our block size.  Allocate it separately
    // to avoid wasting too much space in leftover bytes.
    char* result = AllocateNewBlock(bytes);
    return result;
  }

  // We waste the remaining space in the current block.
  alloc_ptr_ = AllocateNewBlock(kBlockSize); // &#21542;&#21017;&#20250;&#20998;&#37197;&#20986;&#26469;&#28982;&#21518;&#22312;&#36825;&#19978;&#38754;&#36827;&#34892;&#20999;&#20998;.
  alloc_bytes_remaining_ = kBlockSize;

  char* result = alloc_ptr_;
  alloc_ptr_ += bytes;
  alloc_bytes_remaining_ -= bytes;
  return result;
}

char* Arena::AllocateAligned(size_t bytes) {
  const int align = sizeof(void*);    // We'll align to pointer size
  assert((align &amp; (align-1)) == 0);   // Pointer size should be a power of 2
  size_t current_mod = reinterpret_cast&lt;uintptr_t&gt;(alloc_ptr_) &amp; (align-1); // &#38656;&#35201;&#32771;&#34385;&#24403;&#21069;&#22320;&#22336;&#26159;&#21542;&#23545;&#20854;.
  size_t slop = (current_mod == 0 ? 0 : align - current_mod);
  size_t needed = bytes + slop; // &#22914;&#26524;&#27809;&#26377;&#23545;&#40784;&#25105;&#20204;&#21487;&#33021;&#38656;&#35201;&#20570;&#30340;&#20559;&#31227;.
  char* result;
  if (needed &lt;= alloc_bytes_remaining_) {
    result = alloc_ptr_ + slop;
    alloc_ptr_ += needed;
    alloc_bytes_remaining_ -= needed;
  } else {
    // AllocateFallback always returned aligned memory
    result = AllocateFallback(bytes);
  }
  assert((reinterpret_cast&lt;uintptr_t&gt;(result) &amp; (align-1)) == 0);
  return result;
}

char* Arena::AllocateNewBlock(size_t block_bytes) {
  char* result = new char[block_bytes];
  blocks_memory_ += block_bytes;
  blocks_.push_back(result);
  return result;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-9-2" class="outline-5">
<h5 id="sec-1-10-9-2"><span class="section-number-5">1.10.9.2</span> Coding</h5>
<div class="outline-text-5" id="text-1-10-9-2">

<p>util/coding.h[.cc] Coding主要是用来完成变长数据以及字符串还有Slice的序列化和反序列化的.主要方法包括下面这些
</p><ul>
<li>PutFixed32 写入定长uint32
</li>
<li>PutFixed64 写入定长uint64
</li>
<li>PutVarint32 写入变长uint32
</li>
<li>PutVarint64 写入变长uint64
</li>
<li>PutLengthPrefixedSlice 后面解释.
</li>
<li>GetVarint32 读取变长uint32
</li>
<li>GetVarint64 读取变长uint64
</li>
<li>GetLengthPrefixedSlice 后面解释.
</li>
<li>GetVarint32Ptr(p,limit,v) 将[p,limit)部分的内存解析为变长uint32放到v里面,返回下一个字节
</li>
<li>GetVarint64Ptr(p,limit,v) 将[p,limit)部分的内存解析为变长uint64放到v里面,返回下一个字节
</li>
<li>VarintLength 变长uint32/uint64长度
</li>
<li>EncodeFixed32 PutFixed32 low-level
</li>
<li>EncodeFixed64 PutFixed64 low-level
</li>
<li>EncodeVarint32 PutVarint32 low-level
</li>
<li>EncodeVarint64 PutVarint64 low-level
</li>
<li>DecodeFixed32 读取定长uint32
</li>
<li>DecodeFixed64 读取定长uint64
</li>
<li>GetVarint32PtrFallback
</li>
<li>GetVarint32Ptr 从[p,limit)读取uint32并且返回下一个字节.
</li>
</ul>


<p>
编码方式有点类似于google::protobuf里面的变长整数打包。我们这里着重看看下面两个函数
</p>


<pre class="src src-C++">void PutLengthPrefixedSlice(std::string* dst, const Slice&amp; value) {
  PutVarint32(dst, value.size());
  dst-&gt;append(value.data(), value.size());
}
bool GetLengthPrefixedSlice(Slice* input, Slice* result) {
  uint32_t len;
  if (GetVarint32(input, &amp;len) &amp;&amp;
      input-&gt;size() &gt;= len) {
    *result = Slice(input-&gt;data(), len);
    input-&gt;remove_prefix(len);
    return true;
  } else {
    return false;
  }
}
</pre>

<p>
PutLengthPrefixedSlice对于slice的存储，首先是放入uint32长度然后放入内容.
GetLengthPrefixedSlice从input首先取出长度，然后取出数据,并且将input跳过这些长度.
</p>
</div>

</div>

<div id="outline-container-1-10-9-3" class="outline-5">
<h5 id="sec-1-10-9-3"><span class="section-number-5">1.10.9.3</span> Histogram</h5>
<div class="outline-text-5" id="text-1-10-9-3">

<p>TODO(dirlt):
</p>
</div>

</div>

<div id="outline-container-1-10-9-4" class="outline-5">
<h5 id="sec-1-10-9-4"><span class="section-number-5">1.10.9.4</span> SkipList</h5>
<div class="outline-text-5" id="text-1-10-9-4">

<p>db/skiplist.h SkipList(跳表)之前在课本上看到过，但是当时觉得实在是没有太大的用途。现在仔细看看吧.
这里的SkipList附带了一个iterator.首先看看SkipList的结构.SkipList对于写的话是需要外部进行同步的，
对于读的话可以是多个读同时发起。
</p>



<pre class="src src-C++">template&lt;typename Key, class Comparator&gt;
class SkipList {
 private:
  struct Node;

 public:
  // Create a new SkipList object that will use <span style="color: #ffff00;">"cmp"</span> for comparing keys,
  // and will allocate memory using <span style="color: #ffff00;">"*arena"</span>.  Objects allocated in the arena
  // must remain allocated for the lifetime of the skiplist object.
  explicit SkipList(Comparator cmp, Arena* arena);

  // Insert key into the list.
  // REQUIRES: nothing that compares equal to key is currently in the list.
  void Insert(const Key&amp; key);

  // Returns true iff an entry that compares equal to key is in the list.
  bool Contains(const Key&amp; key) const;

  // Iteration over the contents of a skip list
  class Iterator {
   public:
    // Initialize an iterator over the specified list.
    // The returned iterator is not valid.
    explicit Iterator(const SkipList* list);

    // Returns true iff the iterator is positioned at a valid node.
    bool Valid() const;

    // Returns the key at the current position.
    // REQUIRES: Valid()
    const Key&amp; key() const;

    // Advances to the next position.
    // REQUIRES: Valid()
    void Next();

    // Advances to the previous position.
    // REQUIRES: Valid()
    void Prev();

    // Advance to the first entry with a key &gt;= target
    void Seek(const Key&amp; target);

    // Position at the first entry in list.
    // Final state of iterator is Valid() iff list is not empty.
    void SeekToFirst();

    // Position at the last entry in list.
    // Final state of iterator is Valid() iff list is not empty.
    void SeekToLast();

   private:
    const SkipList* list_;
    Node* node_;
    // Intentionally copyable
  };

 private:
  enum { kMaxHeight = 12 }; // &#36339;&#34920;&#26368;&#22823;&#39640;&#24230;&#26159;12.

  // Immutable after construction
  Comparator const compare_;
  Arena* const arena_;    // Arena used for allocations of nodes

  Node* const head_;

  // Modified only by Insert().  Read racily by readers, but stale
  // values are ok.
  port::AtomicPointer max_height_;   // Height of the entire list

  inline int GetMaxHeight() const { // &#24403;&#21069;&#26368;&#22823;&#30340;skiplist&#39640;&#24230;.
    return reinterpret_cast&lt;intptr_t&gt;(max_height_.NoBarrier_Load());
  }

  // Read/written only by Insert().
  Random rnd_;

  Node* NewNode(const Key&amp; key, int height);
  int RandomHeight();
  bool Equal(const Key&amp; a, const Key&amp; b) const { return (compare_(a, b) == 0); }

  // Return true if key is greater than the data stored in <span style="color: #ffff00;">"n"</span>
  bool KeyIsAfterNode(const Key&amp; key, Node* n) const;

  // Return the earliest node that comes at or after key.
  // Return NULL if there is no such node.
  //
  // If prev is non-NULL, fills prev[level] with pointer to previous
  // node at <span style="color: #ffff00;">"level"</span> for every level in [0..max_height_-1].
  Node* FindGreaterOrEqual(const Key&amp; key, Node** prev) const;

  // Return the latest node with a key &lt; key.
  // Return head_ if there is no such node.
  Node* FindLessThan(const Key&amp; key) const;

  // Return the last node in the list.
  // Return head_ if list is empty.
  Node* FindLast() const;
};
</pre>



</div>

<div id="outline-container-1-10-9-4-1" class="outline-6">
<h6 id="sec-1-10-9-4-1"><span class="section-number-6">1.10.9.4.1</span> RandomHeight</h6>
<div class="outline-text-6" id="text-1-10-9-4-1">

<p>随机产生一个SkipList的高度.从1开始每次以1/4的概率+1.
</p><ul>
<li>h=1 3/4
</li>
<li>h=2 3/16
</li>
<li>&hellip;
</li>
</ul>

<p>主要就是有这么一个大概的概率就是,随机初始化的高度不会很大.
</p>


<pre class="src src-C++">template&lt;typename Key, class Comparator&gt;
int SkipList&lt;Key,Comparator&gt;::RandomHeight() {
  // Increase height with probability 1 in kBranching
  static const unsigned int kBranching = 4;
  int height = 1;
  while (height &lt; kMaxHeight &amp;&amp; ((rnd_.Next() % kBranching) == 0)) {
    height++;
  }
  assert(height &gt; 0);
  assert(height &lt;= kMaxHeight);
  return height;
}
</pre>


</div>

</div>

<div id="outline-container-1-10-9-4-2" class="outline-6">
<h6 id="sec-1-10-9-4-2"><span class="section-number-6">1.10.9.4.2</span> KeyIsAfterNode</h6>
<div class="outline-text-6" id="text-1-10-9-4-2">

<p>可以认为是key的比较函数吧.拿key和当前某一个node进行比较，看看这个key是否应该存在这个node之后.
</p>


<pre class="src src-C++">template&lt;typename Key, class Comparator&gt;
bool SkipList&lt;Key,Comparator&gt;::KeyIsAfterNode(const Key&amp; key, Node* n) const {
  // NULL n is considered infinite
  return (n != NULL) &amp;&amp; (compare_(n-&gt;key, key) &lt; 0); // &#20869;&#37096;&#30340;comparator.
}
</pre>


</div>

</div>

<div id="outline-container-1-10-9-4-3" class="outline-6">
<h6 id="sec-1-10-9-4-3"><span class="section-number-6">1.10.9.4.3</span> FindGreaterOrEqual</h6>
<div class="outline-text-6" id="text-1-10-9-4-3">

<p>找到和key相当或者是&gt;key的第一个node.对跳表的原理稍微熟悉一些大概就可以看懂代码了.
</p>



<pre class="src src-C++">template&lt;typename Key, class Comparator&gt;
typename SkipList&lt;Key,Comparator&gt;::Node* SkipList&lt;Key,Comparator&gt;::FindGreaterOrEqual(const Key&amp; key, Node** prev)
    const {
  Node* x = head_;
  int level = GetMaxHeight() - 1; // &#25353;&#29031;&#26368;&#39640;&#23618;&#30340;&#36339;&#34920;&#26597;&#25214;
  while (true) {
    Node* next = x-&gt;Next(level);
    if (KeyIsAfterNode(key, next)) { // &#22914;&#26524;key&#22312;&#36825;&#20010;&#21518;&#38754;&#30340;&#35805;,&#37027;&#20040;&#32487;&#32493;&#25353;&#29031;&#36825;&#20010;&#39640;&#24230;.
      // Keep searching in this list
      x = next;
    } else {
      if (prev != NULL) prev[level] = x; // &#35760;&#24405;&#36825;&#20010;prev.
      if (level == 0) { // &#22914;&#26524;&#21040;&#20102;&#26368;&#19979;&#23618;&#30340;&#35805;.
        return next; // &#27880;&#24847;&#36825;&#37324;&#30340;&#36820;&#22238;&#20540;&#19981;&#19968;&#23450;Equal(key)
      } else {
        // Switch to next list
        level--; // &#21542;&#21017;level--.
      }
    }
  }
}
</pre>


</div>

</div>

<div id="outline-container-1-10-9-4-4" class="outline-6">
<h6 id="sec-1-10-9-4-4"><span class="section-number-6">1.10.9.4.4</span> Insert</h6>
<div class="outline-text-6" id="text-1-10-9-4-4">

<p>插入某一个key.恩,逻辑还算是比较简单吧
</p>



<pre class="src src-C++">template&lt;typename Key, class Comparator&gt;
void SkipList&lt;Key,Comparator&gt;::Insert(const Key&amp; key) {
  // TODO(opt): We can use a barrier-free variant of FindGreaterOrEqual()
  // here since Insert() is externally synchronized.
  Node* prev[kMaxHeight];
  Node* x = FindGreaterOrEqual(key, prev); // &#26597;&#25214;&#21040;key&#30340;previous&#30340;&#20869;&#23481;.

  // Our data structure does not allow duplicate insertion
  assert(x == NULL || !Equal(key, x-&gt;key));

  int height = RandomHeight();
  if (height &gt; GetMaxHeight()) { // &#38543;&#26426;&#20135;&#29983;&#39640;&#24230;.(dirlt):&#25105;&#22312;&#24819;&#65292;&#26159;&#19981;&#26159;&#21482;&#26377;&#36825;&#20010;&#22320;&#26041;&#25165;&#20250;&#25913;&#21464;&#39640;&#24230;&#21602;?.
    for (int i = GetMaxHeight(); i &lt; height; i++) {
      prev[i] = head_; // &#22914;&#26524;&#27809;&#26377;&#30340;&#35805;&#65292;&#37027;&#20040;&#21021;&#22987;&#21270;&#20026;head_.
    }
    //fprintf(stderr, <span style="color: #ffff00;">"Change height from %d to %d\n"</span>, max_height_, height);

    // It is ok to mutate max_height_ without any synchronization
    // with concurrent readers.  A concurrent reader that observes
    // the new value of max_height_ will see either the old value of
    // new level pointers from head_ (NULL), or a new value set in
    // the loop below.  In the former case the reader will
    // immediately drop to the next level since NULL sorts after all
    // keys.  In the latter case the reader will use the new node.
    max_height_.NoBarrier_Store(reinterpret_cast&lt;void*&gt;(height));
  }

  x = NewNode(key, height); // &#20135;&#29983;&#19968;&#20010;&#26032;&#30340;&#33410;&#28857;.
  for (int i = 0; i &lt; height; i++) { // &#28982;&#21518;&#25554;&#20837;&#32500;&#25252;&#22909;&#36825;&#20010;&#36339;&#34920;&#32467;&#26500;.
    // NoBarrier_SetNext() suffices since we will add a barrier when
    // we publish a pointer to <span style="color: #ffff00;">"x"</span> in prev[i].
    x-&gt;NoBarrier_SetNext(i, prev[i]-&gt;NoBarrier_Next(i));
    prev[i]-&gt;SetNext(i, x);
  }
}
</pre>


</div>

</div>

<div id="outline-container-1-10-9-4-5" class="outline-6">
<h6 id="sec-1-10-9-4-5"><span class="section-number-6">1.10.9.4.5</span> Contains</h6>
<div class="outline-text-6" id="text-1-10-9-4-5">

<p>Contains用来判断跳表里面是否包含key
</p>



<pre class="src src-C++">template&lt;typename Key, class Comparator&gt;
bool SkipList&lt;Key,Comparator&gt;::Contains(const Key&amp; key) const {
  Node* x = FindGreaterOrEqual(key, NULL);
  if (x != NULL &amp;&amp; Equal(key, x-&gt;key)) {
    return true; // &#22914;&#26524;!=NULL&#24182;&#19988;Equal&#30340;&#35805;&#37027;&#20040;&#36820;&#22238;true.
  } else {
    return false;
  }
}
</pre>


</div>

</div>

<div id="outline-container-1-10-9-4-6" class="outline-6">
<h6 id="sec-1-10-9-4-6"><span class="section-number-6">1.10.9.4.6</span> FindLessThan</h6>
<div class="outline-text-6" id="text-1-10-9-4-6">

<p>查找最后面一个less than key的这个node.
</p>



<pre class="src src-C++">template&lt;typename Key, class Comparator&gt;
typename SkipList&lt;Key,Comparator&gt;::Node*
SkipList&lt;Key,Comparator&gt;::FindLessThan(const Key&amp; key) const {
  Node* x = head_;
  int level = GetMaxHeight() - 1;
  while (true) {
    assert(x == head_ || compare_(x-&gt;key, key) &lt; 0);
    Node* next = x-&gt;Next(level);
    if (next == NULL || compare_(next-&gt;key, key) &gt;= 0) {
      if (level == 0) {
        return x;
      } else {
        // Switch to next list
        level--;
      }
    } else {
      x = next;
    }
  }
}
</pre>


</div>

</div>

<div id="outline-container-1-10-9-4-7" class="outline-6">
<h6 id="sec-1-10-9-4-7"><span class="section-number-6">1.10.9.4.7</span> FindLast</h6>
<div class="outline-text-6" id="text-1-10-9-4-7">

<p>FindLast就是找到元素的最后一个节点.非常简单，首先在最高节点遍历然后不断地降低level遍历.
</p>


<pre class="src src-C++">template&lt;typename Key, class Comparator&gt;
typename SkipList&lt;Key,Comparator&gt;::Node* SkipList&lt;Key,Comparator&gt;::FindLast()
    const {
  Node* x = head_;
  int level = GetMaxHeight() - 1;
  while (true) {
    Node* next = x-&gt;Next(level);
    if (next == NULL) {
      if (level == 0) {
        return x;
      } else {
        // Switch to next list
        level--;
      }
    } else {
      x = next;
    }
  }
}
</pre>


</div>

</div>

<div id="outline-container-1-10-9-4-8" class="outline-6">
<h6 id="sec-1-10-9-4-8"><span class="section-number-6">1.10.9.4.8</span> Node</h6>
<div class="outline-text-6" id="text-1-10-9-4-8">

<p>在看下面的函数之前我们先看看Node的实现.其实非常简单，而且似乎没有必要使用atomic的方式来操作。
因为这里面我们已经要求写需要外部加锁保证了.(dirlt:后来想想还是有必要的,这里我们只是要求用户
在写的时候使用外部同步机保证，而读的时候没有。那么这样必须强制读取内存才可以保证正确,所以这里
需要Acquire_Load以及Release_Load).非常简单，就是持有key以及跳表指针.
</p>



<pre class="src src-C++">template&lt;typename Key, class Comparator&gt;
struct SkipList&lt;Key,Comparator&gt;::Node {
  explicit Node(const Key&amp; k) : key(k) { }

  Key const key;

  // Accessors/mutators for links.  Wrapped in methods so we can
  // add the appropriate barriers as necessary.
  Node* Next(int n) {
    assert(n &gt;= 0);
    // Use an 'acquire load' so that we observe a fully initialized
    // version of the returned Node.
    return reinterpret_cast&lt;Node*&gt;(next_[n].Acquire_Load());
  }
  void SetNext(int n, Node* x) {
    assert(n &gt;= 0);
    // Use a 'release store' so that anybody who reads through this
    // pointer observes a fully initialized version of the inserted node.
    next_[n].Release_Store(x);
  }

  // No-barrier variants that can be safely used in a few locations.
  Node* NoBarrier_Next(int n) {
    assert(n &gt;= 0);
    return reinterpret_cast&lt;Node*&gt;(next_[n].NoBarrier_Load());
  }
  void NoBarrier_SetNext(int n, Node* x) {
    assert(n &gt;= 0);
    next_[n].NoBarrier_Store(x);
  }

 private:
  // Array of length equal to the node height.  next_[0] is lowest level link.
  port::AtomicPointer next_[1]; // &#33267;&#23569;&#26377;&#19968;&#20010;next&#25351;&#38024;.
};
</pre>


</div>

</div>

<div id="outline-container-1-10-9-4-9" class="outline-6">
<h6 id="sec-1-10-9-4-9"><span class="section-number-6">1.10.9.4.9</span> NewNode</h6>
<div class="outline-text-6" id="text-1-10-9-4-9">

<p>前面看完了Node的结构.然后Node分配就非常简单了.这里采用了inplacement new的方式来分配内存
</p>


<pre class="src src-C++">template&lt;typename Key, class Comparator&gt;
typename SkipList&lt;Key,Comparator&gt;::Node*
SkipList&lt;Key,Comparator&gt;::NewNode(const Key&amp; key, int height) {
  char* mem = arena_-&gt;AllocateAligned(
      sizeof(Node) + sizeof(port::AtomicPointer) * (height - 1));
  return new (mem) Node(key);
}
</pre>

<p>
注意这里只需要分配height-1的高度即可，因为在Node里面已经存在了1个链表指针.
</p>
</div>

</div>

<div id="outline-container-1-10-9-4-10" class="outline-6">
<h6 id="sec-1-10-9-4-10"><span class="section-number-6">1.10.9.4.10</span> Iterator</h6>
<div class="outline-text-6" id="text-1-10-9-4-10">

<p>了解了跳表的工作原理之后，对于其遍历器理解就非常简单了。代码也非常简单。但是阅读代码就会发现，
跳表的前向遍历功能不怎么样，因为没有维护prev指针。这里prev的方法是用过调用FindLessThan来实现的。
</p>


<pre class="src src-C++">template&lt;typename Key, class Comparator&gt;
inline SkipList&lt;Key,Comparator&gt;::Iterator::Iterator(const SkipList* list) {
  list_ = list;
  node_ = NULL;
}

template&lt;typename Key, class Comparator&gt;
inline bool SkipList&lt;Key,Comparator&gt;::Iterator::Valid() const {
  return node_ != NULL;
}

template&lt;typename Key, class Comparator&gt;
inline const Key&amp; SkipList&lt;Key,Comparator&gt;::Iterator::key() const {
  assert(Valid());
  return node_-&gt;key;
}

template&lt;typename Key, class Comparator&gt;
inline void SkipList&lt;Key,Comparator&gt;::Iterator::Next() {
  assert(Valid());
  node_ = node_-&gt;Next(0);
}

template&lt;typename Key, class Comparator&gt;
inline void SkipList&lt;Key,Comparator&gt;::Iterator::Prev() {
  // Instead of using explicit <span style="color: #ffff00;">"prev"</span> links, we just search for the
  // last node that falls before key.
  assert(Valid());
  node_ = list_-&gt;FindLessThan(node_-&gt;key); // &#21487;&#33021;&#24615;&#33021;&#20250;&#23384;&#22312;&#38382;&#39064;.&#25152;&#20197;&#26368;&#22909;&#19981;&#35201;&#21069;&#21521;&#36941;&#21382;.
  if (node_ == list_-&gt;head_) {
    node_ = NULL;
  }
}

template&lt;typename Key, class Comparator&gt;
inline void SkipList&lt;Key,Comparator&gt;::Iterator::Seek(const Key&amp; target) {
  node_ = list_-&gt;FindGreaterOrEqual(target, NULL);
}

template&lt;typename Key, class Comparator&gt;
inline void SkipList&lt;Key,Comparator&gt;::Iterator::SeekToFirst() {
  node_ = list_-&gt;head_-&gt;Next(0);
}

template&lt;typename Key, class Comparator&gt;
inline void SkipList&lt;Key,Comparator&gt;::Iterator::SeekToLast() {
  node_ = list_-&gt;FindLast();
  if (node_ == list_-&gt;head_) {
    node_ = NULL;
  }
}
</pre>


</div>
</div>

</div>

<div id="outline-container-1-10-9-5" class="outline-5">
<h5 id="sec-1-10-9-5"><span class="section-number-5">1.10.9.5</span> AtomicPointer</h5>
<div class="outline-text-5" id="text-1-10-9-5">

<p>port/atomic_pointer.h 指针的存取都是原子操作.对于pointer来说，不管是32位还是64位的话都是原子操作的。但是这里必须考虑内存屏障。
对于leveldb还考虑到c++0x的原子操作库cstdatomic本身所提供的功能。我们都看看这个是如何实现的。
</p>
<p>
对于没有cstdatomic并且是x86CPU的话.
</p>


<pre class="src src-C++">// AtomicPointer built using platform-specific MemoryBarrier()

// Gcc on x86
#elif defined(ARCH_CPU_X86_FAMILY) &amp;&amp; defined(__GNUC__)
inline void MemoryBarrier() {
  // See http://gcc.gnu.org/ml/gcc/2003-04/msg01180.html for a discussion on
  // this idiom. Also see http://en.wikipedia.org/wiki/Memory_ordering.
  __asm__ __volatile__(<span style="color: #ffff00;">""</span> : : : <span style="color: #ffff00;">"memory"</span>);
}

#if defined(LEVELDB_HAVE_MEMORY_BARRIER)
class AtomicPointer {
 private:
  void* rep_;
 public:
  AtomicPointer() { }
  explicit AtomicPointer(void* p) : rep_(p) {}
  inline void* NoBarrier_Load() const { return rep_; }
  inline void NoBarrier_Store(void* v) { rep_ = v; }
  inline void* Acquire_Load() const {
    void* result = rep_;
    MemoryBarrier();
    return result;
  }
  inline void Release_Store(void* v) {
    MemoryBarrier();
    rep_ = v;
  }
};
</pre>


<p>
对于有cstdatomic库的话.
</p>


<pre class="src src-C++">#elif defined(LEVELDB_CSTDATOMIC_PRESENT)
class AtomicPointer {
 private:
  std::atomic&lt;void*&gt; rep_;
 public:
  AtomicPointer() { }
  explicit AtomicPointer(void* v) : rep_(v) { }
  inline void* Acquire_Load() const {
    return rep_.load(std::memory_order_acquire); // memory order acquire
  }
  inline void Release_Store(void* v) {
    rep_.store(v, std::memory_order_release); // memory order release.
  }
  inline void* NoBarrier_Load() const {
    return rep_.load(std::memory_order_relaxed); // memory order relaxed.
  }
  inline void NoBarrier_Store(void* v) {
    rep_.store(v, std::memory_order_relaxed);
  }
};
</pre>


</div>

</div>

<div id="outline-container-1-10-9-6" class="outline-5">
<h5 id="sec-1-10-9-6"><span class="section-number-5">1.10.9.6</span> CRC32C</h5>
<div class="outline-text-5" id="text-1-10-9-6">

<p>util/crc32c.cc CRC32C算法实现.注意这里Extend的第一个参数是初始值.
</p>


<pre class="src src-C++">// Return the crc32c of concat(A, data[0,n-1]) where init_crc is the
// crc32c of some string A.  Extend() is often used to maintain the
// crc32c of a stream of data.
extern uint32_t Extend(uint32_t init_crc, const char* data, size_t n);

// Return the crc32c of data[0,n-1]
inline uint32_t Value(const char* data, size_t n) {
  return Extend(0, data, n);
}
</pre>


<p>
后面还有两个函数没有看懂存在的意义，但是本身算法并不麻烦.
</p>


<pre class="src src-C++">static const uint32_t kMaskDelta = 0xa282ead8ul;

// Return a masked representation of crc.
//
// Motivation: it is problematic to compute the CRC of a string that
// contains embedded CRCs.  Therefore we recommend that CRCs stored
// somewhere (e.g., in files) should be masked before being stored.
inline uint32_t Mask(uint32_t crc) {
  // Rotate right by 15 bits and add a constant.
  return ((crc &gt;&gt; 15) | (crc &lt;&lt; 17)) + kMaskDelta;
}

// Return the crc whose masked representation is masked_crc.
inline uint32_t Unmask(uint32_t masked_crc) {
  uint32_t rot = masked_crc - kMaskDelta;
  return ((rot &gt;&gt; 17) | (rot &lt;&lt; 15));
}
</pre>


</div>

</div>

<div id="outline-container-1-10-9-7" class="outline-5">
<h5 id="sec-1-10-9-7"><span class="section-number-5">1.10.9.7</span> Hash</h5>
<div class="outline-text-5" id="text-1-10-9-7">

<p>hash.cc提供了Hash算法，看上去有点类似于murmurhash.
</p>


<pre class="src src-C++">uint32_t Hash(const char* data, size_t n, uint32_t seed) {
  // Similar to murmur hash
  const uint32_t m = 0xc6a4a793;
  const uint32_t r = 24;
  const char* limit = data + n;
  uint32_t h = seed ^ (n * m);

  // Pick up four bytes at a time
  while (data + 4 &lt;= limit) {
    uint32_t w = DecodeFixed32(data);
    data += 4;
    h += w;
    h *= m;
    h ^= (h &gt;&gt; 16);
  }

  // Pick up remaining bytes
  switch (limit - data) {
    case 3:
      h += data[2] &lt;&lt; 16;
      // fall through
    case 2:
      h += data[1] &lt;&lt; 8;
      // fall through
    case 1:
      h += data[0];
      h *= m;
      h ^= (h &gt;&gt; r);
      break;
  }
  return h;
}
</pre>


<p>
之前一直纠结于这个seed应该如何来进行设置。其实现在自己也不知道:(.
在bloom.cc里面使用方式是：
</p>


<pre class="src src-C++">static uint32_t BloomHash(const Slice&amp; key) {
  return Hash(key.data(), key.size(), 0xbc9f1d34);
}
</pre>


</div>

</div>

<div id="outline-container-1-10-9-8" class="outline-5">
<h5 id="sec-1-10-9-8"><span class="section-number-5">1.10.9.8</span> BloomFilterPolicy</h5>
<div class="outline-text-5" id="text-1-10-9-8">

<p>第一次看接口有点混淆。为什么CreateFilter需要将生成的filter追加到dst里面呢?其实我猜想这个完全取决于应用，
可能应用在上层希望将filter的内存统一管理，然后一次释放。使用的时候可以选取某一个slice作为filter.
</p>
<p>
NOTE(dirlt):之前可能对于filter有点错误理解.觉得这个filter没有必要存放在磁盘上而应该全部在内存上面。
但是leveldb会针对若干个data block生成一个filter存放在磁盘上面。如果是这样接口就非常好理解了，
将所有的filter全部聚合在连续的内存上面写入table.
</p>



<pre class="src src-C++">explicit BloomFilterPolicy(int bits_per_key)
    : bits_per_key_(bits_per_key) {
  // &#35745;&#31639;&#20026;&#27599;&#20010;key&#29983;&#25104;&#22810;&#23569;&#20010;probe(&#26816;&#27979;&#28857;).
  // bits_per_key*ln(2)
  // We intentionally round down to reduce probing cost a little bit
  k_ = static_cast&lt;size_t&gt;(bits_per_key * 0.69);  // 0.69 =~ ln(2)
  if (k_ &lt; 1) k_ = 1;
  if (k_ &gt; 30) k_ = 30;
}

virtual void CreateFilter(const Slice* keys, int n, std::string* dst) const {
  // Compute bloom filter size (in both bits and bytes)
  size_t bits = n * bits_per_key_; // &#20998;&#37197;&#22810;&#23569;&#20010;bits.

  // For small n, we can see a very high false positive rate.  Fix it
  // by enforcing a minimum bloom filter length.
  if (bits &lt; 64) bits = 64;

  size_t bytes = (bits + 7) / 8; // &#20570;&#19968;&#20010;round&#28982;&#21518;&#35745;&#31639;&#20998;&#37197;&#22810;&#23569;&#20010;bits.
  bits = bytes * 8;

  const size_t init_size = dst-&gt;size();
  dst-&gt;resize(init_size + bytes, 0); // dst&#21069;&#38754;&#30340;&#37096;&#20998;&#19981;&#21516;&#36861;&#21152;bytes&#23383;&#33410;.
  dst-&gt;push_back(static_cast&lt;char&gt;(k_));  // Remember # of probes in filter // &#23558;&#36825;&#20010;probe&#20010;&#25968;&#35760;&#24405;&#22312;dst&#26411;&#23614;.
  char* array = &amp;(*dst)[init_size]; //
  for (size_t i = 0; i &lt; n; i++) {
    // Use double-hashing to generate a sequence of hash values.
    // See analysis in [Kirsch,Mitzenmacher 2006].
    uint32_t h = BloomHash(keys[i]);
    const uint32_t delta = (h &gt;&gt; 17) | (h &lt;&lt; 15);  // Rotate right 17 bits
    for (size_t j = 0; j &lt; k_; j++) { // &#27599;&#27425;&#20570;key&#20010;&#28857;&#30340;probe.
      const uint32_t bitpos = h % bits;
      array[bitpos/8] |= (1 &lt;&lt; (bitpos % 8));
      h += delta;
    }
  }
}

virtual bool KeyMayMatch(const Slice&amp; key, const Slice&amp; bloom_filter) const {
  const size_t len = bloom_filter.size(); // &#27880;&#24847;&#36825;&#20010;len&#21253;&#21547;&#20102;&#26368;&#21518;&#19968;&#20010;&#23383;&#33410;&#30340;probe.
  // &#21518;&#38754;&#37117;&#38750;&#24120;&#22909;&#29702;&#35299;.
  if (len &lt; 2) return false;

  const char* array = bloom_filter.data();
  const size_t bits = (len - 1) * 8;

  // Use the encoded k so that we can read filters generated by
  // bloom filters created using different parameters.
  const size_t k = array[len-1];
  if (k &gt; 30) {
    // Reserved for potentially new encodings for short bloom filters.
    // Consider it a match.
    return true;
  }

  uint32_t h = BloomHash(key);
  const uint32_t delta = (h &gt;&gt; 17) | (h &lt;&lt; 15);  // Rotate right 17 bits
  for (size_t j = 0; j &lt; k; j++) {
    const uint32_t bitpos = h % bits;
    if ((array[bitpos/8] &amp; (1 &lt;&lt; (bitpos % 8))) == 0) return false;
    h += delta;
  }
  return true;
}
</pre>


</div>
</div>
</div>

</div>

<div id="outline-container-1-11" class="outline-3">
<h3 id="sec-1-11"><span class="section-number-3">1.11</span> Discussion</h3>
<div class="outline-text-3" id="text-1-11">


</div>

<div id="outline-container-1-11-1" class="outline-4">
<h4 id="sec-1-11-1"><span class="section-number-4">1.11.1</span> leveldb通过iterator遍历，对于相同的key如何保证获取到最新的值（hpplinux)</h4>
<div class="outline-text-4" id="text-1-11-1">

<p><b>Question</b>
</p>



<pre class="example">我在看LevelDB代码的时候遇到了一个问题，百思不得其解，也找不到可以探讨请教的人，所以冒昧的给您发了这封邮件，希望得到您的帮助。
我遇到的问题是这样的：
在
void Version::AddIterators(const ReadOptions&amp; options,
                           std::vector&lt;Iterator*&gt;* iters) {
  // Merge all level zero files together since they may overlap
  for (size_t i = 0; i &lt; files_[0].size(); i++) {
    iters-&gt;push_back(
        vset_-&gt;table_cache_-&gt;NewIterator(
            options, files_[0][i]-&gt;number, files_[0][i]-&gt;file_size));
  }
 
  // For levels &gt; 0, we can use a concatenating iterator that sequentially
  // walks through the non-overlapping files in the level, opening them
  // lazily.
  for (int level = 1; level &lt; config::kNumLevels; level++) {
    if (!files_[level].empty()) {
      iters-&gt;push_back(NewConcatenatingIterator(options, level));
    }
  }
}
 
中对于Level 0层是按照下标从0到N开始遍历的， 但是由于数据加入的时候老的文件在前，新的在后，所以这样的话在iters数组中
下标最小的不一定是最新的。
而在DBImpl::NewInternalIterator 中会把该函数的返回结果直接进行merging，而且原则是key相同的话选取丢弃后面出现的。
 
这样的策略的话会不会导致较老的数据被留下，较新的被删除 ？
</pre>



<hr/>

<p>
<b>Answer</b>
</p>
<p>
是这样的，你可以看到AddIterators这个部分是被DBImpl::NewInternalIterator调用的，得到所有的iterators之后，构造一个MergingIterator对象。
</p>



<pre class="src src-C++">// &#23545;&#20110;version&#26469;&#35828;&#21487;&#33021;&#23384;&#22312;&#24456;&#22810;&#25991;&#20214;&#38656;&#35201;&#36941;&#21382;.
versions_-&gt;current()-&gt;AddIterators(options, &amp;list);
// &#23558;&#36825;&#20123;&#20869;&#23481;&#26500;&#36896;&#31216;&#20026;&#19968;&#20010;merge iterator.
// &#27880;&#24847;&#36825;&#37324;&#30340;&#20869;&#23481;&#37117;&#21152;&#20102;&#24341;&#29992;&#35745;&#25968;.
Iterator* internal_iter =
    NewMergingIterator(&amp;internal_comparator_, &amp;list[0], list.size());
</pre>


<p>
注意它这里提供的comparator是一个internal_comparator. 这个comparator不仅仅比较user key, 还比较sequence number. 因为sequence number是顺序分配的，所以新的kv得到更大的sequence number. 代码在这里：
</p>



<pre class="src src-C++">int InternalKeyComparator::Compare(const Slice&amp; akey, const Slice&amp; bkey) const {
  // Order by:
  //    increasing user key (according to user-supplied comparator)
  //    decreasing sequence number
  //    decreasing type (though sequence# should be enough to disambiguate)
  int r = user_comparator_-&gt;Compare(ExtractUserKey(akey), ExtractUserKey(bkey));
  if (r == 0) {
    const uint64_t anum = DecodeFixed64(akey.data() + akey.size() - 8);
    const uint64_t bnum = DecodeFixed64(bkey.data() + bkey.size() - 8);
    if (anum &gt; bnum) { // &#25353;&#29031;sequence number&#27604;&#36739;.
     // &#20043;&#21069;&#25105;&#20204;&#22312;MemTableInserter&#37324;&#38754;&#21487;&#20197;&#30475;&#21040;sequence number&#26159;&#19981;&#26029;&#22686;&#21152;&#30340;.
      r = -1;
    } else if (anum &lt; bnum) {
      r = +1;
    }
  }
  return r;
}

</pre>


<p>
然后这个就好解释问题了。首先每个iterator内部都是按照key做好排序的，多路iterator如果出现相同的key那么使用sequence number大的那个，这样就可以保证始终首先看到的是新值。
</p></div>
</div>
</div>
</div>
</div>

<!-- Baidu Analytics BEGIN --><script type="text/javascript">var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F54a700ad7035f6e485eaf2300641e7e9' type='text/javascript'%3E%3C/script%3E"));</script><!-- Baidu Analytics END --><!-- Google Analytics BEGIN --><script type="text/javascript">  var _gaq = _gaq || [];  _gaq.push(['_setAccount', 'UA-31377772-1']);  _gaq.push(['_trackPageview']);  (function() {    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);  })();</script><!-- Google Analytics END --><!-- Baidu Button BEGIN --><!-- <script type="text/javascript" id="bdshare_js" data="type=tools&amp;uid=6762177" ></script><script type="text/javascript" id="bdshell_js"></script><script type="text/javascript"> document.getElementById("bdshell_js").src = "http://bdimg.share.baidu.com/static/js/shell_v2.js?cdnversion=" + Math.ceil(new Date()/3600000)</script> --><!-- Baidu Button END --><!-- G+ BEGIN --><!-- Place this render call where appropriate --><script type="text/javascript">  (function() {    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;    po.src = 'https://apis.google.com/js/plusone.js';    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);  })();</script><!-- G+ END --><!-- DISQUS BEGIN --><div id="disqus_thread"></div><script type="text/javascript">/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * *//* required: replace example with your forum shortname  */var disqus_shortname = 'dirlt';var disqus_identifier = 'leveldb.html';var disqus_title = 'leveldb.html';var disqus_url = 'http://dirlt.com/leveldb.html';/* * * DON'T EDIT BELOW THIS LINE * * */(function() {var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);})();</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a><!-- DISQUS END --></body>
</html>
