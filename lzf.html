<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>lzf</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="title" content="lzf"/>
<meta name="generator" content="Org-mode"/>
<meta name="author" content="dirtysalt"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  div.inlinetask {
    padding:10px;
    border:2px solid gray;
    margin:10px;
    background: #ffffcc;
  }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style><link rel="shortcut icon" href="css/favicon.ico" /> <link rel="stylesheet" type="text/css" href="css/site.css" />


</head>
<body>

<div id="preamble">

</div>

<div id="content">
<h1 class="title">lzf</h1>

<p><a href="http://oldhome.schmorp.de/marc/liblzf.html">http://oldhome.schmorp.de/marc/liblzf.html</a>
</p>

<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="lzf.html#sec-1">1 Overview</a></li>
<li><a href="lzf.html#sec-2">2 Compress</a></li>
<li><a href="lzf.html#sec-3">3 Decompress</a></li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-3">
<h3 id="sec-1"><span class="section-number-3">1</span> Overview</h3>
<div class="outline-text-3" id="text-1">

<p>这个压缩库非常轻量
</p><ul>
<li>lzf.c 程序入口文件
</li>
<li>lzf.h 接口文件
</li>
<li>lzfP.h 配置文件
</li>
<li>lzf_c.c 压缩
</li>
<li>lzf_d.c 解压缩
</li>
</ul>

<p>其实主要的就是两个文件lzf_c.c和lzf_d.c
</p>
</div>

</div>

<div id="outline-container-2" class="outline-3">
<h3 id="sec-2"><span class="section-number-3">2</span> Compress</h3>
<div class="outline-text-3" id="text-2">




<pre class="example">/*
 * Compress in_len bytes stored at the memory block starting at
 * in_data and write the result to out_data, up to a maximum length
 * of out_len bytes.
 *
 * If the output buffer is not large enough or any error occurs return 0,
 * otherwise return the number of bytes used, which might be considerably
 * more than in_len (but less than 104% of the original size), so it
 * makes sense to always use out_len == in_len - 1), to ensure _some_
 * compression, and store the data uncompressed otherwise (with a flag, of
 * course.
 *
 * lzf_compress might use different algorithms on different systems and
 * even different runs, thus might result in different compressed strings
 * depending on the phase of the moon or similar factors. However, all
 * these strings are architecture-independent and will result in the
 * original data when decompressed using lzf_decompress.
 *
 * The buffers must not be overlapping.
 *
 */
unsigned int
lzf_compress (const void *const in_data,  unsigned int in_len,
              void             *out_data, unsigned int out_len);
</pre>

<ul>
<li>in &amp; out的内存区间不能重叠
</li>
<li>如果out_len不够的话，返回0；否则返回压缩后大小。所以使用上可以out_len = in_len-1. 如果压缩之后空间变大的话那么直接使用原空间
</li>
<li>不同版本lzf压缩同一个数据得到的结果不一定相同，取决于寻找repeatable string方法。但是均可以使用同样的解压缩函数解压。
</li>
</ul>


<p>
压缩数据节(data section)有三种标识 a. literal b. short backref c. long backref.
</p>


<pre class="example">/*
 * compressed format
 *
 * 000LLLLL &lt;L+1&gt;    ; literal, L+1=1..33 octets
 * LLLooooo oooooooo ; backref L+1=1..7 octets, o+1=1..4096 offset
 * 111ooooo LLLLLLLL oooooooo ; backref L+8 octets, o+1=1..4096 offset
 *
 */
</pre>


<p>
配置文件中最重要的几个参数有：
</p><ul>
<li>HLOG # 用于查找repeatable string的hashtable大小. 1 &lt;&lt; HLOG
</li>
<li>VERY_FAST / ULTRA_FAST # 控制查找repeatble string策略
</li>
<li>LZF_USE_OFFSETS # 决定hashtable存储偏移还是存储pointer. 为了方便阅读代码，这里我们假设存储偏移。
<ul>
<li>define LZF_HSLOT_BIAS ((const u8 *)in_data)
</li>
<li>typedef unsigned int LZF_HSLOT;
</li>
<li>typedef LZF_HSLOT LZF_STATE[1 &lt;&lt; (HLOG)]; # hashtable定义
</li>
</ul>

</li>
<li>STRICT_ALIGN # input数据是否对齐
</li>
</ul>


<p>
压缩函数其实不长，所以这里我把代码稍作整理全部贴出来，然后附上相关注释
</p>


<pre class="src src-C++">#ifndef FRST
# define FRST(p) (((p[0]) &lt;&lt; 8) | p[1])
# define NEXT(v,p) (((v) &lt;&lt; 8) | p[2])
// &#21306;&#21035;&#22312;&#20110;&#20351;&#29992;hash&#20989;&#25968;&#19981;&#21516;. &#26222;&#36890;&#27169;&#24335;&#19979;&#36816;&#31639;&#37327;&#26356;&#22810;&#20294;&#26159;&#22343;&#21248;&#25928;&#26524;&#24212;&#35813;&#20250;&#26356;&#22909;
# if ULTRA_FAST
#  define IDX(h) ((( h             &gt;&gt; (3*8 - HLOG)) - h  ) &amp; (HSIZE - 1))
# elif VERY_FAST
#  define IDX(h) ((( h             &gt;&gt; (3*8 - HLOG)) - h*5) &amp; (HSIZE - 1))
# else
#  define IDX(h) ((((h ^ (h &lt;&lt; 5)) &gt;&gt; (3*8 - HLOG)) - h*5) &amp; (HSIZE - 1))
# endif
#endif

// literal&#26368;&#22823;&#38271;&#24230;
#define        MAX_LIT        (1 &lt;&lt;  5)
// offset&#26368;&#22823;&#38271;&#24230;
#define        MAX_OFF        (1 &lt;&lt; 13)
// ref&#26368;&#22823;&#38271;&#24230;. &#30475;long backref&#23450;&#20041;&#26159;L+8 ocets. &#32780;L&#26368;&#38271;&#21487;&#20197;&#26159;8bits.
#define        MAX_REF        ((1 &lt;&lt; 8) + (1 &lt;&lt; 3))

unsigned int
lzf_compress (const void *const in_data, unsigned int in_len,
              void *out_data, unsigned int out_len
              )
{
    LZF_STATE htab;
    const u8 *ip = (const u8 *)in_data;
    u8 *op = (u8 *)out_data;
    const u8 *in_end  = ip + in_len;
    u8 *out_end = op + out_len;
    const u8 *ref;

    unsigned long off;
    unsigned int hval;
    int lit;

    if (!in_len || !out_len)
        return 0;

    memset (htab, 0, sizeof (htab)); // &#21021;&#22987;&#21270;hashtable.

    lit = 0; op++; /* start run */ // &#36825;&#37324;&#31354;&#20986;1&#23383;&#33410;&#26159;&#20026;&#20102;&#22788;&#29702;literal.

    hval = FRST (ip);
    while (ip &lt; in_end - 2)
    {
        LZ_HSLOT *hslot;

        hval = NEXT (hval, ip); // &#27492;&#26102;hval = (ip[-1] &lt;&lt; 24) | (ip[0] &lt;&lt; 16) | (ip[1] &lt;&lt; 8) | ip[2].
        hslot = htab + IDX (hval);
        // &#28982;&#21518;&#26597;&#25214;hashtable&#26159;&#21542;&#23384;&#22312;&#28508;&#22312;&#30456;&#21516;&#30340;&#20018;&#65292;&#35760;&#20026;ref; &#21516;&#26102;&#26356;&#26032;hashtable&#36825;&#20010;entry&#20026;ip.
        // &#36825;&#37324;&#26356;&#26032;hashtable entry&#38750;&#24120;&#37325;&#35201;&#65292;&#22240;&#20026;offset&#26159;&#26377;&#38480;&#21046;&#30340;&#12290;&#22914;&#26524;&#19981;&#26356;&#26032;&#30340;&#35805;&#65292;&#37027;&#20040;&#36229;&#36807;offset&#38271;&#24230;&#38480;&#21046;&#30340;&#20018;
        // &#20415;&#19981;&#33021;&#34987;&#21305;&#37197;&#20197;&#21450;&#21387;&#32553;&#20102;&#12290;
        ref = *hslot + LZF_HSLOT_BIAS; *hslot = ip - LZF_HSLOT_BIAS;

        if (1
            &amp;&amp; ref &lt; ip /* the next test will actually take care of this, but this is faster */
            // &#36825;&#37324;&#30495;&#23454;&#20559;&#31227;&#26159;(off+1). &#20294;&#26159;&#21482;&#23384;&#20648;off.(see backref)
            &amp;&amp; (off = ip - ref - 1) &lt; MAX_OFF
            &amp;&amp; ref &gt; (u8 *)in_data
            // &#26816;&#26597;ref&#21644;ip&#22836;&#19977;&#20010;&#23383;&#33410;&#26159;&#21542;&#30456;&#21516;. &#33267;&#23569;3&#20010;&#23383;&#33410;&#25165;&#20250;&#21387;&#32553;
            &amp;&amp; ref[2] == ip[2]
#if STRICT_ALIGN
            &amp;&amp; ((ref[1] &lt;&lt; 8) | ref[0]) == ((ip[1] &lt;&lt; 8) | ip[0])
#else
            &amp;&amp; *(u16 *)ref == *(u16 *)ip
#endif
            )
        {
            /* match found at *ref++ */
            unsigned int len = 2;
            unsigned int maxlen = in_end - ip - len;
            // &#26368;&#38271;&#21487;&#20197;ref&#22810;&#23569;&#23383;&#33410;
            maxlen = maxlen &gt; MAX_REF ? MAX_REF : maxlen;

            // &#20445;&#23432;&#20272;&#35745;&#33267;&#23569;3&#20010;&#23383;&#33410;(long backref). &#36825;&#37324;+1&#20026;&#19979;&#19968;&#36718;&#26597;&#25214;literal&#20934;&#22791;
            if (expect_false (op + 3 + 1 &gt;= out_end)) /* first a faster conservative test */
                if (op - !lit + 3 + 1 &gt;= out_end) /* second the exact but rare test */
                    return 0;

            // &#23558;&#20043;&#21069;&#30340;literal flush&#20986;&#26469;&#12290;&#36825;&#20010;&#21518;&#38754;&#20250;&#32473;&#20986;&#35299;&#37322;&#20026;&#20160;&#20040;&#21487;&#20197;&#36825;&#20040;&#20570;
            op [- lit - 1] = lit - 1; /* stop run */
            op -= !lit; /* undo run if length is zero */

            for (;;)
            {
                if (expect_true (maxlen &gt; 16))
                {
                    len++; if (ref [len] != ip [len]) break;
                    len++; if (ref [len] != ip [len]) break;
                    len++; if (ref [len] != ip [len]) break;
                    len++; if (ref [len] != ip [len]) break;

                    len++; if (ref [len] != ip [len]) break;
                    len++; if (ref [len] != ip [len]) break;
                    len++; if (ref [len] != ip [len]) break;
                    len++; if (ref [len] != ip [len]) break;

                    len++; if (ref [len] != ip [len]) break;
                    len++; if (ref [len] != ip [len]) break;
                    len++; if (ref [len] != ip [len]) break;
                    len++; if (ref [len] != ip [len]) break;

                    len++; if (ref [len] != ip [len]) break;
                    len++; if (ref [len] != ip [len]) break;
                    len++; if (ref [len] != ip [len]) break;
                    len++; if (ref [len] != ip [len]) break;
                }

                do
                    len++;
                while (len &lt; maxlen &amp;&amp; ref[len] == ip[len]);

                break;
            }
            // ip&#21644;ref&#20844;&#20849;&#20018;&#38271;&#24230;&#20026;len - 1.(&#27604;&#36739;tricky, &#38656;&#35201;&#32771;&#34385;&#19968;&#19979;)
            // &#27880;&#24847;&#36825;&#37324;&#22914;&#26524;ip&#21644;ref&#23384;&#22312;overlapping&#20063;&#27809;&#26377;&#20219;&#20309;&#38382;&#39064;

            len -= 2; /* len is now #octets - 1 */
            ip++;

            if (len &lt; 7) // short backref
            {
                *op++ = (off &gt;&gt; 8) + (len &lt;&lt; 5);
            }
            else // long backref.
            {
                *op++ = (off &gt;&gt; 8) + (  7 &lt;&lt; 5);
                *op++ = len - 7;
            }

            *op++ = off;

            // &#33267;&#27492;&#19968;&#36718;repeatable string&#26597;&#25214;&#23436;&#27605;&#12290;&#20026;&#19979;&#19968;&#36718;literal&#20934;&#22791;.
            lit = 0; op++; /* start run */

            // &#36755;&#20837;&#20018;&#21521;&#21069;&#21069;&#36827;len+1&#23383;&#33410;
            ip += len + 1;

            if (expect_false (ip &gt;= in_end - 2))
                break;

            // &#22914;&#26524;&#26159;ULTRA_FAST&#22238;&#36864;&#19968;&#20010;&#23383;&#33410;&#20570;&#32034;&#24341;
            // &#22914;&#26524;&#26159;VERY FAST&#22238;&#36864;&#20004;&#20010;&#23383;&#33410;
            // &#26222;&#36890;&#27169;&#24335;&#30340;&#35805;&#20250;&#23545;&#36825;&#19968;&#20010;&#36755;&#20837;&#20018;&#20570;&#32034;&#24341;
#if ULTRA_FAST || VERY_FAST
            --ip;
# if VERY_FAST &amp;&amp; !ULTRA_FAST
            --ip;
# endif
            hval = FRST (ip);

            hval = NEXT (hval, ip);
            htab[IDX (hval)] = ip - LZF_HSLOT_BIAS;
            ip++;

# if VERY_FAST &amp;&amp; !ULTRA_FAST
            hval = NEXT (hval, ip);
            htab[IDX (hval)] = ip - LZF_HSLOT_BIAS;
            ip++;
# endif
#else
            ip -= len + 1;

            do
            {
                hval = NEXT (hval, ip);
                htab[IDX (hval)] = ip - LZF_HSLOT_BIAS;
                ip++;
            }
            while (len--);
#endif
        }
        else // &#22914;&#26524;&#27809;&#26377;&#25214;&#21040;&#20844;&#20849;&#20018;&#30340;&#35805;&#37027;&#20040;&#36755;&#20986;literal.
        {
            /* one more literal byte we must copy */
            if (expect_false (op &gt;= out_end))
                return 0;

            lit++; *op++ = *ip++;

            // &#21518;&#38754;&#20250;&#35762;&#35299;literal&#26159;&#24590;&#20040;&#22788;&#29702;&#30340;
            if (expect_false (lit == MAX_LIT))
            {
                op [- lit - 1] = lit - 1; /* stop run */
                lit = 0; op++; /* start run */
            }
        }
    }

    if (op + 3 &gt; out_end) /* at most 3 bytes can be missing here */
        return 0;

    // &#22914;&#26524;&#21097;&#20313;&#20018;&#24456;&#30701;&#30340;&#35805;&#37027;&#20040;&#36890;&#29992;&#25353;&#29031;literal&#26469;&#22788;&#29702;&#12290;
    while (ip &lt; in_end)
    {
        lit++; *op++ = *ip++;

        if (expect_false (lit == MAX_LIT))
        {
            op [- lit - 1] = lit - 1; /* stop run */
            lit = 0; op++; /* start run */
        }
    }

    op [- lit - 1] = lit - 1; /* end run */
    op -= !lit; /* undo run if length is zero */

    return op - (u8 *)out_data;
}
</pre>


<p>
literal处理比较有趣，大致方式如下
</p><ul>
<li>"lit = 0; op++". # 因为literal需要一个额外字节，这里op++空出一个字节
</li>
<li>可是有时候lit=0就退出了，这个时候op最后一个字节是废弃的，所以有"op -= !lit".
</li>
<li>当lit == MAX_LIT的时候或者是flush时候（假设lit!=0. lit=0的情况上面分析过了). 比如lit = 3
<ul>
<li>"op[-lit-1] = lit-1" 就是 "op[-4] = 2"
</li>
<li>op[-4]是literal开头的字节，而2+1则是literal长度
</li>
</ul>

</li>
</ul>


</div>

</div>

<div id="outline-container-3" class="outline-3">
<h3 id="sec-3"><span class="section-number-3">3</span> Decompress</h3>
<div class="outline-text-3" id="text-3">

<p>相对于压缩函数，解压缩函数就没有那么多策略，完全是数据驱动。同样我把代码稍作整理添加少注释
</p>



<pre class="src src-C++">// intel&#26377;rep movsb&#25351;&#20196;&#29992;&#26469;&#20570;memcpy. &#20043;&#21069;&#20570;&#36807;&#23454;&#39564;&#21457;&#29616;&#25928;&#26524;&#24182;&#19981;&#29702;&#24819;
#if USE_REP_MOVSB /* small win on amd, big loss on intel */
#if (__i386 || __amd64) &amp;&amp; __GNUC__ &gt;= 3
# define lzf_movsb(dst, src, len)               \
    asm (<span class="org-string">"rep movsb"</span>                            \
         : <span class="org-string">"=D"</span> (dst), <span class="org-string">"=S"</span> (src), <span class="org-string">"=c"</span> (len)   \
         :  <span class="org-string">"0"</span> (dst),  <span class="org-string">"1"</span> (src),  <span class="org-string">"2"</span> (len));
#endif
#endif

unsigned int
lzf_decompress (const void *const in_data,  unsigned int in_len,
                void             *out_data, unsigned int out_len)
{
    u8 const *ip = (const u8 *)in_data;
    u8       *op = (u8 *)out_data;
    u8 const *const in_end  = ip + in_len;
    u8       *const out_end = op + out_len;

    do
    {
        unsigned int ctrl = *ip++;

        if (ctrl &lt; (1 &lt;&lt; 5)) /* literal run */
        {
            ctrl++;

            if (op + ctrl &gt; out_end)
            {
                SET_ERRNO (E2BIG);
                return 0;
            }

#ifdef lzf_movsb
            lzf_movsb (op, ip, ctrl);
#else
            switch (ctrl)
            {
                case 32: *op++ = *ip++; case 31: *op++ = *ip++; case 30: *op++ = *ip++; case 29: *op++ = *ip++;
                case 28: *op++ = *ip++; case 27: *op++ = *ip++; case 26: *op++ = *ip++; case 25: *op++ = *ip++;
                case 24: *op++ = *ip++; case 23: *op++ = *ip++; case 22: *op++ = *ip++; case 21: *op++ = *ip++;
                case 20: *op++ = *ip++; case 19: *op++ = *ip++; case 18: *op++ = *ip++; case 17: *op++ = *ip++;
                case 16: *op++ = *ip++; case 15: *op++ = *ip++; case 14: *op++ = *ip++; case 13: *op++ = *ip++;
                case 12: *op++ = *ip++; case 11: *op++ = *ip++; case 10: *op++ = *ip++; case  9: *op++ = *ip++;
                case  8: *op++ = *ip++; case  7: *op++ = *ip++; case  6: *op++ = *ip++; case  5: *op++ = *ip++;
                case  4: *op++ = *ip++; case  3: *op++ = *ip++; case  2: *op++ = *ip++; case  1: *op++ = *ip++;
            }
#endif
        }
        else /* back reference */
        {
            unsigned int len = ctrl &gt;&gt; 5;

            u8 *ref = op - ((ctrl &amp; 0x1f) &lt;&lt; 8) - 1;

            if (len == 7)
            {
                len += *ip++;
            }

            ref -= *ip++;

            if (op + len + 2 &gt; out_end)
            {
                SET_ERRNO (E2BIG);
                return 0;
            }

            if (ref &lt; (u8 *)out_data)
            {
                SET_ERRNO (EINVAL);
                return 0;
            }

#ifdef lzf_movsb
            len += 2;
            lzf_movsb (op, ref, len);
#else
            switch (len)
            {
                default:
                    len += 2;
                    // &#22788;&#29702;ip&#21644;ref&#20844;&#20849;&#20018;&#23384;&#22312;overlapping&#30340;&#24773;&#20917;
                    if (op &gt;= ref + len)
                    {
                        /* disjunct areas */
                        memcpy (op, ref, len);
                        op += len;
                    }
                    else
                    {
                        /* overlapping, use octte by octte copying */
                        do
                            *op++ = *ref++;
                        while (--len);
                    }

                    break;

                case 9: *op++ = *ref++;
                case 8: *op++ = *ref++;
                case 7: *op++ = *ref++;
                case 6: *op++ = *ref++;
                case 5: *op++ = *ref++;
                case 4: *op++ = *ref++;
                case 3: *op++ = *ref++;
                case 2: *op++ = *ref++;
                case 1: *op++ = *ref++;
                case 0: *op++ = *ref++; /* two octets more */
                    *op++ = *ref++;
            }
#endif
        }
    }
    while (ip &lt; in_end);

    return op - (u8 *)out_data;
}
</pre>

</div>
</div>
</div>

<div id="postamble">
<p class="creator"><a href="http://orgmode.org">Org</a> version 7.9.3f with <a href="http://www.gnu.org/software/emacs/">Emacs</a> version 24</p>

</div>
<!-- BA BEGIN --><script>var _hmt = _hmt || [];(function() {  var hm = document.createElement("script");  hm.src = "//hm.baidu.com/hm.js?4f82bfcb8e6f2283f7e7eebae990bc80";  var s = document.getElementsByTagName("script")[0];  s.parentNode.insertBefore(hm, s);})();</script><!-- BA END --><!-- DISQUS BEGIN --><div id="disqus_thread"></div><script type="text/javascript">/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * *//* required: replace example with your forum shortname  */var disqus_shortname = 'dirlt';var disqus_identifier = 'lzf.html';var disqus_title = 'lzf.html';var disqus_url = 'http://dirlt.com/lzf.html';/* * * DON'T EDIT BELOW THIS LINE * * */(function() {var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);})();</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a><!-- DISQUS END --></body>
</html>
