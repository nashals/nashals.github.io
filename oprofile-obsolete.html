<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>OProfile(obsolete)</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="title" content="OProfile(obsolete)"/>
<meta name="generator" content="Org-mode"/>
<meta name="author" content="dirtysalt"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  div.inlinetask {
    padding:10px;
    border:2px solid gray;
    margin:10px;
    background: #ffffcc;
  }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style><link rel="shortcut icon" href="css/favicon.ico" /> <link rel="stylesheet" type="text/css" href="css/site.css" />


</head>
<body>

<div id="preamble">

</div>

<div id="content">
<h1 class="title">OProfile(obsolete)</h1>

<p>#note@2014-05-08: 最后更新时间还是2003-07-08. 项目应该已经废弃了。
</p>
<p>
#note@2015-08-01: 最后更新时间居然变为了2014-09-11, 然后1.0.0版本发布。但是使用方式和之前版本有非常大的变化。打算 <a href="oprofile.html">单开一个文档</a> 来记录新版本是如何使用的。
</p>
<ul>
<li>Homepage <a href="http://oprofile.sourceforge.net/news/">http://oprofile.sourceforge.net/news/</a>
</li>
<li>Documentation <a href="http://oprofile.sourceforge.net/doc/index.html">http://oprofile.sourceforge.net/doc/index.html</a>
</li>
<li>AMD Family 10 Events <a href="http://oprofile.sourceforge.net/docs/amd-family10-events.php">http://oprofile.sourceforge.net/docs/amd-family10-events.php</a>
</li>
</ul>



<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="oprofile-obsolete.html#sec-1">1 Overview</a>
<ul>
<li><a href="oprofile-obsolete.html#sec-1-1">1.1 内核驱动</a></li>
<li><a href="oprofile-obsolete.html#sec-1-2">1.2 守护进程</a></li>
<li><a href="oprofile-obsolete.html#sec-1-3">1.3 工具附件</a></li>
</ul>
</li>
<li><a href="oprofile-obsolete.html#sec-2">2 Getting Started</a></li>
<li><a href="oprofile-obsolete.html#sec-3">3 Notes</a>
<ul>
<li><a href="oprofile-obsolete.html#sec-3-1">3.1 opcontrol</a></li>
<li><a href="oprofile-obsolete.html#sec-3-2">3.2 opreport</a></li>
<li><a href="oprofile-obsolete.html#sec-3-3">3.3 opannotate</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-3">
<h3 id="sec-1"><span class="section-number-3">1</span> Overview</h3>
<div class="outline-text-3" id="text-1">

<p><a href="http://www.ibm.com/developerworks/cn/linux/l-oprof/">http://www.ibm.com/developerworks/cn/linux/l-oprof/</a>
</p>
<p>
oprofile是用于Linux的若干种评测和性能监控工具中的一种。它可以工作在不同的体系结构上，包括IA32,IA64和AMD Athlon系列。它的开销小，将被包含在(Linux)2.6版的内核中。
</p>
<p>
oprofile可以帮助用户识别诸如循环的展开、高速缓存的使用率低、低效的类型转换和冗余操作、错误预测转移等问题。它收集有关处理器事件的信息，其中包括TLB的故障、停机、存储器访问、位于 DCU(数据高速缓存单元)中的总线路数、一个 DCU 故障的周期数，以及不可高速缓存的和可高速缓存的指令的获取数量。oprofile是一种细粒度的工具，可以为指令集或者为函数、系统调用或中断处理例程收集采样。oprofile通过取样来工作。使用收集到的评测数据，用户可以很容易地找出性能问题。
</p>
<p>
oprofile由下面三个部分组成
</p>

</div>

<div id="outline-container-1-1" class="outline-4">
<h4 id="sec-1-1"><span class="section-number-4">1.1</span> 内核驱动</h4>
<div class="outline-text-4" id="text-1-1">

<p>内核驱动工作的时候分为三种模式：
</p><ul>
<li>硬件事件计数器模式
</li>
<li>RTC模式
</li>
<li>TimeInterrupt模式
</li>
</ul>


<p>
关于RTC模式和TimeInterrupt模式之间的差别并不是非常了解。RTC(RealTimeClock)和TimeInterrupt模式工作方式，大致都是在底层开启一个定时器并且定时触发中断，然后知道当时PC的位置，然后把这段时间都作为这条PC所执行的时间。定位相对来说粗糙的，但是对于大部分的情况都是管用的。但是如果执行代码部分是屏蔽了中断的话，那么实际上这个部分是不会被profile的。
</p>
<p>
硬件事件计数器模式需要CPU的支持。CPU内部维护一系列事件计数器。Profile针对某些事件把计数器设置为初始值比如C，然后一旦操作触发事件的话,那么计数器就会&ndash;。一旦计数器变为0的话，CPU内部就会触发一个不可屏蔽的中断(NMI/Non Maskable Interrupt)。这个时候我们了解到PC在什么位置，就把这条指令作为触发这个时间的指令。需要注意的是,如果计数器的C设置非常低的话,那么产生NMI就会非常频繁。这样会导致overhead过高，系统非常不稳定。使用硬件事件计数器的话，需要CPU开启APIC这个选项，否则允许指定参数的得不到采样结果。
</p>
<p>
上面三种模式都是基于采样的方式，理论上说采样方式得到的结果并不准确，但是实际工作很好。还需要注意就是，陷入中断时刻和发出中断时刻会存在一些误差，在这段时间内指令还在运行。也就是说发出中断之后，CPU可能继续执行了后面几条指令之后，才陷入中断得到的PC值就是不准确的。
</p>
<p>
&gt;&gt;&gt; Linux Kernel Development
</p>
<p class="verse">
实时时钟(RTC)是用来持久存放系统时间的设备, 即便系统关闭后, 它也可以靠主板上的微型电池提供的电力保持系统的计时. 在PC体系结构中, RTC和CMOS集成在一起, 而且RTC的运行和BIOS的保存设置都是通过同一个电池供电的.<br/>
<br/>
当系统启动时, 内核通过读取RTC来初始化墙上的时钟, 该时间存放在xtime变量中. 虽然内核通常不会在系统启动后再读取xtime变量, 但是有些体系结构(比如x86)会周期性地将当前时间存回RTC中. 尽管如此, 实时时钟主要作用仍是在启动时初始化xtime变量.<br/>
</p>



</div>

</div>

<div id="outline-container-1-2" class="outline-4">
<h4 id="sec-1-2"><span class="section-number-4">1.2</span> 守护进程</h4>
<div class="outline-text-4" id="text-1-2">

<p>守护进程(daemon)用于收集内核驱动采样数据，并且将采样数据dump到外部文件。对应的可执行程序是bin/oprofiled.
</p>
</div>

</div>

<div id="outline-container-1-3" class="outline-4">
<h4 id="sec-1-3"><span class="section-number-4">1.3</span> 工具附件</h4>
<div class="outline-text-4" id="text-1-3">

<p>通过读取dump出来的外部文件得到采样数据进行加工：
</p><ul>
<li>ophelp //显示帮助信息
</li>
<li>opcontrol //oprofile控制程序
</li>
<li>opreport //产生报表信息
</li>
<li>opannotate //annotate代码，包括源代码和汇编代码
</li>
</ul>


</div>
</div>

</div>

<div id="outline-container-2" class="outline-3">
<h3 id="sec-2"><span class="section-number-3">2</span> Getting Started</h3>
<div class="outline-text-3" id="text-2">

<ul>
<li>Installation <a href="http://oprofile.sourceforge.net/doc/install.html">http://oprofile.sourceforge.net/doc/install.html</a>
</li>
<li>Requirement <a href="http://oprofile.sourceforge.net/doc/requirements.html">http://oprofile.sourceforge.net/doc/requirements.html</a>
</li>
</ul>


<p>
如果不是2.6以及以上版本Linux内核的话，那么必须提供源代码树来编译出oprofile驱动。
</p>


<pre class="example">./configure --prefix=&lt;install-dir&gt; --with-linux=&lt;linux-source-code-root&gt;
</pre>


<p>
如果是2.6以及以上版本Linux内核的话，那么可以使用不需要源代码
</p>


<pre class="example">./configure --prefix=&lt;install-dir&gt; --with-kernel-support
</pre>

<p>
因为这些版本的Linux内核已经自带了oprofile驱动。
</p>
<p>
使用步骤非常简单，大致如下：
</p><ul>
<li>使用opcontrol启动daemon并且开始采样
</li>
<li>执行应用程序
</li>
<li>使用opcontrol dump出剖分数据
</li>
<li>使用opcontrol停止采样并且关闭daemon程序
</li>
<li>使用opreport和opannotate查看结果
</li>
<li>#note: 使用oprofile需要root权限
</li>
</ul>


<p>
之前写过一个脚本来包装整个过程。只用它来对应用程序做过profile, 没有对kernel做过profile. 脚本会：
</p><ul>
<li>生成profile汇总报表
</li>
<li>对源代码进行标注
</li>
<li>对汇编代码进行标注
</li>
</ul>




<pre class="src src-Shell"># deprecated !!!
easy_oprofile() {
    if [ $# -lt 5 ]; then
        echo <span class="org-string">"easy_oprofile image-file(ELF) command"</span>
        exit 1
    fi
    local ifile=$1; shift
    local rfile=<span class="org-string">"oprof.rpt"</span>
    local srcdir=<span class="org-string">"."</span>
    local afile=<span class="org-string">"oprof.asm"</span>
    local command=$@
    echo <span class="org-string">"Image file: $ifile"</span>
    echo <span class="org-string">"Report file: $rfile"</span>
    echo <span class="org-string">"Source directory: $srcdir"</span>
    echo <span class="org-string">"Assembly file: $afile"</span>
    echo <span class="org-string">"Command: $command"</span>

    sudo opcontrol --reset
    sudo opcontrol --no-vmlinux --separate=lib --start --image=$ifile
    $command
    sudo opcontrol --dump
    sudo opcontrol --shutdown
    sudo opreport -l image:$ifile -o $rfile
    sudo opannotate -s --output-dir=$srcdir $ifile
    sudo opannotate -a $ifile &gt; $afile
}
</pre>


</div>

</div>

<div id="outline-container-3" class="outline-3">
<h3 id="sec-3"><span class="section-number-3">3</span> Notes</h3>
<div class="outline-text-3" id="text-3">


</div>

<div id="outline-container-3-1" class="outline-4">
<h4 id="sec-3-1"><span class="section-number-4">3.1</span> opcontrol</h4>
<div class="outline-text-4" id="text-3-1">

<p>常用命令参数如下：
</p><ul>
<li>&ndash;reset # 清除session数据
</li>
<li>&ndash;no-vmlinux|&ndash;vmlinux=/boot/vmlinux-2.6.9.2_9-0-0-0 # 选择内核镜像剖分内核
</li>
<li>&ndash;deinit # 卸载oprofile device driver
</li>
<li>&ndash;init # 加载oprofile device driver
</li>
<li>&ndash;setup # 设置oprofile默认参数，保存在/root/.oprofile/daemonrc下面
</li>
<li>&ndash;status # 显示配置信息
</li>
<li>&ndash;start-daemon # 启动daemon程序
</li>
<li>&ndash;shutdown # 停止采样并且关闭daemon程序
</li>
<li>&ndash;start # 启动daemon程序并且开始采样
</li>
<li>&ndash;stop # 停止采样
</li>
<li>&ndash;dump # 控制daemon程序dump所收集的sample数据
</li>
<li>&ndash;list-event # 显示所支持事件
</li>
<li>&ndash;help # 帮助
</li>
<li>&ndash;buffer-size|&ndash;buffer-watershed|&ndash;cpu-buffer-size=&lt;size&gt; # 内核采样sample的buffer大小
</li>
<li>&ndash;event=&lt;eventspec&gt; # 设置采样事件，可以指定多次
</li>
<li>&ndash;separate=none|lib|kernel|cpu|all # 剖分信息划分(none)
<ul>
<li>none # 按照应用程序划分
</li>
<li>lib # 按照library划分
</li>
<li>kernel # 按照内核态和用户态划分
</li>
<li>thread # 按照每个线程划分
</li>
<li>cpu # 按照每个CPU划分
</li>
<li>all # 按照上面所有都划分
</li>
</ul>

</li>
<li>&ndash;image=image,[image]|"all" # 只profile某些特定的binary
</li>
<li>&ndash;session-dir=&lt;dir&gt; # 存放session目录(/var/lib/oprofile)
</li>
<li>&ndash;save=&lt;session-name&gt; # 保存session
</li>
</ul>


<p>
常用用法如下：
</p><ul>
<li>opcontrol &ndash;reset # 清除之前session
</li>
<li>opcontrol &ndash;start &ndash;no-vmlinux &ndash;image=image &ndash;separate=lib  # 开启daemon程序并且剖析
</li>
<li>执行程序
</li>
<li>opcontrol &ndash;dump # dump剖析数据
</li>
<li>opcontrol &ndash;shutdown  # 停止采样并且关闭daemon程序
</li>
</ul>


<p>
执行一次opcontrol &ndash;start,所使用的参数就会记录在/root/.oprofile/daemonrc文件。效果就等同于首先调用opcontrol &ndash;setup, 然后调用opcontrol &ndash;start.
</p>
</div>

</div>

<div id="outline-container-3-2" class="outline-4">
<h4 id="sec-3-2"><span class="section-number-4">3.2</span> opreport</h4>
<div class="outline-text-4" id="text-3-2">

<p>opreport包含两类参数，一类是过滤参数用于通知应用打印出关于哪些方面的信息，一类是命令参数是关于如何打印出这方面的信息。
</p>
<p>
常用过滤参数如下，过滤参数值可以使用glob风格来指定：
</p><ul>
<li>session|session-exclude:sessionlist # 按照session名称过滤
</li>
<li>image|image-exclude:imagelist # 按照imgae名字过滤
</li>
<li>event:eventlist # 按照event进行过滤
</li>
<li>count:countlist # 按照计数器进行过滤
</li>
<li>unit-mask:masklist # 按照mask进行过滤
</li>
<li>cpu:cpulist # 按照cpu编号过滤
</li>
<li>tgid:pidlist # 按照进程号过滤
</li>
<li>tid:tidlist # 按照线程号过滤
</li>
</ul>


<p>
常用命令参数如下：
</p><ul>
<li>-g|&ndash;debug-info # 显示每个symbol的文件和行号
</li>
<li>-D|&ndash;demangle=none|normal|smart # 对C++名字解构(normal)
</li>
<li>-i|&ndash;include-symbols|-e|&ndash;exclude-symbols # 符号选择
</li>
<li>-h|&ndash;help # 帮助信息
</li>
<li>-f|&ndash;long-filenames # 显示长文件名
</li>
<li>-r|&ndash;reverse-sort # 反向输出
</li>
<li>-l|&ndash;symbols # 显示symbol而不是binary image
</li>
<li>-o|&ndash;output-file # 输出文件
</li>
<li>-t|&ndash;threshold # sample的percentage超过这个值才显示
</li>
<li>-X|&ndash;xml # 产生XML输出信息
</li>
<li>&ndash;session-dir=&lt;dir&gt; # 存放session目录(/var/lib/oprofile)
</li>
</ul>


<p>
常用用法如下：
</p><ul>
<li>opreport -l image:&lt;image&gt; -o profile.log # 产生profile.log.
</li>
</ul>


</div>

</div>

<div id="outline-container-3-3" class="outline-4">
<h4 id="sec-3-3"><span class="section-number-4">3.3</span> opannotate</h4>
<div class="outline-text-4" id="text-3-3">

<p>常用命令参数如下：
</p><ul>
<li>-a|&ndash;assembly # 产生汇编文件注释
</li>
<li>-b|&ndash;base-dirs # 将被strip掉的调试信息中源文件绝对路径前缀
</li>
<li>-d|&ndash;search-dirs # 源文件搜索路径
<ul>
<li>这两个选项配合使用场景是，如果我是用/tmp/a.cc编译出来的话，那么debug信息里面存放的就是/tmp/a.cc的路径。如果我们源代码在其他路径比如/home/tmp/a.cc的话，那么就不能够进行annotate.
</li>
<li>这个问题可以使用上面两个参数解决。我们可以指定-b /tmp -d /home/tmp,这样debug信息中首先将/tmp stripped掉，然后拿a.cc在/home/tmp下面搜索。
</li>
</ul>

</li>
<li>-D|&ndash;demangle=none|normal|smart # 对C++名字解构(normal)
</li>
<li>-i|&ndash;include-symbols|-e|&ndash;exclude-symbols # 符号选择
</li>
<li>&ndash;include-file|&ndash;exclude-file # 文件选择
</li>
<li>-t|&ndash;threshold # sample的percentage超过这个值才显示
</li>
<li>-s|&ndash;source # 产生源文件注释
</li>
<li>-o|&ndash;output-dir # 输出目录
</li>
<li>&ndash;help|&ndash;usage # 帮助信息
</li>
</ul>


<p>
常用方法如下:
</p><ul>
<li>opannotate -a &lt;image&gt; &gt; profile.asm # 产生汇编文件注释.profile.asm是结果.
</li>
<li>opannotate -s &ndash;output-dir=. &lt;image&gt; # 产生源文件注释.在当前目录下面产生.
</li>
</ul>

</div>
</div>
</div>
</div>

<div id="postamble">
<p class="creator"><a href="http://orgmode.org">Org</a> version 7.9.3f with <a href="http://www.gnu.org/software/emacs/">Emacs</a> version 24</p>

</div>
<!-- DISQUS BEGIN --><div id="disqus_thread"></div><script type="text/javascript">/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * *//* required: replace example with your forum shortname  */var disqus_shortname = 'dirlt';var disqus_identifier = 'oprofile-obsolete.html';var disqus_title = 'oprofile-obsolete.html';var disqus_url = 'http://dirlt.com/oprofile-obsolete.html';/* * * DON'T EDIT BELOW THIS LINE * * */(function() {var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);})();</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a><!-- DISQUS END --></body>
</html>
